Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> declaration_statement
Rule 5     statement -> synonym_statement
Rule 6     statement -> newmode_statement
Rule 7     statement -> procedure_statement
Rule 8     statement -> action_statement
Rule 9     declaration_statement -> DCL declaration_list SEMI
Rule 10    declaration_list -> declaration
Rule 11    declaration_list -> declaration_list COMMA declaration
Rule 12    declaration -> identifier_list mode initialization
Rule 13    declaration -> identifier_list mode
Rule 14    initialization -> ASSIGN expression
Rule 15    identifier_list -> identifier
Rule 16    identifier_list -> identifier_list COMMA identifier
Rule 17    identifier -> ID
Rule 18    synonym_statement -> SYN synonym_list SEMI
Rule 19    synonym_list -> synonym_definition
Rule 20    synonym_list -> synonym_list COMMA synonym_definition
Rule 21    synonym_definition -> identifier_list mode ASSIGN constant_expression
Rule 22    synonym_definition -> identifier_list ASSIGN constant_expression
Rule 23    constant_expression -> expression
Rule 24    newmode_statement -> TYPE newmode_list
Rule 25    newmode_list -> mode_definition
Rule 26    newmode_list -> newmode_list COMMA mode_definition
Rule 27    mode_definition -> identifier_list mode
Rule 28    mode -> mode_name
Rule 29    mode -> discrete_mode
Rule 30    mode -> reference_mode
Rule 31    mode -> composite_mode
Rule 32    discrete_mode -> integer_mode
Rule 33    discrete_mode -> boolean_mode
Rule 34    discrete_mode -> character_mode
Rule 35    discrete_mode -> discrete_range_mode
Rule 36    integer_mode -> INT
Rule 37    boolean_mode -> BOOL
Rule 38    character_mode -> CHAR
Rule 39    discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN
Rule 40    discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN
Rule 41    mode_name -> identifier
Rule 42    discrete_mode_name -> identifier
Rule 43    literal_range -> ICONST COLON ICONST
Rule 44    reference_mode -> REF mode
Rule 45    composite_mode -> string_mode
Rule 46    composite_mode -> array_mode
Rule 47    string_mode -> CHARS LBRACKET string_length RBRACKET
Rule 48    string_length -> ICONST
Rule 49    array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode
Rule 50    array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
Rule 51    index_mode_list -> index_mode
Rule 52    index_mode_list -> index_mode_list COMMA index_mode
Rule 53    index_mode -> discrete_mode
Rule 54    index_mode -> literal_range
Rule 55    element_mode -> mode
Rule 56    location -> dereferenced_reference
Rule 57    location -> string_element
Rule 58    location -> string_slice
Rule 59    location -> array_element
Rule 60    location -> array_slice
Rule 61    location -> call_action
Rule 62    dereferenced_reference -> location ARROW
Rule 63    string_element -> identifier LBRACKET ICONST RBRACKET
Rule 64    string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET
Rule 65    array_element -> location LBRACKET expression_list RBRACKET
Rule 66    expression_list -> expression
Rule 67    expression_list -> expression_list COMMA expression
Rule 68    array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET
Rule 69    primitive_value -> literal
Rule 70    primitive_value -> value_array_element
Rule 71    primitive_value -> value_array_slice
Rule 72    primitive_value -> parenthesized_expression
Rule 73    literal -> ICONST
Rule 74    literal -> FALSE
Rule 75    literal -> TRUE
Rule 76    literal -> CCONST
Rule 77    literal -> NULL
Rule 78    literal -> SCONST
Rule 79    value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET
Rule 80    value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET
Rule 81    array_primitive_value -> primitive_value
Rule 82    parenthesized_expression -> LPAREN expression RPAREN
Rule 83    expression -> binop
Rule 84    expression -> conditional_expression
Rule 85    conditional_expression -> IF boolean_expression then_expression else_expression FI
Rule 86    conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI
Rule 87    boolean_expression -> expression
Rule 88    then_expression -> THEN expression
Rule 89    else_expression -> ELSE expression
Rule 90    elsif_expression -> ELSIF boolean_expression then_expression
Rule 91    elsif_expression -> elsif_expression ELSIF boolean_expression then_expression
Rule 92    binop -> operand
Rule 93    binop -> binop AND binop
Rule 94    binop -> binop OR binop
Rule 95    binop -> binop EQ binop
Rule 96    binop -> binop NEQ binop
Rule 97    binop -> binop GT binop
Rule 98    binop -> binop GE binop
Rule 99    binop -> binop LT binop
Rule 100   binop -> binop LE binop
Rule 101   binop -> binop PLUS binop
Rule 102   binop -> binop MINUS binop
Rule 103   binop -> binop TIMES binop
Rule 104   binop -> binop DIVIDE binop
Rule 105   binop -> binop MOD binop
Rule 106   binop -> binop NOT binop
Rule 107   binop -> binop IN binop
Rule 108   binop -> binop CONCAT binop
Rule 109   operand -> MINUS operand1
Rule 110   operand -> NOT operand1
Rule 111   operand -> location
Rule 112   operand -> primitive_value
Rule 113   operand -> identifier
Rule 114   operand1 -> location
Rule 115   operand1 -> referenced_location
Rule 116   operand1 -> primitive_value
Rule 117   referenced_location -> ARROW location
Rule 118   action_statement -> identifier COLON action SEMI
Rule 119   action_statement -> action SEMI
Rule 120   action_statement_list -> action_statement
Rule 121   action_statement_list -> action_statement_list action_statement
Rule 122   action -> if_action
Rule 123   action -> do_action
Rule 124   action -> assignment_action
Rule 125   action -> call_action
Rule 126   action -> exit_action
Rule 127   action -> return_action
Rule 128   action -> result_action
Rule 129   assignment_action -> location assigning_operator expression
Rule 130   assignment_action -> identifier assigning_operator expression
Rule 131   assigning_operator -> PLUS ASSIGN
Rule 132   assigning_operator -> MINUS ASSIGN
Rule 133   assigning_operator -> TIMES ASSIGN
Rule 134   assigning_operator -> DIVIDE ASSIGN
Rule 135   assigning_operator -> MOD ASSIGN
Rule 136   assigning_operator -> CONCAT ASSIGN
Rule 137   assigning_operator -> ASSIGN
Rule 138   if_action -> IF boolean_expression then_clause else_clause FI
Rule 139   if_action -> IF boolean_expression then_clause FI
Rule 140   then_clause -> THEN action_statement_list
Rule 141   then_clause -> THEN
Rule 142   else_clause -> ELSE action_statement_list
Rule 143   else_clause -> ELSE
Rule 144   do_action -> DO control_part SEMI action_statement_list OD
Rule 145   do_action -> DO control_part SEMI OD
Rule 146   do_action -> DO action_statement_list OD
Rule 147   control_part -> for_control while_control
Rule 148   control_part -> for_control
Rule 149   control_part -> while_control
Rule 150   for_control -> FOR iteration
Rule 151   iteration -> step_enumeration
Rule 152   iteration -> range_enumeration
Rule 153   step_enumeration -> loop_counter ASSIGN start_value step_value DOWN end_value
Rule 154   step_enumeration -> loop_counter ASSIGN start_value DOWN end_value
Rule 155   step_enumeration -> loop_counter ASSIGN start_value step_value end_value
Rule 156   step_enumeration -> loop_counter ASSIGN start_value end_value
Rule 157   loop_counter -> identifier
Rule 158   start_value -> discrete_expression
Rule 159   step_value -> BY ICONST
Rule 160   end_value -> TO discrete_expression
Rule 161   discrete_expression -> expression
Rule 162   range_enumeration -> loop_counter DOWN IN discrete_mode_name
Rule 163   range_enumeration -> loop_counter IN discrete_mode_name
Rule 164   while_control -> WHILE boolean_expression
Rule 165   call_action -> procedure_call
Rule 166   call_action -> builtin_call
Rule 167   procedure_call -> identifier LPAREN parameter_list RPAREN
Rule 168   procedure_call -> identifier LPAREN RPAREN
Rule 169   parameter_list -> expression
Rule 170   parameter_list -> parameter_list COMMA expression
Rule 171   exit_action -> EXIT identifier
Rule 172   return_action -> RETURN expression
Rule 173   return_action -> RETURN
Rule 174   result_action -> RESULT expression
Rule 175   builtin_call -> builtin_name LPAREN parameter_list RPAREN
Rule 176   builtin_call -> builtin_name LPAREN RPAREN
Rule 177   builtin_name -> NUM
Rule 178   builtin_name -> PRED
Rule 179   builtin_name -> SUCC
Rule 180   builtin_name -> UPPER
Rule 181   builtin_name -> LOWER
Rule 182   builtin_name -> LENGTH
Rule 183   builtin_name -> READ
Rule 184   builtin_name -> PRINT
Rule 185   procedure_statement -> identifier COLON procedure_definition SEMI
Rule 186   procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END
Rule 187   procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_list END
Rule 188   procedure_definition -> PROC LPAREN RPAREN SEMI statement_list END
Rule 189   formal_parameter_list -> formal_parameter
Rule 190   formal_parameter_list -> formal_parameter_list COMMA formal_parameter
Rule 191   formal_parameter -> identifier_list parameter_spec
Rule 192   result_spec -> RETURNS LPAREN parameter_spec RPAREN
Rule 193   parameter_spec -> mode LOC
Rule 194   parameter_spec -> mode

Terminals, with rules where they appear

AND                  : 93
ARRAY                : 49 50
ARROW                : 62 117
ASSIGN               : 14 21 22 131 132 133 134 135 136 137 153 154 155 156
BOOL                 : 37
BY                   : 159
CCONST               : 76
CHAR                 : 38
CHARS                : 47
COLON                : 43 64 68 80 118 185
COMMA                : 11 16 20 26 50 52 67 170 190
CONCAT               : 108 136
DCL                  : 9
DIVIDE               : 104 134
DO                   : 144 145 146
DOWN                 : 153 154 162
ELSE                 : 89 142 143
ELSIF                : 90 91
END                  : 186 187 188
EQ                   : 95
EXIT                 : 171
FALSE                : 74
FI                   : 85 86 138 139
FOR                  : 150
GE                   : 98
GT                   : 97
ICONST               : 43 43 48 63 64 64 68 68 73 159
ID                   : 17
IF                   : 85 86 138 139
IN                   : 107 162 163
INT                  : 36
LBRACKET             : 47 49 50 63 64 65 68 79 80
LE                   : 100
LENGTH               : 182
LOC                  : 193
LOWER                : 181
LPAREN               : 39 40 82 167 168 175 176 186 187 188 192
LT                   : 99
MINUS                : 102 109 132
MOD                  : 105 135
NEQ                  : 96
NOT                  : 106 110
NULL                 : 77
NUM                  : 177
OD                   : 144 145 146
OR                   : 94
PLUS                 : 101 131
PRED                 : 178
PRINT                : 184
PROC                 : 186 187 188
RBRACKET             : 47 49 50 63 64 65 68 79 80
READ                 : 183
REF                  : 44
RESULT               : 174
RETURN               : 172 173
RETURNS              : 192
RPAREN               : 39 40 82 167 168 175 176 186 187 188 192
SCONST               : 78
SEMI                 : 9 18 118 119 144 145 185 186 187 188
SUCC                 : 179
SYN                  : 18
THEN                 : 88 140 141
TIMES                : 103 133
TO                   : 160
TRUE                 : 75
TYPE                 : 24
UPPER                : 180
WHILE                : 164
error                : 

Nonterminals, with rules where they appear

action               : 118 119
action_statement     : 8 120 121
action_statement_list : 121 140 142 144 146
array_element        : 59
array_mode           : 46
array_primitive_value : 79 80
array_slice          : 60
assigning_operator   : 129 130
assignment_action    : 124
binop                : 83 93 93 94 94 95 95 96 96 97 97 98 98 99 99 100 100 101 101 102 102 103 103 104 104 105 105 106 106 107 107 108 108
boolean_expression   : 85 86 90 91 138 139 164
boolean_mode         : 33
builtin_call         : 166
builtin_name         : 175 176
call_action          : 61 125
character_mode       : 34
composite_mode       : 31
conditional_expression : 84
constant_expression  : 21 22
control_part         : 144 145
declaration          : 10 11
declaration_list     : 9 11
declaration_statement : 4
dereferenced_reference : 56
discrete_expression  : 158 160
discrete_mode        : 29 40 53
discrete_mode_name   : 39 162 163
discrete_range_mode  : 35
do_action            : 123
element_mode         : 49 50
else_clause          : 138
else_expression      : 85 86
elsif_expression     : 86 91
end_value            : 153 154 155 156
exit_action          : 126
expression           : 14 23 66 67 80 80 82 87 88 89 129 130 161 169 170 172 174
expression_list      : 65 67 79
for_control          : 147 148
formal_parameter     : 189 190
formal_parameter_list : 186 187 190
identifier           : 15 16 41 42 63 64 113 118 130 157 167 168 171 185
identifier_list      : 12 13 16 21 22 27 191
if_action            : 122
index_mode           : 49 50 51 52
index_mode_list      : 50 52
initialization       : 12
integer_mode         : 32
iteration            : 150
literal              : 69
literal_range        : 39 40 54
location             : 62 65 68 111 114 117 129
loop_counter         : 153 154 155 156 162 163
mode                 : 12 13 21 27 44 55 193 194
mode_definition      : 25 26
mode_name            : 28
newmode_list         : 24 26
newmode_statement    : 6
operand              : 92
operand1             : 109 110
parameter_list       : 167 170 175
parameter_spec       : 191 192
parenthesized_expression : 72
primitive_value      : 81 112 116
procedure_call       : 165
procedure_definition : 185
procedure_statement  : 7
program              : 0
range_enumeration    : 152
reference_mode       : 30
referenced_location  : 115
result_action        : 128
result_spec          : 186
return_action        : 127
start_value          : 153 154 155 156
statement            : 2 3
statement_list       : 1 3 186 187 188
step_enumeration     : 151
step_value           : 153 155
string_element       : 57
string_length        : 47
string_mode          : 45
string_slice         : 58
synonym_definition   : 19 20
synonym_list         : 18 20
synonym_statement    : 5
then_clause          : 138 139
then_expression      : 85 86 90 91
value_array_element  : 70
value_array_slice    : 71
while_control        : 147 149

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (185) procedure_statement -> . identifier COLON procedure_definition SEMI
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    program                        shift and go to state 20
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 22
    statement_list                 shift and go to state 26
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 1

    (124) action -> assignment_action .

    SEMI            reduce using rule 124 (action -> assignment_action .)


state 2

    (181) builtin_name -> LOWER .

    LPAREN          reduce using rule 181 (builtin_name -> LOWER .)


state 3

    (172) return_action -> RETURN . expression
    (173) return_action -> RETURN .
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    SEMI            reduce using rule 173 (return_action -> RETURN .)
    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 65
    primitive_value                shift and go to state 66

state 4

    (144) do_action -> DO . control_part SEMI action_statement_list OD
    (145) do_action -> DO . control_part SEMI OD
    (146) do_action -> DO . action_statement_list OD
    (147) control_part -> . for_control while_control
    (148) control_part -> . for_control
    (149) control_part -> . while_control
    (120) action_statement_list -> . action_statement
    (121) action_statement_list -> . action_statement_list action_statement
    (150) for_control -> . FOR iteration
    (164) while_control -> . WHILE boolean_expression
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    FOR             shift and go to state 71
    WHILE           shift and go to state 67
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    action_statement_list          shift and go to state 68
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    control_part                   shift and go to state 69
    while_control                  shift and go to state 72
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    for_control                    shift and go to state 70
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 73
    action_statement               shift and go to state 74

state 5

    (5) statement -> synonym_statement .

    END             reduce using rule 5 (statement -> synonym_statement .)
    DCL             reduce using rule 5 (statement -> synonym_statement .)
    SYN             reduce using rule 5 (statement -> synonym_statement .)
    TYPE            reduce using rule 5 (statement -> synonym_statement .)
    ID              reduce using rule 5 (statement -> synonym_statement .)
    IF              reduce using rule 5 (statement -> synonym_statement .)
    DO              reduce using rule 5 (statement -> synonym_statement .)
    EXIT            reduce using rule 5 (statement -> synonym_statement .)
    RETURN          reduce using rule 5 (statement -> synonym_statement .)
    RESULT          reduce using rule 5 (statement -> synonym_statement .)
    NUM             reduce using rule 5 (statement -> synonym_statement .)
    PRED            reduce using rule 5 (statement -> synonym_statement .)
    SUCC            reduce using rule 5 (statement -> synonym_statement .)
    UPPER           reduce using rule 5 (statement -> synonym_statement .)
    LOWER           reduce using rule 5 (statement -> synonym_statement .)
    LENGTH          reduce using rule 5 (statement -> synonym_statement .)
    READ            reduce using rule 5 (statement -> synonym_statement .)
    PRINT           reduce using rule 5 (statement -> synonym_statement .)
    $end            reduce using rule 5 (statement -> synonym_statement .)


state 6

    (59) location -> array_element .

    ARROW           reduce using rule 59 (location -> array_element .)
    LBRACKET        reduce using rule 59 (location -> array_element .)
    AND             reduce using rule 59 (location -> array_element .)
    OR              reduce using rule 59 (location -> array_element .)
    EQ              reduce using rule 59 (location -> array_element .)
    NEQ             reduce using rule 59 (location -> array_element .)
    GT              reduce using rule 59 (location -> array_element .)
    GE              reduce using rule 59 (location -> array_element .)
    LT              reduce using rule 59 (location -> array_element .)
    LE              reduce using rule 59 (location -> array_element .)
    PLUS            reduce using rule 59 (location -> array_element .)
    MINUS           reduce using rule 59 (location -> array_element .)
    TIMES           reduce using rule 59 (location -> array_element .)
    DIVIDE          reduce using rule 59 (location -> array_element .)
    MOD             reduce using rule 59 (location -> array_element .)
    NOT             reduce using rule 59 (location -> array_element .)
    IN              reduce using rule 59 (location -> array_element .)
    CONCAT          reduce using rule 59 (location -> array_element .)
    DOWN            reduce using rule 59 (location -> array_element .)
    BY              reduce using rule 59 (location -> array_element .)
    TO              reduce using rule 59 (location -> array_element .)
    SEMI            reduce using rule 59 (location -> array_element .)
    THEN            reduce using rule 59 (location -> array_element .)
    RPAREN          reduce using rule 59 (location -> array_element .)
    COMMA           reduce using rule 59 (location -> array_element .)
    RBRACKET        reduce using rule 59 (location -> array_element .)
    COLON           reduce using rule 59 (location -> array_element .)
    ELSE            reduce using rule 59 (location -> array_element .)
    ELSIF           reduce using rule 59 (location -> array_element .)
    FI              reduce using rule 59 (location -> array_element .)
    WHILE           reduce using rule 59 (location -> array_element .)
    ASSIGN          reduce using rule 59 (location -> array_element .)


state 7

    (128) action -> result_action .

    SEMI            reduce using rule 128 (action -> result_action .)


state 8

    (175) builtin_call -> builtin_name . LPAREN parameter_list RPAREN
    (176) builtin_call -> builtin_name . LPAREN RPAREN

    LPAREN          shift and go to state 75


state 9

    (184) builtin_name -> PRINT .

    LPAREN          reduce using rule 184 (builtin_name -> PRINT .)


state 10

    (179) builtin_name -> SUCC .

    LPAREN          reduce using rule 179 (builtin_name -> SUCC .)


state 11

    (127) action -> return_action .

    SEMI            reduce using rule 127 (action -> return_action .)


state 12

    (165) call_action -> procedure_call .

    SEMI            reduce using rule 165 (call_action -> procedure_call .)
    ARROW           reduce using rule 165 (call_action -> procedure_call .)
    LBRACKET        reduce using rule 165 (call_action -> procedure_call .)
    PLUS            reduce using rule 165 (call_action -> procedure_call .)
    MINUS           reduce using rule 165 (call_action -> procedure_call .)
    TIMES           reduce using rule 165 (call_action -> procedure_call .)
    DIVIDE          reduce using rule 165 (call_action -> procedure_call .)
    MOD             reduce using rule 165 (call_action -> procedure_call .)
    CONCAT          reduce using rule 165 (call_action -> procedure_call .)
    ASSIGN          reduce using rule 165 (call_action -> procedure_call .)
    AND             reduce using rule 165 (call_action -> procedure_call .)
    OR              reduce using rule 165 (call_action -> procedure_call .)
    EQ              reduce using rule 165 (call_action -> procedure_call .)
    NEQ             reduce using rule 165 (call_action -> procedure_call .)
    GT              reduce using rule 165 (call_action -> procedure_call .)
    GE              reduce using rule 165 (call_action -> procedure_call .)
    LT              reduce using rule 165 (call_action -> procedure_call .)
    LE              reduce using rule 165 (call_action -> procedure_call .)
    NOT             reduce using rule 165 (call_action -> procedure_call .)
    IN              reduce using rule 165 (call_action -> procedure_call .)
    THEN            reduce using rule 165 (call_action -> procedure_call .)
    RPAREN          reduce using rule 165 (call_action -> procedure_call .)
    COMMA           reduce using rule 165 (call_action -> procedure_call .)
    RBRACKET        reduce using rule 165 (call_action -> procedure_call .)
    COLON           reduce using rule 165 (call_action -> procedure_call .)
    ELSE            reduce using rule 165 (call_action -> procedure_call .)
    ELSIF           reduce using rule 165 (call_action -> procedure_call .)
    DOWN            reduce using rule 165 (call_action -> procedure_call .)
    BY              reduce using rule 165 (call_action -> procedure_call .)
    TO              reduce using rule 165 (call_action -> procedure_call .)
    FI              reduce using rule 165 (call_action -> procedure_call .)
    WHILE           reduce using rule 165 (call_action -> procedure_call .)


state 13

    (123) action -> do_action .

    SEMI            reduce using rule 123 (action -> do_action .)


state 14

    (122) action -> if_action .

    SEMI            reduce using rule 122 (action -> if_action .)


state 15

    (57) location -> string_element .

    ARROW           reduce using rule 57 (location -> string_element .)
    LBRACKET        reduce using rule 57 (location -> string_element .)
    AND             reduce using rule 57 (location -> string_element .)
    OR              reduce using rule 57 (location -> string_element .)
    EQ              reduce using rule 57 (location -> string_element .)
    NEQ             reduce using rule 57 (location -> string_element .)
    GT              reduce using rule 57 (location -> string_element .)
    GE              reduce using rule 57 (location -> string_element .)
    LT              reduce using rule 57 (location -> string_element .)
    LE              reduce using rule 57 (location -> string_element .)
    PLUS            reduce using rule 57 (location -> string_element .)
    MINUS           reduce using rule 57 (location -> string_element .)
    TIMES           reduce using rule 57 (location -> string_element .)
    DIVIDE          reduce using rule 57 (location -> string_element .)
    MOD             reduce using rule 57 (location -> string_element .)
    NOT             reduce using rule 57 (location -> string_element .)
    IN              reduce using rule 57 (location -> string_element .)
    CONCAT          reduce using rule 57 (location -> string_element .)
    DOWN            reduce using rule 57 (location -> string_element .)
    BY              reduce using rule 57 (location -> string_element .)
    TO              reduce using rule 57 (location -> string_element .)
    SEMI            reduce using rule 57 (location -> string_element .)
    THEN            reduce using rule 57 (location -> string_element .)
    RPAREN          reduce using rule 57 (location -> string_element .)
    COMMA           reduce using rule 57 (location -> string_element .)
    RBRACKET        reduce using rule 57 (location -> string_element .)
    COLON           reduce using rule 57 (location -> string_element .)
    ELSE            reduce using rule 57 (location -> string_element .)
    ELSIF           reduce using rule 57 (location -> string_element .)
    FI              reduce using rule 57 (location -> string_element .)
    WHILE           reduce using rule 57 (location -> string_element .)
    ASSIGN          reduce using rule 57 (location -> string_element .)


state 16

    (9) declaration_statement -> DCL . declaration_list SEMI
    (10) declaration_list -> . declaration
    (11) declaration_list -> . declaration_list COMMA declaration
    (12) declaration -> . identifier_list mode initialization
    (13) declaration -> . identifier_list mode
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier_list                shift and go to state 79
    declaration_list               shift and go to state 77
    declaration                    shift and go to state 78
    identifier                     shift and go to state 76

state 17

    (182) builtin_name -> LENGTH .

    LPAREN          reduce using rule 182 (builtin_name -> LENGTH .)


state 18

    (7) statement -> procedure_statement .

    END             reduce using rule 7 (statement -> procedure_statement .)
    DCL             reduce using rule 7 (statement -> procedure_statement .)
    SYN             reduce using rule 7 (statement -> procedure_statement .)
    TYPE            reduce using rule 7 (statement -> procedure_statement .)
    ID              reduce using rule 7 (statement -> procedure_statement .)
    IF              reduce using rule 7 (statement -> procedure_statement .)
    DO              reduce using rule 7 (statement -> procedure_statement .)
    EXIT            reduce using rule 7 (statement -> procedure_statement .)
    RETURN          reduce using rule 7 (statement -> procedure_statement .)
    RESULT          reduce using rule 7 (statement -> procedure_statement .)
    NUM             reduce using rule 7 (statement -> procedure_statement .)
    PRED            reduce using rule 7 (statement -> procedure_statement .)
    SUCC            reduce using rule 7 (statement -> procedure_statement .)
    UPPER           reduce using rule 7 (statement -> procedure_statement .)
    LOWER           reduce using rule 7 (statement -> procedure_statement .)
    LENGTH          reduce using rule 7 (statement -> procedure_statement .)
    READ            reduce using rule 7 (statement -> procedure_statement .)
    PRINT           reduce using rule 7 (statement -> procedure_statement .)
    $end            reduce using rule 7 (statement -> procedure_statement .)


state 19

    (183) builtin_name -> READ .

    LPAREN          reduce using rule 183 (builtin_name -> READ .)


state 20

    (0) S' -> program .



state 21

    (129) assignment_action -> location . assigning_operator expression
    (62) dereferenced_reference -> location . ARROW
    (65) array_element -> location . LBRACKET expression_list RBRACKET
    (68) array_slice -> location . LBRACKET ICONST COLON ICONST RBRACKET
    (131) assigning_operator -> . PLUS ASSIGN
    (132) assigning_operator -> . MINUS ASSIGN
    (133) assigning_operator -> . TIMES ASSIGN
    (134) assigning_operator -> . DIVIDE ASSIGN
    (135) assigning_operator -> . MOD ASSIGN
    (136) assigning_operator -> . CONCAT ASSIGN
    (137) assigning_operator -> . ASSIGN

    ARROW           shift and go to state 85
    LBRACKET        shift and go to state 84
    PLUS            shift and go to state 83
    MINUS           shift and go to state 82
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 89
    CONCAT          shift and go to state 88
    ASSIGN          shift and go to state 87

    assigning_operator             shift and go to state 80

state 22

    (2) statement_list -> statement .

    END             reduce using rule 2 (statement_list -> statement .)
    DCL             reduce using rule 2 (statement_list -> statement .)
    SYN             reduce using rule 2 (statement_list -> statement .)
    TYPE            reduce using rule 2 (statement_list -> statement .)
    ID              reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    DO              reduce using rule 2 (statement_list -> statement .)
    EXIT            reduce using rule 2 (statement_list -> statement .)
    RETURN          reduce using rule 2 (statement_list -> statement .)
    RESULT          reduce using rule 2 (statement_list -> statement .)
    NUM             reduce using rule 2 (statement_list -> statement .)
    PRED            reduce using rule 2 (statement_list -> statement .)
    SUCC            reduce using rule 2 (statement_list -> statement .)
    UPPER           reduce using rule 2 (statement_list -> statement .)
    LOWER           reduce using rule 2 (statement_list -> statement .)
    LENGTH          reduce using rule 2 (statement_list -> statement .)
    READ            reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)


state 23

    (58) location -> string_slice .

    ARROW           reduce using rule 58 (location -> string_slice .)
    LBRACKET        reduce using rule 58 (location -> string_slice .)
    AND             reduce using rule 58 (location -> string_slice .)
    OR              reduce using rule 58 (location -> string_slice .)
    EQ              reduce using rule 58 (location -> string_slice .)
    NEQ             reduce using rule 58 (location -> string_slice .)
    GT              reduce using rule 58 (location -> string_slice .)
    GE              reduce using rule 58 (location -> string_slice .)
    LT              reduce using rule 58 (location -> string_slice .)
    LE              reduce using rule 58 (location -> string_slice .)
    PLUS            reduce using rule 58 (location -> string_slice .)
    MINUS           reduce using rule 58 (location -> string_slice .)
    TIMES           reduce using rule 58 (location -> string_slice .)
    DIVIDE          reduce using rule 58 (location -> string_slice .)
    MOD             reduce using rule 58 (location -> string_slice .)
    NOT             reduce using rule 58 (location -> string_slice .)
    IN              reduce using rule 58 (location -> string_slice .)
    CONCAT          reduce using rule 58 (location -> string_slice .)
    DOWN            reduce using rule 58 (location -> string_slice .)
    BY              reduce using rule 58 (location -> string_slice .)
    TO              reduce using rule 58 (location -> string_slice .)
    SEMI            reduce using rule 58 (location -> string_slice .)
    THEN            reduce using rule 58 (location -> string_slice .)
    RPAREN          reduce using rule 58 (location -> string_slice .)
    COMMA           reduce using rule 58 (location -> string_slice .)
    RBRACKET        reduce using rule 58 (location -> string_slice .)
    COLON           reduce using rule 58 (location -> string_slice .)
    ELSE            reduce using rule 58 (location -> string_slice .)
    ELSIF           reduce using rule 58 (location -> string_slice .)
    FI              reduce using rule 58 (location -> string_slice .)
    WHILE           reduce using rule 58 (location -> string_slice .)
    ASSIGN          reduce using rule 58 (location -> string_slice .)


state 24

    (166) call_action -> builtin_call .

    SEMI            reduce using rule 166 (call_action -> builtin_call .)
    ARROW           reduce using rule 166 (call_action -> builtin_call .)
    LBRACKET        reduce using rule 166 (call_action -> builtin_call .)
    PLUS            reduce using rule 166 (call_action -> builtin_call .)
    MINUS           reduce using rule 166 (call_action -> builtin_call .)
    TIMES           reduce using rule 166 (call_action -> builtin_call .)
    DIVIDE          reduce using rule 166 (call_action -> builtin_call .)
    MOD             reduce using rule 166 (call_action -> builtin_call .)
    CONCAT          reduce using rule 166 (call_action -> builtin_call .)
    ASSIGN          reduce using rule 166 (call_action -> builtin_call .)
    AND             reduce using rule 166 (call_action -> builtin_call .)
    OR              reduce using rule 166 (call_action -> builtin_call .)
    EQ              reduce using rule 166 (call_action -> builtin_call .)
    NEQ             reduce using rule 166 (call_action -> builtin_call .)
    GT              reduce using rule 166 (call_action -> builtin_call .)
    GE              reduce using rule 166 (call_action -> builtin_call .)
    LT              reduce using rule 166 (call_action -> builtin_call .)
    LE              reduce using rule 166 (call_action -> builtin_call .)
    NOT             reduce using rule 166 (call_action -> builtin_call .)
    IN              reduce using rule 166 (call_action -> builtin_call .)
    THEN            reduce using rule 166 (call_action -> builtin_call .)
    RPAREN          reduce using rule 166 (call_action -> builtin_call .)
    COMMA           reduce using rule 166 (call_action -> builtin_call .)
    RBRACKET        reduce using rule 166 (call_action -> builtin_call .)
    COLON           reduce using rule 166 (call_action -> builtin_call .)
    ELSE            reduce using rule 166 (call_action -> builtin_call .)
    ELSIF           reduce using rule 166 (call_action -> builtin_call .)
    DOWN            reduce using rule 166 (call_action -> builtin_call .)
    BY              reduce using rule 166 (call_action -> builtin_call .)
    TO              reduce using rule 166 (call_action -> builtin_call .)
    FI              reduce using rule 166 (call_action -> builtin_call .)
    WHILE           reduce using rule 166 (call_action -> builtin_call .)


state 25

    (125) action -> call_action .
    (61) location -> call_action .

    SEMI            reduce using rule 125 (action -> call_action .)
    ARROW           reduce using rule 61 (location -> call_action .)
    LBRACKET        reduce using rule 61 (location -> call_action .)
    PLUS            reduce using rule 61 (location -> call_action .)
    MINUS           reduce using rule 61 (location -> call_action .)
    TIMES           reduce using rule 61 (location -> call_action .)
    DIVIDE          reduce using rule 61 (location -> call_action .)
    MOD             reduce using rule 61 (location -> call_action .)
    CONCAT          reduce using rule 61 (location -> call_action .)
    ASSIGN          reduce using rule 61 (location -> call_action .)


state 26

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (185) procedure_statement -> . identifier COLON procedure_definition SEMI
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    $end            reduce using rule 1 (program -> statement_list .)
    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 90
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 27

    (174) result_action -> RESULT . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 91
    primitive_value                shift and go to state 66

state 28

    (126) action -> exit_action .

    SEMI            reduce using rule 126 (action -> exit_action .)


state 29

    (177) builtin_name -> NUM .

    LPAREN          reduce using rule 177 (builtin_name -> NUM .)


state 30

    (6) statement -> newmode_statement .

    END             reduce using rule 6 (statement -> newmode_statement .)
    DCL             reduce using rule 6 (statement -> newmode_statement .)
    SYN             reduce using rule 6 (statement -> newmode_statement .)
    TYPE            reduce using rule 6 (statement -> newmode_statement .)
    ID              reduce using rule 6 (statement -> newmode_statement .)
    IF              reduce using rule 6 (statement -> newmode_statement .)
    DO              reduce using rule 6 (statement -> newmode_statement .)
    EXIT            reduce using rule 6 (statement -> newmode_statement .)
    RETURN          reduce using rule 6 (statement -> newmode_statement .)
    RESULT          reduce using rule 6 (statement -> newmode_statement .)
    NUM             reduce using rule 6 (statement -> newmode_statement .)
    PRED            reduce using rule 6 (statement -> newmode_statement .)
    SUCC            reduce using rule 6 (statement -> newmode_statement .)
    UPPER           reduce using rule 6 (statement -> newmode_statement .)
    LOWER           reduce using rule 6 (statement -> newmode_statement .)
    LENGTH          reduce using rule 6 (statement -> newmode_statement .)
    READ            reduce using rule 6 (statement -> newmode_statement .)
    PRINT           reduce using rule 6 (statement -> newmode_statement .)
    $end            reduce using rule 6 (statement -> newmode_statement .)


state 31

    (17) identifier -> ID .

    LBRACKET        reduce using rule 17 (identifier -> ID .)
    LPAREN          reduce using rule 17 (identifier -> ID .)
    AND             reduce using rule 17 (identifier -> ID .)
    OR              reduce using rule 17 (identifier -> ID .)
    EQ              reduce using rule 17 (identifier -> ID .)
    NEQ             reduce using rule 17 (identifier -> ID .)
    GT              reduce using rule 17 (identifier -> ID .)
    GE              reduce using rule 17 (identifier -> ID .)
    LT              reduce using rule 17 (identifier -> ID .)
    LE              reduce using rule 17 (identifier -> ID .)
    PLUS            reduce using rule 17 (identifier -> ID .)
    MINUS           reduce using rule 17 (identifier -> ID .)
    TIMES           reduce using rule 17 (identifier -> ID .)
    DIVIDE          reduce using rule 17 (identifier -> ID .)
    MOD             reduce using rule 17 (identifier -> ID .)
    NOT             reduce using rule 17 (identifier -> ID .)
    IN              reduce using rule 17 (identifier -> ID .)
    CONCAT          reduce using rule 17 (identifier -> ID .)
    THEN            reduce using rule 17 (identifier -> ID .)
    COMMA           reduce using rule 17 (identifier -> ID .)
    REF             reduce using rule 17 (identifier -> ID .)
    ID              reduce using rule 17 (identifier -> ID .)
    INT             reduce using rule 17 (identifier -> ID .)
    BOOL            reduce using rule 17 (identifier -> ID .)
    CHAR            reduce using rule 17 (identifier -> ID .)
    CHARS           reduce using rule 17 (identifier -> ID .)
    ARRAY           reduce using rule 17 (identifier -> ID .)
    COLON           reduce using rule 17 (identifier -> ID .)
    ASSIGN          reduce using rule 17 (identifier -> ID .)
    DCL             reduce using rule 17 (identifier -> ID .)
    SYN             reduce using rule 17 (identifier -> ID .)
    TYPE            reduce using rule 17 (identifier -> ID .)
    IF              reduce using rule 17 (identifier -> ID .)
    DO              reduce using rule 17 (identifier -> ID .)
    EXIT            reduce using rule 17 (identifier -> ID .)
    RETURN          reduce using rule 17 (identifier -> ID .)
    RESULT          reduce using rule 17 (identifier -> ID .)
    NUM             reduce using rule 17 (identifier -> ID .)
    PRED            reduce using rule 17 (identifier -> ID .)
    SUCC            reduce using rule 17 (identifier -> ID .)
    UPPER           reduce using rule 17 (identifier -> ID .)
    LOWER           reduce using rule 17 (identifier -> ID .)
    LENGTH          reduce using rule 17 (identifier -> ID .)
    READ            reduce using rule 17 (identifier -> ID .)
    PRINT           reduce using rule 17 (identifier -> ID .)
    $end            reduce using rule 17 (identifier -> ID .)
    END             reduce using rule 17 (identifier -> ID .)
    SEMI            reduce using rule 17 (identifier -> ID .)
    RPAREN          reduce using rule 17 (identifier -> ID .)
    RBRACKET        reduce using rule 17 (identifier -> ID .)
    ELSE            reduce using rule 17 (identifier -> ID .)
    ELSIF           reduce using rule 17 (identifier -> ID .)
    DOWN            reduce using rule 17 (identifier -> ID .)
    BY              reduce using rule 17 (identifier -> ID .)
    TO              reduce using rule 17 (identifier -> ID .)
    FI              reduce using rule 17 (identifier -> ID .)
    WHILE           reduce using rule 17 (identifier -> ID .)
    LOC             reduce using rule 17 (identifier -> ID .)


state 32

    (138) if_action -> IF . boolean_expression then_clause else_clause FI
    (139) if_action -> IF . boolean_expression then_clause FI
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    boolean_expression             shift and go to state 92
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 93
    primitive_value                shift and go to state 66

state 33

    (180) builtin_name -> UPPER .

    LPAREN          reduce using rule 180 (builtin_name -> UPPER .)


state 34

    (56) location -> dereferenced_reference .

    ARROW           reduce using rule 56 (location -> dereferenced_reference .)
    LBRACKET        reduce using rule 56 (location -> dereferenced_reference .)
    AND             reduce using rule 56 (location -> dereferenced_reference .)
    OR              reduce using rule 56 (location -> dereferenced_reference .)
    EQ              reduce using rule 56 (location -> dereferenced_reference .)
    NEQ             reduce using rule 56 (location -> dereferenced_reference .)
    GT              reduce using rule 56 (location -> dereferenced_reference .)
    GE              reduce using rule 56 (location -> dereferenced_reference .)
    LT              reduce using rule 56 (location -> dereferenced_reference .)
    LE              reduce using rule 56 (location -> dereferenced_reference .)
    PLUS            reduce using rule 56 (location -> dereferenced_reference .)
    MINUS           reduce using rule 56 (location -> dereferenced_reference .)
    TIMES           reduce using rule 56 (location -> dereferenced_reference .)
    DIVIDE          reduce using rule 56 (location -> dereferenced_reference .)
    MOD             reduce using rule 56 (location -> dereferenced_reference .)
    NOT             reduce using rule 56 (location -> dereferenced_reference .)
    IN              reduce using rule 56 (location -> dereferenced_reference .)
    CONCAT          reduce using rule 56 (location -> dereferenced_reference .)
    DOWN            reduce using rule 56 (location -> dereferenced_reference .)
    BY              reduce using rule 56 (location -> dereferenced_reference .)
    TO              reduce using rule 56 (location -> dereferenced_reference .)
    SEMI            reduce using rule 56 (location -> dereferenced_reference .)
    THEN            reduce using rule 56 (location -> dereferenced_reference .)
    RPAREN          reduce using rule 56 (location -> dereferenced_reference .)
    COMMA           reduce using rule 56 (location -> dereferenced_reference .)
    RBRACKET        reduce using rule 56 (location -> dereferenced_reference .)
    COLON           reduce using rule 56 (location -> dereferenced_reference .)
    ELSE            reduce using rule 56 (location -> dereferenced_reference .)
    ELSIF           reduce using rule 56 (location -> dereferenced_reference .)
    FI              reduce using rule 56 (location -> dereferenced_reference .)
    WHILE           reduce using rule 56 (location -> dereferenced_reference .)
    ASSIGN          reduce using rule 56 (location -> dereferenced_reference .)


state 35

    (24) newmode_statement -> TYPE . newmode_list
    (25) newmode_list -> . mode_definition
    (26) newmode_list -> . newmode_list COMMA mode_definition
    (27) mode_definition -> . identifier_list mode
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    mode_definition                shift and go to state 94
    newmode_list                   shift and go to state 95
    identifier_list                shift and go to state 96
    identifier                     shift and go to state 76

state 36

    (18) synonym_statement -> SYN . synonym_list SEMI
    (19) synonym_list -> . synonym_definition
    (20) synonym_list -> . synonym_list COMMA synonym_definition
    (21) synonym_definition -> . identifier_list mode ASSIGN constant_expression
    (22) synonym_definition -> . identifier_list ASSIGN constant_expression
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    synonym_definition             shift and go to state 97
    identifier_list                shift and go to state 99
    synonym_list                   shift and go to state 98
    identifier                     shift and go to state 76

state 37

    (4) statement -> declaration_statement .

    END             reduce using rule 4 (statement -> declaration_statement .)
    DCL             reduce using rule 4 (statement -> declaration_statement .)
    SYN             reduce using rule 4 (statement -> declaration_statement .)
    TYPE            reduce using rule 4 (statement -> declaration_statement .)
    ID              reduce using rule 4 (statement -> declaration_statement .)
    IF              reduce using rule 4 (statement -> declaration_statement .)
    DO              reduce using rule 4 (statement -> declaration_statement .)
    EXIT            reduce using rule 4 (statement -> declaration_statement .)
    RETURN          reduce using rule 4 (statement -> declaration_statement .)
    RESULT          reduce using rule 4 (statement -> declaration_statement .)
    NUM             reduce using rule 4 (statement -> declaration_statement .)
    PRED            reduce using rule 4 (statement -> declaration_statement .)
    SUCC            reduce using rule 4 (statement -> declaration_statement .)
    UPPER           reduce using rule 4 (statement -> declaration_statement .)
    LOWER           reduce using rule 4 (statement -> declaration_statement .)
    LENGTH          reduce using rule 4 (statement -> declaration_statement .)
    READ            reduce using rule 4 (statement -> declaration_statement .)
    PRINT           reduce using rule 4 (statement -> declaration_statement .)
    $end            reduce using rule 4 (statement -> declaration_statement .)


state 38

    (171) exit_action -> EXIT . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier                     shift and go to state 100

state 39

    (60) location -> array_slice .

    ARROW           reduce using rule 60 (location -> array_slice .)
    LBRACKET        reduce using rule 60 (location -> array_slice .)
    AND             reduce using rule 60 (location -> array_slice .)
    OR              reduce using rule 60 (location -> array_slice .)
    EQ              reduce using rule 60 (location -> array_slice .)
    NEQ             reduce using rule 60 (location -> array_slice .)
    GT              reduce using rule 60 (location -> array_slice .)
    GE              reduce using rule 60 (location -> array_slice .)
    LT              reduce using rule 60 (location -> array_slice .)
    LE              reduce using rule 60 (location -> array_slice .)
    PLUS            reduce using rule 60 (location -> array_slice .)
    MINUS           reduce using rule 60 (location -> array_slice .)
    TIMES           reduce using rule 60 (location -> array_slice .)
    DIVIDE          reduce using rule 60 (location -> array_slice .)
    MOD             reduce using rule 60 (location -> array_slice .)
    NOT             reduce using rule 60 (location -> array_slice .)
    IN              reduce using rule 60 (location -> array_slice .)
    CONCAT          reduce using rule 60 (location -> array_slice .)
    DOWN            reduce using rule 60 (location -> array_slice .)
    BY              reduce using rule 60 (location -> array_slice .)
    TO              reduce using rule 60 (location -> array_slice .)
    SEMI            reduce using rule 60 (location -> array_slice .)
    THEN            reduce using rule 60 (location -> array_slice .)
    RPAREN          reduce using rule 60 (location -> array_slice .)
    COMMA           reduce using rule 60 (location -> array_slice .)
    RBRACKET        reduce using rule 60 (location -> array_slice .)
    COLON           reduce using rule 60 (location -> array_slice .)
    ELSE            reduce using rule 60 (location -> array_slice .)
    ELSIF           reduce using rule 60 (location -> array_slice .)
    FI              reduce using rule 60 (location -> array_slice .)
    WHILE           reduce using rule 60 (location -> array_slice .)
    ASSIGN          reduce using rule 60 (location -> array_slice .)


state 40

    (119) action_statement -> action . SEMI

    SEMI            shift and go to state 101


state 41

    (185) procedure_statement -> identifier . COLON procedure_definition SEMI
    (118) action_statement -> identifier . COLON action SEMI
    (130) assignment_action -> identifier . assigning_operator expression
    (167) procedure_call -> identifier . LPAREN parameter_list RPAREN
    (168) procedure_call -> identifier . LPAREN RPAREN
    (63) string_element -> identifier . LBRACKET ICONST RBRACKET
    (64) string_slice -> identifier . LBRACKET ICONST COLON ICONST RBRACKET
    (131) assigning_operator -> . PLUS ASSIGN
    (132) assigning_operator -> . MINUS ASSIGN
    (133) assigning_operator -> . TIMES ASSIGN
    (134) assigning_operator -> . DIVIDE ASSIGN
    (135) assigning_operator -> . MOD ASSIGN
    (136) assigning_operator -> . CONCAT ASSIGN
    (137) assigning_operator -> . ASSIGN

    COLON           shift and go to state 104
    LPAREN          shift and go to state 105
    LBRACKET        shift and go to state 103
    PLUS            shift and go to state 83
    MINUS           shift and go to state 82
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 89
    CONCAT          shift and go to state 88
    ASSIGN          shift and go to state 87

    assigning_operator             shift and go to state 102

state 42

    (8) statement -> action_statement .

    END             reduce using rule 8 (statement -> action_statement .)
    DCL             reduce using rule 8 (statement -> action_statement .)
    SYN             reduce using rule 8 (statement -> action_statement .)
    TYPE            reduce using rule 8 (statement -> action_statement .)
    ID              reduce using rule 8 (statement -> action_statement .)
    IF              reduce using rule 8 (statement -> action_statement .)
    DO              reduce using rule 8 (statement -> action_statement .)
    EXIT            reduce using rule 8 (statement -> action_statement .)
    RETURN          reduce using rule 8 (statement -> action_statement .)
    RESULT          reduce using rule 8 (statement -> action_statement .)
    NUM             reduce using rule 8 (statement -> action_statement .)
    PRED            reduce using rule 8 (statement -> action_statement .)
    SUCC            reduce using rule 8 (statement -> action_statement .)
    UPPER           reduce using rule 8 (statement -> action_statement .)
    LOWER           reduce using rule 8 (statement -> action_statement .)
    LENGTH          reduce using rule 8 (statement -> action_statement .)
    READ            reduce using rule 8 (statement -> action_statement .)
    PRINT           reduce using rule 8 (statement -> action_statement .)
    $end            reduce using rule 8 (statement -> action_statement .)


state 43

    (178) builtin_name -> PRED .

    LPAREN          reduce using rule 178 (builtin_name -> PRED .)


state 44

    (82) parenthesized_expression -> LPAREN . expression RPAREN
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 106
    primitive_value                shift and go to state 66

state 45

    (72) primitive_value -> parenthesized_expression .

    AND             reduce using rule 72 (primitive_value -> parenthesized_expression .)
    OR              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    EQ              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    NEQ             reduce using rule 72 (primitive_value -> parenthesized_expression .)
    GT              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    GE              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    LT              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    LE              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    PLUS            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    MINUS           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    TIMES           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    DIVIDE          reduce using rule 72 (primitive_value -> parenthesized_expression .)
    MOD             reduce using rule 72 (primitive_value -> parenthesized_expression .)
    NOT             reduce using rule 72 (primitive_value -> parenthesized_expression .)
    IN              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    CONCAT          reduce using rule 72 (primitive_value -> parenthesized_expression .)
    SEMI            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    THEN            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    RPAREN          reduce using rule 72 (primitive_value -> parenthesized_expression .)
    COMMA           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    RBRACKET        reduce using rule 72 (primitive_value -> parenthesized_expression .)
    COLON           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    ELSE            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    ELSIF           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    DOWN            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    BY              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    TO              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    FI              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    WHILE           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    LBRACKET        reduce using rule 72 (primitive_value -> parenthesized_expression .)


state 46

    (92) binop -> operand .

    AND             reduce using rule 92 (binop -> operand .)
    OR              reduce using rule 92 (binop -> operand .)
    EQ              reduce using rule 92 (binop -> operand .)
    NEQ             reduce using rule 92 (binop -> operand .)
    GT              reduce using rule 92 (binop -> operand .)
    GE              reduce using rule 92 (binop -> operand .)
    LT              reduce using rule 92 (binop -> operand .)
    LE              reduce using rule 92 (binop -> operand .)
    PLUS            reduce using rule 92 (binop -> operand .)
    MINUS           reduce using rule 92 (binop -> operand .)
    TIMES           reduce using rule 92 (binop -> operand .)
    DIVIDE          reduce using rule 92 (binop -> operand .)
    MOD             reduce using rule 92 (binop -> operand .)
    NOT             reduce using rule 92 (binop -> operand .)
    IN              reduce using rule 92 (binop -> operand .)
    CONCAT          reduce using rule 92 (binop -> operand .)
    RBRACKET        reduce using rule 92 (binop -> operand .)
    SEMI            reduce using rule 92 (binop -> operand .)
    THEN            reduce using rule 92 (binop -> operand .)
    RPAREN          reduce using rule 92 (binop -> operand .)
    COMMA           reduce using rule 92 (binop -> operand .)
    COLON           reduce using rule 92 (binop -> operand .)
    ELSE            reduce using rule 92 (binop -> operand .)
    ELSIF           reduce using rule 92 (binop -> operand .)
    DOWN            reduce using rule 92 (binop -> operand .)
    BY              reduce using rule 92 (binop -> operand .)
    TO              reduce using rule 92 (binop -> operand .)
    FI              reduce using rule 92 (binop -> operand .)
    WHILE           reduce using rule 92 (binop -> operand .)


state 47

    (77) literal -> NULL .

    AND             reduce using rule 77 (literal -> NULL .)
    OR              reduce using rule 77 (literal -> NULL .)
    EQ              reduce using rule 77 (literal -> NULL .)
    NEQ             reduce using rule 77 (literal -> NULL .)
    GT              reduce using rule 77 (literal -> NULL .)
    GE              reduce using rule 77 (literal -> NULL .)
    LT              reduce using rule 77 (literal -> NULL .)
    LE              reduce using rule 77 (literal -> NULL .)
    PLUS            reduce using rule 77 (literal -> NULL .)
    MINUS           reduce using rule 77 (literal -> NULL .)
    TIMES           reduce using rule 77 (literal -> NULL .)
    DIVIDE          reduce using rule 77 (literal -> NULL .)
    MOD             reduce using rule 77 (literal -> NULL .)
    NOT             reduce using rule 77 (literal -> NULL .)
    IN              reduce using rule 77 (literal -> NULL .)
    CONCAT          reduce using rule 77 (literal -> NULL .)
    SEMI            reduce using rule 77 (literal -> NULL .)
    THEN            reduce using rule 77 (literal -> NULL .)
    RPAREN          reduce using rule 77 (literal -> NULL .)
    COMMA           reduce using rule 77 (literal -> NULL .)
    RBRACKET        reduce using rule 77 (literal -> NULL .)
    COLON           reduce using rule 77 (literal -> NULL .)
    ELSE            reduce using rule 77 (literal -> NULL .)
    ELSIF           reduce using rule 77 (literal -> NULL .)
    DOWN            reduce using rule 77 (literal -> NULL .)
    BY              reduce using rule 77 (literal -> NULL .)
    TO              reduce using rule 77 (literal -> NULL .)
    FI              reduce using rule 77 (literal -> NULL .)
    WHILE           reduce using rule 77 (literal -> NULL .)
    LBRACKET        reduce using rule 77 (literal -> NULL .)


state 48

    (75) literal -> TRUE .

    AND             reduce using rule 75 (literal -> TRUE .)
    OR              reduce using rule 75 (literal -> TRUE .)
    EQ              reduce using rule 75 (literal -> TRUE .)
    NEQ             reduce using rule 75 (literal -> TRUE .)
    GT              reduce using rule 75 (literal -> TRUE .)
    GE              reduce using rule 75 (literal -> TRUE .)
    LT              reduce using rule 75 (literal -> TRUE .)
    LE              reduce using rule 75 (literal -> TRUE .)
    PLUS            reduce using rule 75 (literal -> TRUE .)
    MINUS           reduce using rule 75 (literal -> TRUE .)
    TIMES           reduce using rule 75 (literal -> TRUE .)
    DIVIDE          reduce using rule 75 (literal -> TRUE .)
    MOD             reduce using rule 75 (literal -> TRUE .)
    NOT             reduce using rule 75 (literal -> TRUE .)
    IN              reduce using rule 75 (literal -> TRUE .)
    CONCAT          reduce using rule 75 (literal -> TRUE .)
    SEMI            reduce using rule 75 (literal -> TRUE .)
    THEN            reduce using rule 75 (literal -> TRUE .)
    RPAREN          reduce using rule 75 (literal -> TRUE .)
    COMMA           reduce using rule 75 (literal -> TRUE .)
    RBRACKET        reduce using rule 75 (literal -> TRUE .)
    COLON           reduce using rule 75 (literal -> TRUE .)
    ELSE            reduce using rule 75 (literal -> TRUE .)
    ELSIF           reduce using rule 75 (literal -> TRUE .)
    DOWN            reduce using rule 75 (literal -> TRUE .)
    BY              reduce using rule 75 (literal -> TRUE .)
    TO              reduce using rule 75 (literal -> TRUE .)
    FI              reduce using rule 75 (literal -> TRUE .)
    WHILE           reduce using rule 75 (literal -> TRUE .)
    LBRACKET        reduce using rule 75 (literal -> TRUE .)


state 49

    (109) operand -> MINUS . operand1
    (114) operand1 -> . location
    (115) operand1 -> . referenced_location
    (116) operand1 -> . primitive_value
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (117) referenced_location -> . ARROW location
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (17) identifier -> . ID
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    ARROW           shift and go to state 110
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    operand1                       shift and go to state 107
    literal                        shift and go to state 50
    location                       shift and go to state 108
    call_action                    shift and go to state 53
    referenced_location            shift and go to state 109
    builtin_call                   shift and go to state 24
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 111
    primitive_value                shift and go to state 112

state 50

    (69) primitive_value -> literal .

    AND             reduce using rule 69 (primitive_value -> literal .)
    OR              reduce using rule 69 (primitive_value -> literal .)
    EQ              reduce using rule 69 (primitive_value -> literal .)
    NEQ             reduce using rule 69 (primitive_value -> literal .)
    GT              reduce using rule 69 (primitive_value -> literal .)
    GE              reduce using rule 69 (primitive_value -> literal .)
    LT              reduce using rule 69 (primitive_value -> literal .)
    LE              reduce using rule 69 (primitive_value -> literal .)
    PLUS            reduce using rule 69 (primitive_value -> literal .)
    MINUS           reduce using rule 69 (primitive_value -> literal .)
    TIMES           reduce using rule 69 (primitive_value -> literal .)
    DIVIDE          reduce using rule 69 (primitive_value -> literal .)
    MOD             reduce using rule 69 (primitive_value -> literal .)
    NOT             reduce using rule 69 (primitive_value -> literal .)
    IN              reduce using rule 69 (primitive_value -> literal .)
    CONCAT          reduce using rule 69 (primitive_value -> literal .)
    SEMI            reduce using rule 69 (primitive_value -> literal .)
    THEN            reduce using rule 69 (primitive_value -> literal .)
    RPAREN          reduce using rule 69 (primitive_value -> literal .)
    COMMA           reduce using rule 69 (primitive_value -> literal .)
    RBRACKET        reduce using rule 69 (primitive_value -> literal .)
    COLON           reduce using rule 69 (primitive_value -> literal .)
    ELSE            reduce using rule 69 (primitive_value -> literal .)
    ELSIF           reduce using rule 69 (primitive_value -> literal .)
    DOWN            reduce using rule 69 (primitive_value -> literal .)
    BY              reduce using rule 69 (primitive_value -> literal .)
    TO              reduce using rule 69 (primitive_value -> literal .)
    FI              reduce using rule 69 (primitive_value -> literal .)
    WHILE           reduce using rule 69 (primitive_value -> literal .)
    LBRACKET        reduce using rule 69 (primitive_value -> literal .)


state 51

    (78) literal -> SCONST .

    AND             reduce using rule 78 (literal -> SCONST .)
    OR              reduce using rule 78 (literal -> SCONST .)
    EQ              reduce using rule 78 (literal -> SCONST .)
    NEQ             reduce using rule 78 (literal -> SCONST .)
    GT              reduce using rule 78 (literal -> SCONST .)
    GE              reduce using rule 78 (literal -> SCONST .)
    LT              reduce using rule 78 (literal -> SCONST .)
    LE              reduce using rule 78 (literal -> SCONST .)
    PLUS            reduce using rule 78 (literal -> SCONST .)
    MINUS           reduce using rule 78 (literal -> SCONST .)
    TIMES           reduce using rule 78 (literal -> SCONST .)
    DIVIDE          reduce using rule 78 (literal -> SCONST .)
    MOD             reduce using rule 78 (literal -> SCONST .)
    NOT             reduce using rule 78 (literal -> SCONST .)
    IN              reduce using rule 78 (literal -> SCONST .)
    CONCAT          reduce using rule 78 (literal -> SCONST .)
    SEMI            reduce using rule 78 (literal -> SCONST .)
    THEN            reduce using rule 78 (literal -> SCONST .)
    RPAREN          reduce using rule 78 (literal -> SCONST .)
    COMMA           reduce using rule 78 (literal -> SCONST .)
    RBRACKET        reduce using rule 78 (literal -> SCONST .)
    COLON           reduce using rule 78 (literal -> SCONST .)
    ELSE            reduce using rule 78 (literal -> SCONST .)
    ELSIF           reduce using rule 78 (literal -> SCONST .)
    DOWN            reduce using rule 78 (literal -> SCONST .)
    BY              reduce using rule 78 (literal -> SCONST .)
    TO              reduce using rule 78 (literal -> SCONST .)
    FI              reduce using rule 78 (literal -> SCONST .)
    WHILE           reduce using rule 78 (literal -> SCONST .)
    LBRACKET        reduce using rule 78 (literal -> SCONST .)


state 52

    (111) operand -> location .
    (62) dereferenced_reference -> location . ARROW
    (65) array_element -> location . LBRACKET expression_list RBRACKET
    (68) array_slice -> location . LBRACKET ICONST COLON ICONST RBRACKET

    AND             reduce using rule 111 (operand -> location .)
    OR              reduce using rule 111 (operand -> location .)
    EQ              reduce using rule 111 (operand -> location .)
    NEQ             reduce using rule 111 (operand -> location .)
    GT              reduce using rule 111 (operand -> location .)
    GE              reduce using rule 111 (operand -> location .)
    LT              reduce using rule 111 (operand -> location .)
    LE              reduce using rule 111 (operand -> location .)
    PLUS            reduce using rule 111 (operand -> location .)
    MINUS           reduce using rule 111 (operand -> location .)
    TIMES           reduce using rule 111 (operand -> location .)
    DIVIDE          reduce using rule 111 (operand -> location .)
    MOD             reduce using rule 111 (operand -> location .)
    NOT             reduce using rule 111 (operand -> location .)
    IN              reduce using rule 111 (operand -> location .)
    CONCAT          reduce using rule 111 (operand -> location .)
    SEMI            reduce using rule 111 (operand -> location .)
    FI              reduce using rule 111 (operand -> location .)
    RBRACKET        reduce using rule 111 (operand -> location .)
    COMMA           reduce using rule 111 (operand -> location .)
    THEN            reduce using rule 111 (operand -> location .)
    RPAREN          reduce using rule 111 (operand -> location .)
    COLON           reduce using rule 111 (operand -> location .)
    ELSE            reduce using rule 111 (operand -> location .)
    ELSIF           reduce using rule 111 (operand -> location .)
    DOWN            reduce using rule 111 (operand -> location .)
    BY              reduce using rule 111 (operand -> location .)
    TO              reduce using rule 111 (operand -> location .)
    WHILE           reduce using rule 111 (operand -> location .)
    ARROW           shift and go to state 85
    LBRACKET        shift and go to state 84


state 53

    (61) location -> call_action .

    ARROW           reduce using rule 61 (location -> call_action .)
    LBRACKET        reduce using rule 61 (location -> call_action .)
    AND             reduce using rule 61 (location -> call_action .)
    OR              reduce using rule 61 (location -> call_action .)
    EQ              reduce using rule 61 (location -> call_action .)
    NEQ             reduce using rule 61 (location -> call_action .)
    GT              reduce using rule 61 (location -> call_action .)
    GE              reduce using rule 61 (location -> call_action .)
    LT              reduce using rule 61 (location -> call_action .)
    LE              reduce using rule 61 (location -> call_action .)
    PLUS            reduce using rule 61 (location -> call_action .)
    MINUS           reduce using rule 61 (location -> call_action .)
    TIMES           reduce using rule 61 (location -> call_action .)
    DIVIDE          reduce using rule 61 (location -> call_action .)
    MOD             reduce using rule 61 (location -> call_action .)
    NOT             reduce using rule 61 (location -> call_action .)
    IN              reduce using rule 61 (location -> call_action .)
    CONCAT          reduce using rule 61 (location -> call_action .)
    DOWN            reduce using rule 61 (location -> call_action .)
    BY              reduce using rule 61 (location -> call_action .)
    TO              reduce using rule 61 (location -> call_action .)
    SEMI            reduce using rule 61 (location -> call_action .)
    THEN            reduce using rule 61 (location -> call_action .)
    RPAREN          reduce using rule 61 (location -> call_action .)
    COMMA           reduce using rule 61 (location -> call_action .)
    RBRACKET        reduce using rule 61 (location -> call_action .)
    COLON           reduce using rule 61 (location -> call_action .)
    ELSE            reduce using rule 61 (location -> call_action .)
    ELSIF           reduce using rule 61 (location -> call_action .)
    FI              reduce using rule 61 (location -> call_action .)
    WHILE           reduce using rule 61 (location -> call_action .)


state 54

    (70) primitive_value -> value_array_element .

    AND             reduce using rule 70 (primitive_value -> value_array_element .)
    OR              reduce using rule 70 (primitive_value -> value_array_element .)
    EQ              reduce using rule 70 (primitive_value -> value_array_element .)
    NEQ             reduce using rule 70 (primitive_value -> value_array_element .)
    GT              reduce using rule 70 (primitive_value -> value_array_element .)
    GE              reduce using rule 70 (primitive_value -> value_array_element .)
    LT              reduce using rule 70 (primitive_value -> value_array_element .)
    LE              reduce using rule 70 (primitive_value -> value_array_element .)
    PLUS            reduce using rule 70 (primitive_value -> value_array_element .)
    MINUS           reduce using rule 70 (primitive_value -> value_array_element .)
    TIMES           reduce using rule 70 (primitive_value -> value_array_element .)
    DIVIDE          reduce using rule 70 (primitive_value -> value_array_element .)
    MOD             reduce using rule 70 (primitive_value -> value_array_element .)
    NOT             reduce using rule 70 (primitive_value -> value_array_element .)
    IN              reduce using rule 70 (primitive_value -> value_array_element .)
    CONCAT          reduce using rule 70 (primitive_value -> value_array_element .)
    SEMI            reduce using rule 70 (primitive_value -> value_array_element .)
    THEN            reduce using rule 70 (primitive_value -> value_array_element .)
    RPAREN          reduce using rule 70 (primitive_value -> value_array_element .)
    COMMA           reduce using rule 70 (primitive_value -> value_array_element .)
    RBRACKET        reduce using rule 70 (primitive_value -> value_array_element .)
    COLON           reduce using rule 70 (primitive_value -> value_array_element .)
    ELSE            reduce using rule 70 (primitive_value -> value_array_element .)
    ELSIF           reduce using rule 70 (primitive_value -> value_array_element .)
    DOWN            reduce using rule 70 (primitive_value -> value_array_element .)
    BY              reduce using rule 70 (primitive_value -> value_array_element .)
    TO              reduce using rule 70 (primitive_value -> value_array_element .)
    FI              reduce using rule 70 (primitive_value -> value_array_element .)
    WHILE           reduce using rule 70 (primitive_value -> value_array_element .)
    LBRACKET        reduce using rule 70 (primitive_value -> value_array_element .)


state 55

    (76) literal -> CCONST .

    AND             reduce using rule 76 (literal -> CCONST .)
    OR              reduce using rule 76 (literal -> CCONST .)
    EQ              reduce using rule 76 (literal -> CCONST .)
    NEQ             reduce using rule 76 (literal -> CCONST .)
    GT              reduce using rule 76 (literal -> CCONST .)
    GE              reduce using rule 76 (literal -> CCONST .)
    LT              reduce using rule 76 (literal -> CCONST .)
    LE              reduce using rule 76 (literal -> CCONST .)
    PLUS            reduce using rule 76 (literal -> CCONST .)
    MINUS           reduce using rule 76 (literal -> CCONST .)
    TIMES           reduce using rule 76 (literal -> CCONST .)
    DIVIDE          reduce using rule 76 (literal -> CCONST .)
    MOD             reduce using rule 76 (literal -> CCONST .)
    NOT             reduce using rule 76 (literal -> CCONST .)
    IN              reduce using rule 76 (literal -> CCONST .)
    CONCAT          reduce using rule 76 (literal -> CCONST .)
    SEMI            reduce using rule 76 (literal -> CCONST .)
    THEN            reduce using rule 76 (literal -> CCONST .)
    RPAREN          reduce using rule 76 (literal -> CCONST .)
    COMMA           reduce using rule 76 (literal -> CCONST .)
    RBRACKET        reduce using rule 76 (literal -> CCONST .)
    COLON           reduce using rule 76 (literal -> CCONST .)
    ELSE            reduce using rule 76 (literal -> CCONST .)
    ELSIF           reduce using rule 76 (literal -> CCONST .)
    DOWN            reduce using rule 76 (literal -> CCONST .)
    BY              reduce using rule 76 (literal -> CCONST .)
    TO              reduce using rule 76 (literal -> CCONST .)
    FI              reduce using rule 76 (literal -> CCONST .)
    WHILE           reduce using rule 76 (literal -> CCONST .)
    LBRACKET        reduce using rule 76 (literal -> CCONST .)


state 56

    (83) expression -> binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    SEMI            reduce using rule 83 (expression -> binop .)
    COMMA           reduce using rule 83 (expression -> binop .)
    RPAREN          reduce using rule 83 (expression -> binop .)
    RBRACKET        reduce using rule 83 (expression -> binop .)
    COLON           reduce using rule 83 (expression -> binop .)
    THEN            reduce using rule 83 (expression -> binop .)
    FI              reduce using rule 83 (expression -> binop .)
    WHILE           reduce using rule 83 (expression -> binop .)
    ELSE            reduce using rule 83 (expression -> binop .)
    ELSIF           reduce using rule 83 (expression -> binop .)
    DOWN            reduce using rule 83 (expression -> binop .)
    BY              reduce using rule 83 (expression -> binop .)
    TO              reduce using rule 83 (expression -> binop .)
    AND             shift and go to state 113
    OR              shift and go to state 126
    EQ              shift and go to state 125
    NEQ             shift and go to state 128
    GT              shift and go to state 114
    GE              shift and go to state 118
    LT              shift and go to state 116
    LE              shift and go to state 119
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121
    NOT             shift and go to state 123
    IN              shift and go to state 122
    CONCAT          shift and go to state 127


state 57

    (73) literal -> ICONST .

    AND             reduce using rule 73 (literal -> ICONST .)
    OR              reduce using rule 73 (literal -> ICONST .)
    EQ              reduce using rule 73 (literal -> ICONST .)
    NEQ             reduce using rule 73 (literal -> ICONST .)
    GT              reduce using rule 73 (literal -> ICONST .)
    GE              reduce using rule 73 (literal -> ICONST .)
    LT              reduce using rule 73 (literal -> ICONST .)
    LE              reduce using rule 73 (literal -> ICONST .)
    PLUS            reduce using rule 73 (literal -> ICONST .)
    MINUS           reduce using rule 73 (literal -> ICONST .)
    TIMES           reduce using rule 73 (literal -> ICONST .)
    DIVIDE          reduce using rule 73 (literal -> ICONST .)
    MOD             reduce using rule 73 (literal -> ICONST .)
    NOT             reduce using rule 73 (literal -> ICONST .)
    IN              reduce using rule 73 (literal -> ICONST .)
    CONCAT          reduce using rule 73 (literal -> ICONST .)
    SEMI            reduce using rule 73 (literal -> ICONST .)
    THEN            reduce using rule 73 (literal -> ICONST .)
    RPAREN          reduce using rule 73 (literal -> ICONST .)
    COMMA           reduce using rule 73 (literal -> ICONST .)
    RBRACKET        reduce using rule 73 (literal -> ICONST .)
    COLON           reduce using rule 73 (literal -> ICONST .)
    ELSE            reduce using rule 73 (literal -> ICONST .)
    ELSIF           reduce using rule 73 (literal -> ICONST .)
    DOWN            reduce using rule 73 (literal -> ICONST .)
    BY              reduce using rule 73 (literal -> ICONST .)
    TO              reduce using rule 73 (literal -> ICONST .)
    FI              reduce using rule 73 (literal -> ICONST .)
    WHILE           reduce using rule 73 (literal -> ICONST .)
    LBRACKET        reduce using rule 73 (literal -> ICONST .)


state 58

    (74) literal -> FALSE .

    AND             reduce using rule 74 (literal -> FALSE .)
    OR              reduce using rule 74 (literal -> FALSE .)
    EQ              reduce using rule 74 (literal -> FALSE .)
    NEQ             reduce using rule 74 (literal -> FALSE .)
    GT              reduce using rule 74 (literal -> FALSE .)
    GE              reduce using rule 74 (literal -> FALSE .)
    LT              reduce using rule 74 (literal -> FALSE .)
    LE              reduce using rule 74 (literal -> FALSE .)
    PLUS            reduce using rule 74 (literal -> FALSE .)
    MINUS           reduce using rule 74 (literal -> FALSE .)
    TIMES           reduce using rule 74 (literal -> FALSE .)
    DIVIDE          reduce using rule 74 (literal -> FALSE .)
    MOD             reduce using rule 74 (literal -> FALSE .)
    NOT             reduce using rule 74 (literal -> FALSE .)
    IN              reduce using rule 74 (literal -> FALSE .)
    CONCAT          reduce using rule 74 (literal -> FALSE .)
    SEMI            reduce using rule 74 (literal -> FALSE .)
    THEN            reduce using rule 74 (literal -> FALSE .)
    RPAREN          reduce using rule 74 (literal -> FALSE .)
    COMMA           reduce using rule 74 (literal -> FALSE .)
    RBRACKET        reduce using rule 74 (literal -> FALSE .)
    COLON           reduce using rule 74 (literal -> FALSE .)
    ELSE            reduce using rule 74 (literal -> FALSE .)
    ELSIF           reduce using rule 74 (literal -> FALSE .)
    DOWN            reduce using rule 74 (literal -> FALSE .)
    BY              reduce using rule 74 (literal -> FALSE .)
    TO              reduce using rule 74 (literal -> FALSE .)
    FI              reduce using rule 74 (literal -> FALSE .)
    WHILE           reduce using rule 74 (literal -> FALSE .)
    LBRACKET        reduce using rule 74 (literal -> FALSE .)


state 59

    (85) conditional_expression -> IF . boolean_expression then_expression else_expression FI
    (86) conditional_expression -> IF . boolean_expression then_expression elsif_expression else_expression FI
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    boolean_expression             shift and go to state 129
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 93
    primitive_value                shift and go to state 66

state 60

    (79) value_array_element -> array_primitive_value . LBRACKET expression_list RBRACKET
    (80) value_array_slice -> array_primitive_value . LBRACKET expression COLON expression RBRACKET

    LBRACKET        shift and go to state 130


state 61

    (71) primitive_value -> value_array_slice .

    AND             reduce using rule 71 (primitive_value -> value_array_slice .)
    OR              reduce using rule 71 (primitive_value -> value_array_slice .)
    EQ              reduce using rule 71 (primitive_value -> value_array_slice .)
    NEQ             reduce using rule 71 (primitive_value -> value_array_slice .)
    GT              reduce using rule 71 (primitive_value -> value_array_slice .)
    GE              reduce using rule 71 (primitive_value -> value_array_slice .)
    LT              reduce using rule 71 (primitive_value -> value_array_slice .)
    LE              reduce using rule 71 (primitive_value -> value_array_slice .)
    PLUS            reduce using rule 71 (primitive_value -> value_array_slice .)
    MINUS           reduce using rule 71 (primitive_value -> value_array_slice .)
    TIMES           reduce using rule 71 (primitive_value -> value_array_slice .)
    DIVIDE          reduce using rule 71 (primitive_value -> value_array_slice .)
    MOD             reduce using rule 71 (primitive_value -> value_array_slice .)
    NOT             reduce using rule 71 (primitive_value -> value_array_slice .)
    IN              reduce using rule 71 (primitive_value -> value_array_slice .)
    CONCAT          reduce using rule 71 (primitive_value -> value_array_slice .)
    SEMI            reduce using rule 71 (primitive_value -> value_array_slice .)
    THEN            reduce using rule 71 (primitive_value -> value_array_slice .)
    RPAREN          reduce using rule 71 (primitive_value -> value_array_slice .)
    COMMA           reduce using rule 71 (primitive_value -> value_array_slice .)
    RBRACKET        reduce using rule 71 (primitive_value -> value_array_slice .)
    COLON           reduce using rule 71 (primitive_value -> value_array_slice .)
    ELSE            reduce using rule 71 (primitive_value -> value_array_slice .)
    ELSIF           reduce using rule 71 (primitive_value -> value_array_slice .)
    DOWN            reduce using rule 71 (primitive_value -> value_array_slice .)
    BY              reduce using rule 71 (primitive_value -> value_array_slice .)
    TO              reduce using rule 71 (primitive_value -> value_array_slice .)
    FI              reduce using rule 71 (primitive_value -> value_array_slice .)
    WHILE           reduce using rule 71 (primitive_value -> value_array_slice .)
    LBRACKET        reduce using rule 71 (primitive_value -> value_array_slice .)


state 62

    (84) expression -> conditional_expression .

    SEMI            reduce using rule 84 (expression -> conditional_expression .)
    COMMA           reduce using rule 84 (expression -> conditional_expression .)
    RPAREN          reduce using rule 84 (expression -> conditional_expression .)
    RBRACKET        reduce using rule 84 (expression -> conditional_expression .)
    COLON           reduce using rule 84 (expression -> conditional_expression .)
    THEN            reduce using rule 84 (expression -> conditional_expression .)
    FI              reduce using rule 84 (expression -> conditional_expression .)
    WHILE           reduce using rule 84 (expression -> conditional_expression .)
    ELSE            reduce using rule 84 (expression -> conditional_expression .)
    ELSIF           reduce using rule 84 (expression -> conditional_expression .)
    DOWN            reduce using rule 84 (expression -> conditional_expression .)
    BY              reduce using rule 84 (expression -> conditional_expression .)
    TO              reduce using rule 84 (expression -> conditional_expression .)


state 63

    (110) operand -> NOT . operand1
    (114) operand1 -> . location
    (115) operand1 -> . referenced_location
    (116) operand1 -> . primitive_value
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (117) referenced_location -> . ARROW location
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (17) identifier -> . ID
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    ARROW           shift and go to state 110
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    operand1                       shift and go to state 131
    literal                        shift and go to state 50
    location                       shift and go to state 108
    call_action                    shift and go to state 53
    referenced_location            shift and go to state 109
    builtin_call                   shift and go to state 24
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 111
    primitive_value                shift and go to state 112

state 64

    (113) operand -> identifier .
    (63) string_element -> identifier . LBRACKET ICONST RBRACKET
    (64) string_slice -> identifier . LBRACKET ICONST COLON ICONST RBRACKET
    (167) procedure_call -> identifier . LPAREN parameter_list RPAREN
    (168) procedure_call -> identifier . LPAREN RPAREN

    AND             reduce using rule 113 (operand -> identifier .)
    OR              reduce using rule 113 (operand -> identifier .)
    EQ              reduce using rule 113 (operand -> identifier .)
    NEQ             reduce using rule 113 (operand -> identifier .)
    GT              reduce using rule 113 (operand -> identifier .)
    GE              reduce using rule 113 (operand -> identifier .)
    LT              reduce using rule 113 (operand -> identifier .)
    LE              reduce using rule 113 (operand -> identifier .)
    PLUS            reduce using rule 113 (operand -> identifier .)
    MINUS           reduce using rule 113 (operand -> identifier .)
    TIMES           reduce using rule 113 (operand -> identifier .)
    DIVIDE          reduce using rule 113 (operand -> identifier .)
    MOD             reduce using rule 113 (operand -> identifier .)
    NOT             reduce using rule 113 (operand -> identifier .)
    IN              reduce using rule 113 (operand -> identifier .)
    CONCAT          reduce using rule 113 (operand -> identifier .)
    SEMI            reduce using rule 113 (operand -> identifier .)
    FI              reduce using rule 113 (operand -> identifier .)
    RBRACKET        reduce using rule 113 (operand -> identifier .)
    COMMA           reduce using rule 113 (operand -> identifier .)
    THEN            reduce using rule 113 (operand -> identifier .)
    RPAREN          reduce using rule 113 (operand -> identifier .)
    COLON           reduce using rule 113 (operand -> identifier .)
    ELSE            reduce using rule 113 (operand -> identifier .)
    ELSIF           reduce using rule 113 (operand -> identifier .)
    DOWN            reduce using rule 113 (operand -> identifier .)
    BY              reduce using rule 113 (operand -> identifier .)
    TO              reduce using rule 113 (operand -> identifier .)
    WHILE           reduce using rule 113 (operand -> identifier .)
    LBRACKET        shift and go to state 103
    LPAREN          shift and go to state 105


state 65

    (172) return_action -> RETURN expression .

    SEMI            reduce using rule 172 (return_action -> RETURN expression .)


state 66

    (112) operand -> primitive_value .
    (81) array_primitive_value -> primitive_value .

    AND             reduce using rule 112 (operand -> primitive_value .)
    OR              reduce using rule 112 (operand -> primitive_value .)
    EQ              reduce using rule 112 (operand -> primitive_value .)
    NEQ             reduce using rule 112 (operand -> primitive_value .)
    GT              reduce using rule 112 (operand -> primitive_value .)
    GE              reduce using rule 112 (operand -> primitive_value .)
    LT              reduce using rule 112 (operand -> primitive_value .)
    LE              reduce using rule 112 (operand -> primitive_value .)
    PLUS            reduce using rule 112 (operand -> primitive_value .)
    MINUS           reduce using rule 112 (operand -> primitive_value .)
    TIMES           reduce using rule 112 (operand -> primitive_value .)
    DIVIDE          reduce using rule 112 (operand -> primitive_value .)
    MOD             reduce using rule 112 (operand -> primitive_value .)
    NOT             reduce using rule 112 (operand -> primitive_value .)
    IN              reduce using rule 112 (operand -> primitive_value .)
    CONCAT          reduce using rule 112 (operand -> primitive_value .)
    SEMI            reduce using rule 112 (operand -> primitive_value .)
    FI              reduce using rule 112 (operand -> primitive_value .)
    RBRACKET        reduce using rule 112 (operand -> primitive_value .)
    COMMA           reduce using rule 112 (operand -> primitive_value .)
    THEN            reduce using rule 112 (operand -> primitive_value .)
    RPAREN          reduce using rule 112 (operand -> primitive_value .)
    COLON           reduce using rule 112 (operand -> primitive_value .)
    ELSE            reduce using rule 112 (operand -> primitive_value .)
    ELSIF           reduce using rule 112 (operand -> primitive_value .)
    DOWN            reduce using rule 112 (operand -> primitive_value .)
    BY              reduce using rule 112 (operand -> primitive_value .)
    TO              reduce using rule 112 (operand -> primitive_value .)
    WHILE           reduce using rule 112 (operand -> primitive_value .)
    LBRACKET        reduce using rule 81 (array_primitive_value -> primitive_value .)


state 67

    (164) while_control -> WHILE . boolean_expression
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    boolean_expression             shift and go to state 132
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 93
    primitive_value                shift and go to state 66

state 68

    (146) do_action -> DO action_statement_list . OD
    (121) action_statement_list -> action_statement_list . action_statement
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    OD              shift and go to state 133
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 134
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 73

state 69

    (144) do_action -> DO control_part . SEMI action_statement_list OD
    (145) do_action -> DO control_part . SEMI OD

    SEMI            shift and go to state 135


state 70

    (147) control_part -> for_control . while_control
    (148) control_part -> for_control .
    (164) while_control -> . WHILE boolean_expression

    SEMI            reduce using rule 148 (control_part -> for_control .)
    WHILE           shift and go to state 67

    while_control                  shift and go to state 136

state 71

    (150) for_control -> FOR . iteration
    (151) iteration -> . step_enumeration
    (152) iteration -> . range_enumeration
    (153) step_enumeration -> . loop_counter ASSIGN start_value step_value DOWN end_value
    (154) step_enumeration -> . loop_counter ASSIGN start_value DOWN end_value
    (155) step_enumeration -> . loop_counter ASSIGN start_value step_value end_value
    (156) step_enumeration -> . loop_counter ASSIGN start_value end_value
    (162) range_enumeration -> . loop_counter DOWN IN discrete_mode_name
    (163) range_enumeration -> . loop_counter IN discrete_mode_name
    (157) loop_counter -> . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    range_enumeration              shift and go to state 137
    loop_counter                   shift and go to state 138
    iteration                      shift and go to state 139
    step_enumeration               shift and go to state 140
    identifier                     shift and go to state 141

state 72

    (149) control_part -> while_control .

    SEMI            reduce using rule 149 (control_part -> while_control .)


state 73

    (118) action_statement -> identifier . COLON action SEMI
    (130) assignment_action -> identifier . assigning_operator expression
    (167) procedure_call -> identifier . LPAREN parameter_list RPAREN
    (168) procedure_call -> identifier . LPAREN RPAREN
    (63) string_element -> identifier . LBRACKET ICONST RBRACKET
    (64) string_slice -> identifier . LBRACKET ICONST COLON ICONST RBRACKET
    (131) assigning_operator -> . PLUS ASSIGN
    (132) assigning_operator -> . MINUS ASSIGN
    (133) assigning_operator -> . TIMES ASSIGN
    (134) assigning_operator -> . DIVIDE ASSIGN
    (135) assigning_operator -> . MOD ASSIGN
    (136) assigning_operator -> . CONCAT ASSIGN
    (137) assigning_operator -> . ASSIGN

    COLON           shift and go to state 142
    LPAREN          shift and go to state 105
    LBRACKET        shift and go to state 103
    PLUS            shift and go to state 83
    MINUS           shift and go to state 82
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 89
    CONCAT          shift and go to state 88
    ASSIGN          shift and go to state 87

    assigning_operator             shift and go to state 102

state 74

    (120) action_statement_list -> action_statement .

    ID              reduce using rule 120 (action_statement_list -> action_statement .)
    IF              reduce using rule 120 (action_statement_list -> action_statement .)
    DO              reduce using rule 120 (action_statement_list -> action_statement .)
    EXIT            reduce using rule 120 (action_statement_list -> action_statement .)
    RETURN          reduce using rule 120 (action_statement_list -> action_statement .)
    RESULT          reduce using rule 120 (action_statement_list -> action_statement .)
    NUM             reduce using rule 120 (action_statement_list -> action_statement .)
    PRED            reduce using rule 120 (action_statement_list -> action_statement .)
    SUCC            reduce using rule 120 (action_statement_list -> action_statement .)
    UPPER           reduce using rule 120 (action_statement_list -> action_statement .)
    LOWER           reduce using rule 120 (action_statement_list -> action_statement .)
    LENGTH          reduce using rule 120 (action_statement_list -> action_statement .)
    READ            reduce using rule 120 (action_statement_list -> action_statement .)
    PRINT           reduce using rule 120 (action_statement_list -> action_statement .)
    FI              reduce using rule 120 (action_statement_list -> action_statement .)
    ELSE            reduce using rule 120 (action_statement_list -> action_statement .)
    OD              reduce using rule 120 (action_statement_list -> action_statement .)


state 75

    (175) builtin_call -> builtin_name LPAREN . parameter_list RPAREN
    (176) builtin_call -> builtin_name LPAREN . RPAREN
    (169) parameter_list -> . expression
    (170) parameter_list -> . parameter_list COMMA expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    RPAREN          shift and go to state 143
    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    parameter_list                 shift and go to state 144
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 145
    primitive_value                shift and go to state 66

state 76

    (15) identifier_list -> identifier .

    COMMA           reduce using rule 15 (identifier_list -> identifier .)
    REF             reduce using rule 15 (identifier_list -> identifier .)
    ID              reduce using rule 15 (identifier_list -> identifier .)
    INT             reduce using rule 15 (identifier_list -> identifier .)
    BOOL            reduce using rule 15 (identifier_list -> identifier .)
    CHAR            reduce using rule 15 (identifier_list -> identifier .)
    CHARS           reduce using rule 15 (identifier_list -> identifier .)
    ARRAY           reduce using rule 15 (identifier_list -> identifier .)
    ASSIGN          reduce using rule 15 (identifier_list -> identifier .)


state 77

    (9) declaration_statement -> DCL declaration_list . SEMI
    (11) declaration_list -> declaration_list . COMMA declaration

    SEMI            shift and go to state 147
    COMMA           shift and go to state 146


state 78

    (10) declaration_list -> declaration .

    SEMI            reduce using rule 10 (declaration_list -> declaration .)
    COMMA           reduce using rule 10 (declaration_list -> declaration .)


state 79

    (12) declaration -> identifier_list . mode initialization
    (13) declaration -> identifier_list . mode
    (16) identifier_list -> identifier_list . COMMA identifier
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    COMMA           shift and go to state 157
    REF             shift and go to state 153
    ID              shift and go to state 31
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    CHARS           shift and go to state 161
    ARRAY           shift and go to state 158

    string_mode                    shift and go to state 155
    identifier                     shift and go to state 167
    array_mode                     shift and go to state 154
    discrete_range_mode            shift and go to state 160
    discrete_mode_name             shift and go to state 151
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    reference_mode                 shift and go to state 150
    composite_mode                 shift and go to state 164
    integer_mode                   shift and go to state 159
    mode                           shift and go to state 166
    discrete_mode                  shift and go to state 152
    mode_name                      shift and go to state 156

state 80

    (129) assignment_action -> location assigning_operator . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 168
    primitive_value                shift and go to state 66

state 81

    (134) assigning_operator -> DIVIDE . ASSIGN

    ASSIGN          shift and go to state 169


state 82

    (132) assigning_operator -> MINUS . ASSIGN

    ASSIGN          shift and go to state 170


state 83

    (131) assigning_operator -> PLUS . ASSIGN

    ASSIGN          shift and go to state 171


state 84

    (65) array_element -> location LBRACKET . expression_list RBRACKET
    (68) array_slice -> location LBRACKET . ICONST COLON ICONST RBRACKET
    (66) expression_list -> . expression
    (67) expression_list -> . expression_list COMMA expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    ICONST          shift and go to state 172
    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    expression_list                shift and go to state 173
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 174
    primitive_value                shift and go to state 66

state 85

    (62) dereferenced_reference -> location ARROW .

    ARROW           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    LBRACKET        reduce using rule 62 (dereferenced_reference -> location ARROW .)
    AND             reduce using rule 62 (dereferenced_reference -> location ARROW .)
    OR              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    EQ              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    NEQ             reduce using rule 62 (dereferenced_reference -> location ARROW .)
    GT              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    GE              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    LT              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    LE              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    PLUS            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    MINUS           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    TIMES           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    DIVIDE          reduce using rule 62 (dereferenced_reference -> location ARROW .)
    MOD             reduce using rule 62 (dereferenced_reference -> location ARROW .)
    NOT             reduce using rule 62 (dereferenced_reference -> location ARROW .)
    IN              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    CONCAT          reduce using rule 62 (dereferenced_reference -> location ARROW .)
    SEMI            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    THEN            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    RPAREN          reduce using rule 62 (dereferenced_reference -> location ARROW .)
    COMMA           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    RBRACKET        reduce using rule 62 (dereferenced_reference -> location ARROW .)
    COLON           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    ELSE            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    ELSIF           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    DOWN            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    BY              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    TO              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    FI              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    WHILE           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    ASSIGN          reduce using rule 62 (dereferenced_reference -> location ARROW .)


state 86

    (133) assigning_operator -> TIMES . ASSIGN

    ASSIGN          shift and go to state 175


state 87

    (137) assigning_operator -> ASSIGN .

    IF              reduce using rule 137 (assigning_operator -> ASSIGN .)
    MINUS           reduce using rule 137 (assigning_operator -> ASSIGN .)
    NOT             reduce using rule 137 (assigning_operator -> ASSIGN .)
    ID              reduce using rule 137 (assigning_operator -> ASSIGN .)
    ICONST          reduce using rule 137 (assigning_operator -> ASSIGN .)
    FALSE           reduce using rule 137 (assigning_operator -> ASSIGN .)
    TRUE            reduce using rule 137 (assigning_operator -> ASSIGN .)
    CCONST          reduce using rule 137 (assigning_operator -> ASSIGN .)
    NULL            reduce using rule 137 (assigning_operator -> ASSIGN .)
    SCONST          reduce using rule 137 (assigning_operator -> ASSIGN .)
    LPAREN          reduce using rule 137 (assigning_operator -> ASSIGN .)
    NUM             reduce using rule 137 (assigning_operator -> ASSIGN .)
    PRED            reduce using rule 137 (assigning_operator -> ASSIGN .)
    SUCC            reduce using rule 137 (assigning_operator -> ASSIGN .)
    UPPER           reduce using rule 137 (assigning_operator -> ASSIGN .)
    LOWER           reduce using rule 137 (assigning_operator -> ASSIGN .)
    LENGTH          reduce using rule 137 (assigning_operator -> ASSIGN .)
    READ            reduce using rule 137 (assigning_operator -> ASSIGN .)
    PRINT           reduce using rule 137 (assigning_operator -> ASSIGN .)


state 88

    (136) assigning_operator -> CONCAT . ASSIGN

    ASSIGN          shift and go to state 176


state 89

    (135) assigning_operator -> MOD . ASSIGN

    ASSIGN          shift and go to state 177


state 90

    (3) statement_list -> statement_list statement .

    END             reduce using rule 3 (statement_list -> statement_list statement .)
    DCL             reduce using rule 3 (statement_list -> statement_list statement .)
    SYN             reduce using rule 3 (statement_list -> statement_list statement .)
    TYPE            reduce using rule 3 (statement_list -> statement_list statement .)
    ID              reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    DO              reduce using rule 3 (statement_list -> statement_list statement .)
    EXIT            reduce using rule 3 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 3 (statement_list -> statement_list statement .)
    RESULT          reduce using rule 3 (statement_list -> statement_list statement .)
    NUM             reduce using rule 3 (statement_list -> statement_list statement .)
    PRED            reduce using rule 3 (statement_list -> statement_list statement .)
    SUCC            reduce using rule 3 (statement_list -> statement_list statement .)
    UPPER           reduce using rule 3 (statement_list -> statement_list statement .)
    LOWER           reduce using rule 3 (statement_list -> statement_list statement .)
    LENGTH          reduce using rule 3 (statement_list -> statement_list statement .)
    READ            reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)


state 91

    (174) result_action -> RESULT expression .

    SEMI            reduce using rule 174 (result_action -> RESULT expression .)


state 92

    (138) if_action -> IF boolean_expression . then_clause else_clause FI
    (139) if_action -> IF boolean_expression . then_clause FI
    (140) then_clause -> . THEN action_statement_list
    (141) then_clause -> . THEN

    THEN            shift and go to state 178

    then_clause                    shift and go to state 179

state 93

    (87) boolean_expression -> expression .

    SEMI            reduce using rule 87 (boolean_expression -> expression .)
    THEN            reduce using rule 87 (boolean_expression -> expression .)


state 94

    (25) newmode_list -> mode_definition .

    COMMA           reduce using rule 25 (newmode_list -> mode_definition .)
    DCL             reduce using rule 25 (newmode_list -> mode_definition .)
    SYN             reduce using rule 25 (newmode_list -> mode_definition .)
    TYPE            reduce using rule 25 (newmode_list -> mode_definition .)
    ID              reduce using rule 25 (newmode_list -> mode_definition .)
    IF              reduce using rule 25 (newmode_list -> mode_definition .)
    DO              reduce using rule 25 (newmode_list -> mode_definition .)
    EXIT            reduce using rule 25 (newmode_list -> mode_definition .)
    RETURN          reduce using rule 25 (newmode_list -> mode_definition .)
    RESULT          reduce using rule 25 (newmode_list -> mode_definition .)
    NUM             reduce using rule 25 (newmode_list -> mode_definition .)
    PRED            reduce using rule 25 (newmode_list -> mode_definition .)
    SUCC            reduce using rule 25 (newmode_list -> mode_definition .)
    UPPER           reduce using rule 25 (newmode_list -> mode_definition .)
    LOWER           reduce using rule 25 (newmode_list -> mode_definition .)
    LENGTH          reduce using rule 25 (newmode_list -> mode_definition .)
    READ            reduce using rule 25 (newmode_list -> mode_definition .)
    PRINT           reduce using rule 25 (newmode_list -> mode_definition .)
    $end            reduce using rule 25 (newmode_list -> mode_definition .)
    END             reduce using rule 25 (newmode_list -> mode_definition .)


state 95

    (24) newmode_statement -> TYPE newmode_list .
    (26) newmode_list -> newmode_list . COMMA mode_definition

    DCL             reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    SYN             reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    TYPE            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    ID              reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    IF              reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    DO              reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    EXIT            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    RETURN          reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    RESULT          reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    NUM             reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    PRED            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    SUCC            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    UPPER           reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    LOWER           reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    LENGTH          reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    READ            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    PRINT           reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    $end            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    END             reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    COMMA           shift and go to state 180


state 96

    (27) mode_definition -> identifier_list . mode
    (16) identifier_list -> identifier_list . COMMA identifier
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    COMMA           shift and go to state 157
    REF             shift and go to state 153
    ID              shift and go to state 31
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    CHARS           shift and go to state 161
    ARRAY           shift and go to state 158

    string_mode                    shift and go to state 155
    identifier                     shift and go to state 167
    array_mode                     shift and go to state 154
    discrete_range_mode            shift and go to state 160
    discrete_mode_name             shift and go to state 151
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    reference_mode                 shift and go to state 150
    composite_mode                 shift and go to state 164
    integer_mode                   shift and go to state 159
    mode                           shift and go to state 181
    discrete_mode                  shift and go to state 152
    mode_name                      shift and go to state 156

state 97

    (19) synonym_list -> synonym_definition .

    SEMI            reduce using rule 19 (synonym_list -> synonym_definition .)
    COMMA           reduce using rule 19 (synonym_list -> synonym_definition .)


state 98

    (18) synonym_statement -> SYN synonym_list . SEMI
    (20) synonym_list -> synonym_list . COMMA synonym_definition

    SEMI            shift and go to state 183
    COMMA           shift and go to state 182


state 99

    (21) synonym_definition -> identifier_list . mode ASSIGN constant_expression
    (22) synonym_definition -> identifier_list . ASSIGN constant_expression
    (16) identifier_list -> identifier_list . COMMA identifier
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    ASSIGN          shift and go to state 184
    COMMA           shift and go to state 157
    REF             shift and go to state 153
    ID              shift and go to state 31
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    CHARS           shift and go to state 161
    ARRAY           shift and go to state 158

    string_mode                    shift and go to state 155
    array_mode                     shift and go to state 154
    discrete_range_mode            shift and go to state 160
    discrete_mode_name             shift and go to state 151
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    reference_mode                 shift and go to state 150
    composite_mode                 shift and go to state 164
    integer_mode                   shift and go to state 159
    mode                           shift and go to state 185
    discrete_mode                  shift and go to state 152
    identifier                     shift and go to state 167
    mode_name                      shift and go to state 156

state 100

    (171) exit_action -> EXIT identifier .

    SEMI            reduce using rule 171 (exit_action -> EXIT identifier .)


state 101

    (119) action_statement -> action SEMI .

    OD              reduce using rule 119 (action_statement -> action SEMI .)
    ID              reduce using rule 119 (action_statement -> action SEMI .)
    IF              reduce using rule 119 (action_statement -> action SEMI .)
    DO              reduce using rule 119 (action_statement -> action SEMI .)
    EXIT            reduce using rule 119 (action_statement -> action SEMI .)
    RETURN          reduce using rule 119 (action_statement -> action SEMI .)
    RESULT          reduce using rule 119 (action_statement -> action SEMI .)
    NUM             reduce using rule 119 (action_statement -> action SEMI .)
    PRED            reduce using rule 119 (action_statement -> action SEMI .)
    SUCC            reduce using rule 119 (action_statement -> action SEMI .)
    UPPER           reduce using rule 119 (action_statement -> action SEMI .)
    LOWER           reduce using rule 119 (action_statement -> action SEMI .)
    LENGTH          reduce using rule 119 (action_statement -> action SEMI .)
    READ            reduce using rule 119 (action_statement -> action SEMI .)
    PRINT           reduce using rule 119 (action_statement -> action SEMI .)
    END             reduce using rule 119 (action_statement -> action SEMI .)
    DCL             reduce using rule 119 (action_statement -> action SEMI .)
    SYN             reduce using rule 119 (action_statement -> action SEMI .)
    TYPE            reduce using rule 119 (action_statement -> action SEMI .)
    FI              reduce using rule 119 (action_statement -> action SEMI .)
    ELSE            reduce using rule 119 (action_statement -> action SEMI .)
    $end            reduce using rule 119 (action_statement -> action SEMI .)


state 102

    (130) assignment_action -> identifier assigning_operator . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 186
    primitive_value                shift and go to state 66

state 103

    (63) string_element -> identifier LBRACKET . ICONST RBRACKET
    (64) string_slice -> identifier LBRACKET . ICONST COLON ICONST RBRACKET

    ICONST          shift and go to state 187


state 104

    (185) procedure_statement -> identifier COLON . procedure_definition SEMI
    (118) action_statement -> identifier COLON . action SEMI
    (186) procedure_definition -> . PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END
    (187) procedure_definition -> . PROC LPAREN formal_parameter_list RPAREN SEMI statement_list END
    (188) procedure_definition -> . PROC LPAREN RPAREN SEMI statement_list END
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (17) identifier -> . ID
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    PROC            shift and go to state 191
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    action                         shift and go to state 188
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    procedure_definition           shift and go to state 189
    identifier                     shift and go to state 190

state 105

    (167) procedure_call -> identifier LPAREN . parameter_list RPAREN
    (168) procedure_call -> identifier LPAREN . RPAREN
    (169) parameter_list -> . expression
    (170) parameter_list -> . parameter_list COMMA expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    RPAREN          shift and go to state 192
    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    parameter_list                 shift and go to state 193
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 145
    primitive_value                shift and go to state 66

state 106

    (82) parenthesized_expression -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 194


state 107

    (109) operand -> MINUS operand1 .

    AND             reduce using rule 109 (operand -> MINUS operand1 .)
    OR              reduce using rule 109 (operand -> MINUS operand1 .)
    EQ              reduce using rule 109 (operand -> MINUS operand1 .)
    NEQ             reduce using rule 109 (operand -> MINUS operand1 .)
    GT              reduce using rule 109 (operand -> MINUS operand1 .)
    GE              reduce using rule 109 (operand -> MINUS operand1 .)
    LT              reduce using rule 109 (operand -> MINUS operand1 .)
    LE              reduce using rule 109 (operand -> MINUS operand1 .)
    PLUS            reduce using rule 109 (operand -> MINUS operand1 .)
    MINUS           reduce using rule 109 (operand -> MINUS operand1 .)
    TIMES           reduce using rule 109 (operand -> MINUS operand1 .)
    DIVIDE          reduce using rule 109 (operand -> MINUS operand1 .)
    MOD             reduce using rule 109 (operand -> MINUS operand1 .)
    NOT             reduce using rule 109 (operand -> MINUS operand1 .)
    IN              reduce using rule 109 (operand -> MINUS operand1 .)
    CONCAT          reduce using rule 109 (operand -> MINUS operand1 .)
    SEMI            reduce using rule 109 (operand -> MINUS operand1 .)
    FI              reduce using rule 109 (operand -> MINUS operand1 .)
    RBRACKET        reduce using rule 109 (operand -> MINUS operand1 .)
    COMMA           reduce using rule 109 (operand -> MINUS operand1 .)
    THEN            reduce using rule 109 (operand -> MINUS operand1 .)
    RPAREN          reduce using rule 109 (operand -> MINUS operand1 .)
    COLON           reduce using rule 109 (operand -> MINUS operand1 .)
    ELSE            reduce using rule 109 (operand -> MINUS operand1 .)
    ELSIF           reduce using rule 109 (operand -> MINUS operand1 .)
    DOWN            reduce using rule 109 (operand -> MINUS operand1 .)
    BY              reduce using rule 109 (operand -> MINUS operand1 .)
    TO              reduce using rule 109 (operand -> MINUS operand1 .)
    WHILE           reduce using rule 109 (operand -> MINUS operand1 .)


state 108

    (114) operand1 -> location .
    (62) dereferenced_reference -> location . ARROW
    (65) array_element -> location . LBRACKET expression_list RBRACKET
    (68) array_slice -> location . LBRACKET ICONST COLON ICONST RBRACKET

    AND             reduce using rule 114 (operand1 -> location .)
    OR              reduce using rule 114 (operand1 -> location .)
    EQ              reduce using rule 114 (operand1 -> location .)
    NEQ             reduce using rule 114 (operand1 -> location .)
    GT              reduce using rule 114 (operand1 -> location .)
    GE              reduce using rule 114 (operand1 -> location .)
    LT              reduce using rule 114 (operand1 -> location .)
    LE              reduce using rule 114 (operand1 -> location .)
    PLUS            reduce using rule 114 (operand1 -> location .)
    MINUS           reduce using rule 114 (operand1 -> location .)
    TIMES           reduce using rule 114 (operand1 -> location .)
    DIVIDE          reduce using rule 114 (operand1 -> location .)
    MOD             reduce using rule 114 (operand1 -> location .)
    NOT             reduce using rule 114 (operand1 -> location .)
    IN              reduce using rule 114 (operand1 -> location .)
    CONCAT          reduce using rule 114 (operand1 -> location .)
    SEMI            reduce using rule 114 (operand1 -> location .)
    THEN            reduce using rule 114 (operand1 -> location .)
    RPAREN          reduce using rule 114 (operand1 -> location .)
    COMMA           reduce using rule 114 (operand1 -> location .)
    RBRACKET        reduce using rule 114 (operand1 -> location .)
    COLON           reduce using rule 114 (operand1 -> location .)
    ELSE            reduce using rule 114 (operand1 -> location .)
    ELSIF           reduce using rule 114 (operand1 -> location .)
    DOWN            reduce using rule 114 (operand1 -> location .)
    BY              reduce using rule 114 (operand1 -> location .)
    TO              reduce using rule 114 (operand1 -> location .)
    FI              reduce using rule 114 (operand1 -> location .)
    WHILE           reduce using rule 114 (operand1 -> location .)
    ARROW           shift and go to state 85
    LBRACKET        shift and go to state 84


state 109

    (115) operand1 -> referenced_location .

    AND             reduce using rule 115 (operand1 -> referenced_location .)
    OR              reduce using rule 115 (operand1 -> referenced_location .)
    EQ              reduce using rule 115 (operand1 -> referenced_location .)
    NEQ             reduce using rule 115 (operand1 -> referenced_location .)
    GT              reduce using rule 115 (operand1 -> referenced_location .)
    GE              reduce using rule 115 (operand1 -> referenced_location .)
    LT              reduce using rule 115 (operand1 -> referenced_location .)
    LE              reduce using rule 115 (operand1 -> referenced_location .)
    PLUS            reduce using rule 115 (operand1 -> referenced_location .)
    MINUS           reduce using rule 115 (operand1 -> referenced_location .)
    TIMES           reduce using rule 115 (operand1 -> referenced_location .)
    DIVIDE          reduce using rule 115 (operand1 -> referenced_location .)
    MOD             reduce using rule 115 (operand1 -> referenced_location .)
    NOT             reduce using rule 115 (operand1 -> referenced_location .)
    IN              reduce using rule 115 (operand1 -> referenced_location .)
    CONCAT          reduce using rule 115 (operand1 -> referenced_location .)
    SEMI            reduce using rule 115 (operand1 -> referenced_location .)
    THEN            reduce using rule 115 (operand1 -> referenced_location .)
    RPAREN          reduce using rule 115 (operand1 -> referenced_location .)
    COMMA           reduce using rule 115 (operand1 -> referenced_location .)
    RBRACKET        reduce using rule 115 (operand1 -> referenced_location .)
    COLON           reduce using rule 115 (operand1 -> referenced_location .)
    ELSE            reduce using rule 115 (operand1 -> referenced_location .)
    ELSIF           reduce using rule 115 (operand1 -> referenced_location .)
    DOWN            reduce using rule 115 (operand1 -> referenced_location .)
    BY              reduce using rule 115 (operand1 -> referenced_location .)
    TO              reduce using rule 115 (operand1 -> referenced_location .)
    FI              reduce using rule 115 (operand1 -> referenced_location .)
    WHILE           reduce using rule 115 (operand1 -> referenced_location .)


state 110

    (117) referenced_location -> ARROW . location
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (17) identifier -> . ID
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    string_element                 shift and go to state 15
    dereferenced_reference         shift and go to state 34
    array_element                  shift and go to state 6
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    location                       shift and go to state 195
    call_action                    shift and go to state 53
    array_slice                    shift and go to state 39
    procedure_call                 shift and go to state 12
    identifier                     shift and go to state 111
    builtin_call                   shift and go to state 24

state 111

    (63) string_element -> identifier . LBRACKET ICONST RBRACKET
    (64) string_slice -> identifier . LBRACKET ICONST COLON ICONST RBRACKET
    (167) procedure_call -> identifier . LPAREN parameter_list RPAREN
    (168) procedure_call -> identifier . LPAREN RPAREN

    LBRACKET        shift and go to state 103
    LPAREN          shift and go to state 105


state 112

    (116) operand1 -> primitive_value .
    (81) array_primitive_value -> primitive_value .

    AND             reduce using rule 116 (operand1 -> primitive_value .)
    OR              reduce using rule 116 (operand1 -> primitive_value .)
    EQ              reduce using rule 116 (operand1 -> primitive_value .)
    NEQ             reduce using rule 116 (operand1 -> primitive_value .)
    GT              reduce using rule 116 (operand1 -> primitive_value .)
    GE              reduce using rule 116 (operand1 -> primitive_value .)
    LT              reduce using rule 116 (operand1 -> primitive_value .)
    LE              reduce using rule 116 (operand1 -> primitive_value .)
    PLUS            reduce using rule 116 (operand1 -> primitive_value .)
    MINUS           reduce using rule 116 (operand1 -> primitive_value .)
    TIMES           reduce using rule 116 (operand1 -> primitive_value .)
    DIVIDE          reduce using rule 116 (operand1 -> primitive_value .)
    MOD             reduce using rule 116 (operand1 -> primitive_value .)
    NOT             reduce using rule 116 (operand1 -> primitive_value .)
    IN              reduce using rule 116 (operand1 -> primitive_value .)
    CONCAT          reduce using rule 116 (operand1 -> primitive_value .)
    SEMI            reduce using rule 116 (operand1 -> primitive_value .)
    THEN            reduce using rule 116 (operand1 -> primitive_value .)
    RPAREN          reduce using rule 116 (operand1 -> primitive_value .)
    COMMA           reduce using rule 116 (operand1 -> primitive_value .)
    RBRACKET        reduce using rule 116 (operand1 -> primitive_value .)
    COLON           reduce using rule 116 (operand1 -> primitive_value .)
    ELSE            reduce using rule 116 (operand1 -> primitive_value .)
    ELSIF           reduce using rule 116 (operand1 -> primitive_value .)
    DOWN            reduce using rule 116 (operand1 -> primitive_value .)
    BY              reduce using rule 116 (operand1 -> primitive_value .)
    TO              reduce using rule 116 (operand1 -> primitive_value .)
    FI              reduce using rule 116 (operand1 -> primitive_value .)
    WHILE           reduce using rule 116 (operand1 -> primitive_value .)
    LBRACKET        reduce using rule 81 (array_primitive_value -> primitive_value .)


state 113

    (93) binop -> binop AND . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 196
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 114

    (97) binop -> binop GT . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 197
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 115

    (104) binop -> binop DIVIDE . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 198
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 116

    (99) binop -> binop LT . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 199
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 117

    (102) binop -> binop MINUS . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 200
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 118

    (98) binop -> binop GE . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 201
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 119

    (100) binop -> binop LE . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 202
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 120

    (101) binop -> binop PLUS . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 203
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 121

    (105) binop -> binop MOD . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 204
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 122

    (107) binop -> binop IN . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 205
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 123

    (106) binop -> binop NOT . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 206
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 124

    (103) binop -> binop TIMES . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 207
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 125

    (95) binop -> binop EQ . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 208
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 126

    (94) binop -> binop OR . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 209
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 127

    (108) binop -> binop CONCAT . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 210
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 128

    (96) binop -> binop NEQ . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    operand                        shift and go to state 46
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 211
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    primitive_value                shift and go to state 66

state 129

    (85) conditional_expression -> IF boolean_expression . then_expression else_expression FI
    (86) conditional_expression -> IF boolean_expression . then_expression elsif_expression else_expression FI
    (88) then_expression -> . THEN expression

    THEN            shift and go to state 212

    then_expression                shift and go to state 213

state 130

    (79) value_array_element -> array_primitive_value LBRACKET . expression_list RBRACKET
    (80) value_array_slice -> array_primitive_value LBRACKET . expression COLON expression RBRACKET
    (66) expression_list -> . expression
    (67) expression_list -> . expression_list COMMA expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    expression_list                shift and go to state 214
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 215
    primitive_value                shift and go to state 66

state 131

    (110) operand -> NOT operand1 .

    AND             reduce using rule 110 (operand -> NOT operand1 .)
    OR              reduce using rule 110 (operand -> NOT operand1 .)
    EQ              reduce using rule 110 (operand -> NOT operand1 .)
    NEQ             reduce using rule 110 (operand -> NOT operand1 .)
    GT              reduce using rule 110 (operand -> NOT operand1 .)
    GE              reduce using rule 110 (operand -> NOT operand1 .)
    LT              reduce using rule 110 (operand -> NOT operand1 .)
    LE              reduce using rule 110 (operand -> NOT operand1 .)
    PLUS            reduce using rule 110 (operand -> NOT operand1 .)
    MINUS           reduce using rule 110 (operand -> NOT operand1 .)
    TIMES           reduce using rule 110 (operand -> NOT operand1 .)
    DIVIDE          reduce using rule 110 (operand -> NOT operand1 .)
    MOD             reduce using rule 110 (operand -> NOT operand1 .)
    NOT             reduce using rule 110 (operand -> NOT operand1 .)
    IN              reduce using rule 110 (operand -> NOT operand1 .)
    CONCAT          reduce using rule 110 (operand -> NOT operand1 .)
    SEMI            reduce using rule 110 (operand -> NOT operand1 .)
    FI              reduce using rule 110 (operand -> NOT operand1 .)
    RBRACKET        reduce using rule 110 (operand -> NOT operand1 .)
    COMMA           reduce using rule 110 (operand -> NOT operand1 .)
    THEN            reduce using rule 110 (operand -> NOT operand1 .)
    RPAREN          reduce using rule 110 (operand -> NOT operand1 .)
    COLON           reduce using rule 110 (operand -> NOT operand1 .)
    ELSE            reduce using rule 110 (operand -> NOT operand1 .)
    ELSIF           reduce using rule 110 (operand -> NOT operand1 .)
    DOWN            reduce using rule 110 (operand -> NOT operand1 .)
    BY              reduce using rule 110 (operand -> NOT operand1 .)
    TO              reduce using rule 110 (operand -> NOT operand1 .)
    WHILE           reduce using rule 110 (operand -> NOT operand1 .)


state 132

    (164) while_control -> WHILE boolean_expression .

    SEMI            reduce using rule 164 (while_control -> WHILE boolean_expression .)


state 133

    (146) do_action -> DO action_statement_list OD .

    SEMI            reduce using rule 146 (do_action -> DO action_statement_list OD .)


state 134

    (121) action_statement_list -> action_statement_list action_statement .

    ID              reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    IF              reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    DO              reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    EXIT            reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    RETURN          reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    RESULT          reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    NUM             reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    PRED            reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    SUCC            reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    UPPER           reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    LOWER           reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    LENGTH          reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    READ            reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    PRINT           reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    FI              reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    ELSE            reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)
    OD              reduce using rule 121 (action_statement_list -> action_statement_list action_statement .)


state 135

    (144) do_action -> DO control_part SEMI . action_statement_list OD
    (145) do_action -> DO control_part SEMI . OD
    (120) action_statement_list -> . action_statement
    (121) action_statement_list -> . action_statement_list action_statement
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    OD              shift and go to state 217
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    action_statement_list          shift and go to state 216
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 74
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 73

state 136

    (147) control_part -> for_control while_control .

    SEMI            reduce using rule 147 (control_part -> for_control while_control .)


state 137

    (152) iteration -> range_enumeration .

    WHILE           reduce using rule 152 (iteration -> range_enumeration .)
    SEMI            reduce using rule 152 (iteration -> range_enumeration .)


state 138

    (153) step_enumeration -> loop_counter . ASSIGN start_value step_value DOWN end_value
    (154) step_enumeration -> loop_counter . ASSIGN start_value DOWN end_value
    (155) step_enumeration -> loop_counter . ASSIGN start_value step_value end_value
    (156) step_enumeration -> loop_counter . ASSIGN start_value end_value
    (162) range_enumeration -> loop_counter . DOWN IN discrete_mode_name
    (163) range_enumeration -> loop_counter . IN discrete_mode_name

    ASSIGN          shift and go to state 220
    DOWN            shift and go to state 218
    IN              shift and go to state 219


state 139

    (150) for_control -> FOR iteration .

    WHILE           reduce using rule 150 (for_control -> FOR iteration .)
    SEMI            reduce using rule 150 (for_control -> FOR iteration .)


state 140

    (151) iteration -> step_enumeration .

    WHILE           reduce using rule 151 (iteration -> step_enumeration .)
    SEMI            reduce using rule 151 (iteration -> step_enumeration .)


state 141

    (157) loop_counter -> identifier .

    ASSIGN          reduce using rule 157 (loop_counter -> identifier .)
    DOWN            reduce using rule 157 (loop_counter -> identifier .)
    IN              reduce using rule 157 (loop_counter -> identifier .)


state 142

    (118) action_statement -> identifier COLON . action SEMI
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (17) identifier -> . ID
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 188
    identifier                     shift and go to state 190

state 143

    (176) builtin_call -> builtin_name LPAREN RPAREN .

    SEMI            reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    ARROW           reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    LBRACKET        reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    PLUS            reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    MINUS           reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    TIMES           reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    DIVIDE          reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    MOD             reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    CONCAT          reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    ASSIGN          reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    AND             reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    OR              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    EQ              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    NEQ             reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    GT              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    GE              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    LT              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    LE              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    NOT             reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    IN              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    RPAREN          reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    COMMA           reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    THEN            reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    RBRACKET        reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    COLON           reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    ELSE            reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    ELSIF           reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    DOWN            reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    BY              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    TO              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    FI              reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)
    WHILE           reduce using rule 176 (builtin_call -> builtin_name LPAREN RPAREN .)


state 144

    (175) builtin_call -> builtin_name LPAREN parameter_list . RPAREN
    (170) parameter_list -> parameter_list . COMMA expression

    RPAREN          shift and go to state 221
    COMMA           shift and go to state 222


state 145

    (169) parameter_list -> expression .

    RPAREN          reduce using rule 169 (parameter_list -> expression .)
    COMMA           reduce using rule 169 (parameter_list -> expression .)


state 146

    (11) declaration_list -> declaration_list COMMA . declaration
    (12) declaration -> . identifier_list mode initialization
    (13) declaration -> . identifier_list mode
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier_list                shift and go to state 79
    declaration                    shift and go to state 223
    identifier                     shift and go to state 76

state 147

    (9) declaration_statement -> DCL declaration_list SEMI .

    END             reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    DCL             reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    SYN             reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    TYPE            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    ID              reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    IF              reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    DO              reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    EXIT            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    RETURN          reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    RESULT          reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    NUM             reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    PRED            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    SUCC            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    UPPER           reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    LOWER           reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    LENGTH          reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    READ            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    PRINT           reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    $end            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)


state 148

    (33) discrete_mode -> boolean_mode .

    LPAREN          reduce using rule 33 (discrete_mode -> boolean_mode .)
    RBRACKET        reduce using rule 33 (discrete_mode -> boolean_mode .)
    COMMA           reduce using rule 33 (discrete_mode -> boolean_mode .)
    ASSIGN          reduce using rule 33 (discrete_mode -> boolean_mode .)
    SEMI            reduce using rule 33 (discrete_mode -> boolean_mode .)
    DCL             reduce using rule 33 (discrete_mode -> boolean_mode .)
    SYN             reduce using rule 33 (discrete_mode -> boolean_mode .)
    TYPE            reduce using rule 33 (discrete_mode -> boolean_mode .)
    ID              reduce using rule 33 (discrete_mode -> boolean_mode .)
    IF              reduce using rule 33 (discrete_mode -> boolean_mode .)
    DO              reduce using rule 33 (discrete_mode -> boolean_mode .)
    EXIT            reduce using rule 33 (discrete_mode -> boolean_mode .)
    RETURN          reduce using rule 33 (discrete_mode -> boolean_mode .)
    RESULT          reduce using rule 33 (discrete_mode -> boolean_mode .)
    NUM             reduce using rule 33 (discrete_mode -> boolean_mode .)
    PRED            reduce using rule 33 (discrete_mode -> boolean_mode .)
    SUCC            reduce using rule 33 (discrete_mode -> boolean_mode .)
    UPPER           reduce using rule 33 (discrete_mode -> boolean_mode .)
    LOWER           reduce using rule 33 (discrete_mode -> boolean_mode .)
    LENGTH          reduce using rule 33 (discrete_mode -> boolean_mode .)
    READ            reduce using rule 33 (discrete_mode -> boolean_mode .)
    PRINT           reduce using rule 33 (discrete_mode -> boolean_mode .)
    $end            reduce using rule 33 (discrete_mode -> boolean_mode .)
    END             reduce using rule 33 (discrete_mode -> boolean_mode .)
    LOC             reduce using rule 33 (discrete_mode -> boolean_mode .)
    RPAREN          reduce using rule 33 (discrete_mode -> boolean_mode .)


state 149

    (38) character_mode -> CHAR .

    LPAREN          reduce using rule 38 (character_mode -> CHAR .)
    RBRACKET        reduce using rule 38 (character_mode -> CHAR .)
    COMMA           reduce using rule 38 (character_mode -> CHAR .)
    DCL             reduce using rule 38 (character_mode -> CHAR .)
    SYN             reduce using rule 38 (character_mode -> CHAR .)
    TYPE            reduce using rule 38 (character_mode -> CHAR .)
    ID              reduce using rule 38 (character_mode -> CHAR .)
    IF              reduce using rule 38 (character_mode -> CHAR .)
    DO              reduce using rule 38 (character_mode -> CHAR .)
    EXIT            reduce using rule 38 (character_mode -> CHAR .)
    RETURN          reduce using rule 38 (character_mode -> CHAR .)
    RESULT          reduce using rule 38 (character_mode -> CHAR .)
    NUM             reduce using rule 38 (character_mode -> CHAR .)
    PRED            reduce using rule 38 (character_mode -> CHAR .)
    SUCC            reduce using rule 38 (character_mode -> CHAR .)
    UPPER           reduce using rule 38 (character_mode -> CHAR .)
    LOWER           reduce using rule 38 (character_mode -> CHAR .)
    LENGTH          reduce using rule 38 (character_mode -> CHAR .)
    READ            reduce using rule 38 (character_mode -> CHAR .)
    PRINT           reduce using rule 38 (character_mode -> CHAR .)
    $end            reduce using rule 38 (character_mode -> CHAR .)
    END             reduce using rule 38 (character_mode -> CHAR .)
    LOC             reduce using rule 38 (character_mode -> CHAR .)
    RPAREN          reduce using rule 38 (character_mode -> CHAR .)
    ASSIGN          reduce using rule 38 (character_mode -> CHAR .)
    SEMI            reduce using rule 38 (character_mode -> CHAR .)


state 150

    (30) mode -> reference_mode .

    ASSIGN          reduce using rule 30 (mode -> reference_mode .)
    SEMI            reduce using rule 30 (mode -> reference_mode .)
    COMMA           reduce using rule 30 (mode -> reference_mode .)
    DCL             reduce using rule 30 (mode -> reference_mode .)
    SYN             reduce using rule 30 (mode -> reference_mode .)
    TYPE            reduce using rule 30 (mode -> reference_mode .)
    ID              reduce using rule 30 (mode -> reference_mode .)
    IF              reduce using rule 30 (mode -> reference_mode .)
    DO              reduce using rule 30 (mode -> reference_mode .)
    EXIT            reduce using rule 30 (mode -> reference_mode .)
    RETURN          reduce using rule 30 (mode -> reference_mode .)
    RESULT          reduce using rule 30 (mode -> reference_mode .)
    NUM             reduce using rule 30 (mode -> reference_mode .)
    PRED            reduce using rule 30 (mode -> reference_mode .)
    SUCC            reduce using rule 30 (mode -> reference_mode .)
    UPPER           reduce using rule 30 (mode -> reference_mode .)
    LOWER           reduce using rule 30 (mode -> reference_mode .)
    LENGTH          reduce using rule 30 (mode -> reference_mode .)
    READ            reduce using rule 30 (mode -> reference_mode .)
    PRINT           reduce using rule 30 (mode -> reference_mode .)
    $end            reduce using rule 30 (mode -> reference_mode .)
    END             reduce using rule 30 (mode -> reference_mode .)
    LOC             reduce using rule 30 (mode -> reference_mode .)
    RPAREN          reduce using rule 30 (mode -> reference_mode .)


state 151

    (39) discrete_range_mode -> discrete_mode_name . LPAREN literal_range RPAREN

    LPAREN          shift and go to state 224


state 152

    (29) mode -> discrete_mode .
    (40) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    ASSIGN          reduce using rule 29 (mode -> discrete_mode .)
    SEMI            reduce using rule 29 (mode -> discrete_mode .)
    COMMA           reduce using rule 29 (mode -> discrete_mode .)
    DCL             reduce using rule 29 (mode -> discrete_mode .)
    SYN             reduce using rule 29 (mode -> discrete_mode .)
    TYPE            reduce using rule 29 (mode -> discrete_mode .)
    ID              reduce using rule 29 (mode -> discrete_mode .)
    IF              reduce using rule 29 (mode -> discrete_mode .)
    DO              reduce using rule 29 (mode -> discrete_mode .)
    EXIT            reduce using rule 29 (mode -> discrete_mode .)
    RETURN          reduce using rule 29 (mode -> discrete_mode .)
    RESULT          reduce using rule 29 (mode -> discrete_mode .)
    NUM             reduce using rule 29 (mode -> discrete_mode .)
    PRED            reduce using rule 29 (mode -> discrete_mode .)
    SUCC            reduce using rule 29 (mode -> discrete_mode .)
    UPPER           reduce using rule 29 (mode -> discrete_mode .)
    LOWER           reduce using rule 29 (mode -> discrete_mode .)
    LENGTH          reduce using rule 29 (mode -> discrete_mode .)
    READ            reduce using rule 29 (mode -> discrete_mode .)
    PRINT           reduce using rule 29 (mode -> discrete_mode .)
    $end            reduce using rule 29 (mode -> discrete_mode .)
    END             reduce using rule 29 (mode -> discrete_mode .)
    LOC             reduce using rule 29 (mode -> discrete_mode .)
    RPAREN          reduce using rule 29 (mode -> discrete_mode .)
    LPAREN          shift and go to state 225


state 153

    (44) reference_mode -> REF . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    REF             shift and go to state 153
    ID              shift and go to state 31
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    CHARS           shift and go to state 161
    ARRAY           shift and go to state 158

    string_mode                    shift and go to state 155
    array_mode                     shift and go to state 154
    discrete_range_mode            shift and go to state 160
    discrete_mode_name             shift and go to state 151
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    reference_mode                 shift and go to state 150
    composite_mode                 shift and go to state 164
    integer_mode                   shift and go to state 159
    mode                           shift and go to state 226
    discrete_mode                  shift and go to state 152
    identifier                     shift and go to state 167
    mode_name                      shift and go to state 156

state 154

    (46) composite_mode -> array_mode .

    LOC             reduce using rule 46 (composite_mode -> array_mode .)
    RPAREN          reduce using rule 46 (composite_mode -> array_mode .)
    ASSIGN          reduce using rule 46 (composite_mode -> array_mode .)
    SEMI            reduce using rule 46 (composite_mode -> array_mode .)
    COMMA           reduce using rule 46 (composite_mode -> array_mode .)
    DCL             reduce using rule 46 (composite_mode -> array_mode .)
    SYN             reduce using rule 46 (composite_mode -> array_mode .)
    TYPE            reduce using rule 46 (composite_mode -> array_mode .)
    ID              reduce using rule 46 (composite_mode -> array_mode .)
    IF              reduce using rule 46 (composite_mode -> array_mode .)
    DO              reduce using rule 46 (composite_mode -> array_mode .)
    EXIT            reduce using rule 46 (composite_mode -> array_mode .)
    RETURN          reduce using rule 46 (composite_mode -> array_mode .)
    RESULT          reduce using rule 46 (composite_mode -> array_mode .)
    NUM             reduce using rule 46 (composite_mode -> array_mode .)
    PRED            reduce using rule 46 (composite_mode -> array_mode .)
    SUCC            reduce using rule 46 (composite_mode -> array_mode .)
    UPPER           reduce using rule 46 (composite_mode -> array_mode .)
    LOWER           reduce using rule 46 (composite_mode -> array_mode .)
    LENGTH          reduce using rule 46 (composite_mode -> array_mode .)
    READ            reduce using rule 46 (composite_mode -> array_mode .)
    PRINT           reduce using rule 46 (composite_mode -> array_mode .)
    $end            reduce using rule 46 (composite_mode -> array_mode .)
    END             reduce using rule 46 (composite_mode -> array_mode .)


state 155

    (45) composite_mode -> string_mode .

    LOC             reduce using rule 45 (composite_mode -> string_mode .)
    RPAREN          reduce using rule 45 (composite_mode -> string_mode .)
    ASSIGN          reduce using rule 45 (composite_mode -> string_mode .)
    SEMI            reduce using rule 45 (composite_mode -> string_mode .)
    COMMA           reduce using rule 45 (composite_mode -> string_mode .)
    DCL             reduce using rule 45 (composite_mode -> string_mode .)
    SYN             reduce using rule 45 (composite_mode -> string_mode .)
    TYPE            reduce using rule 45 (composite_mode -> string_mode .)
    ID              reduce using rule 45 (composite_mode -> string_mode .)
    IF              reduce using rule 45 (composite_mode -> string_mode .)
    DO              reduce using rule 45 (composite_mode -> string_mode .)
    EXIT            reduce using rule 45 (composite_mode -> string_mode .)
    RETURN          reduce using rule 45 (composite_mode -> string_mode .)
    RESULT          reduce using rule 45 (composite_mode -> string_mode .)
    NUM             reduce using rule 45 (composite_mode -> string_mode .)
    PRED            reduce using rule 45 (composite_mode -> string_mode .)
    SUCC            reduce using rule 45 (composite_mode -> string_mode .)
    UPPER           reduce using rule 45 (composite_mode -> string_mode .)
    LOWER           reduce using rule 45 (composite_mode -> string_mode .)
    LENGTH          reduce using rule 45 (composite_mode -> string_mode .)
    READ            reduce using rule 45 (composite_mode -> string_mode .)
    PRINT           reduce using rule 45 (composite_mode -> string_mode .)
    $end            reduce using rule 45 (composite_mode -> string_mode .)
    END             reduce using rule 45 (composite_mode -> string_mode .)


state 156

    (28) mode -> mode_name .

    ASSIGN          reduce using rule 28 (mode -> mode_name .)
    SEMI            reduce using rule 28 (mode -> mode_name .)
    COMMA           reduce using rule 28 (mode -> mode_name .)
    DCL             reduce using rule 28 (mode -> mode_name .)
    SYN             reduce using rule 28 (mode -> mode_name .)
    TYPE            reduce using rule 28 (mode -> mode_name .)
    ID              reduce using rule 28 (mode -> mode_name .)
    IF              reduce using rule 28 (mode -> mode_name .)
    DO              reduce using rule 28 (mode -> mode_name .)
    EXIT            reduce using rule 28 (mode -> mode_name .)
    RETURN          reduce using rule 28 (mode -> mode_name .)
    RESULT          reduce using rule 28 (mode -> mode_name .)
    NUM             reduce using rule 28 (mode -> mode_name .)
    PRED            reduce using rule 28 (mode -> mode_name .)
    SUCC            reduce using rule 28 (mode -> mode_name .)
    UPPER           reduce using rule 28 (mode -> mode_name .)
    LOWER           reduce using rule 28 (mode -> mode_name .)
    LENGTH          reduce using rule 28 (mode -> mode_name .)
    READ            reduce using rule 28 (mode -> mode_name .)
    PRINT           reduce using rule 28 (mode -> mode_name .)
    $end            reduce using rule 28 (mode -> mode_name .)
    END             reduce using rule 28 (mode -> mode_name .)
    LOC             reduce using rule 28 (mode -> mode_name .)
    RPAREN          reduce using rule 28 (mode -> mode_name .)


state 157

    (16) identifier_list -> identifier_list COMMA . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier                     shift and go to state 227

state 158

    (49) array_mode -> ARRAY . LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> ARRAY . LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode

    LBRACKET        shift and go to state 228


state 159

    (32) discrete_mode -> integer_mode .

    LPAREN          reduce using rule 32 (discrete_mode -> integer_mode .)
    RBRACKET        reduce using rule 32 (discrete_mode -> integer_mode .)
    COMMA           reduce using rule 32 (discrete_mode -> integer_mode .)
    ASSIGN          reduce using rule 32 (discrete_mode -> integer_mode .)
    SEMI            reduce using rule 32 (discrete_mode -> integer_mode .)
    DCL             reduce using rule 32 (discrete_mode -> integer_mode .)
    SYN             reduce using rule 32 (discrete_mode -> integer_mode .)
    TYPE            reduce using rule 32 (discrete_mode -> integer_mode .)
    ID              reduce using rule 32 (discrete_mode -> integer_mode .)
    IF              reduce using rule 32 (discrete_mode -> integer_mode .)
    DO              reduce using rule 32 (discrete_mode -> integer_mode .)
    EXIT            reduce using rule 32 (discrete_mode -> integer_mode .)
    RETURN          reduce using rule 32 (discrete_mode -> integer_mode .)
    RESULT          reduce using rule 32 (discrete_mode -> integer_mode .)
    NUM             reduce using rule 32 (discrete_mode -> integer_mode .)
    PRED            reduce using rule 32 (discrete_mode -> integer_mode .)
    SUCC            reduce using rule 32 (discrete_mode -> integer_mode .)
    UPPER           reduce using rule 32 (discrete_mode -> integer_mode .)
    LOWER           reduce using rule 32 (discrete_mode -> integer_mode .)
    LENGTH          reduce using rule 32 (discrete_mode -> integer_mode .)
    READ            reduce using rule 32 (discrete_mode -> integer_mode .)
    PRINT           reduce using rule 32 (discrete_mode -> integer_mode .)
    $end            reduce using rule 32 (discrete_mode -> integer_mode .)
    END             reduce using rule 32 (discrete_mode -> integer_mode .)
    LOC             reduce using rule 32 (discrete_mode -> integer_mode .)
    RPAREN          reduce using rule 32 (discrete_mode -> integer_mode .)


state 160

    (35) discrete_mode -> discrete_range_mode .

    LPAREN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    RBRACKET        reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    COMMA           reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    ASSIGN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    SEMI            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    DCL             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    SYN             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    TYPE            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    ID              reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    IF              reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    DO              reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    EXIT            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    RETURN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    RESULT          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    NUM             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    PRED            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    SUCC            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    UPPER           reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    LOWER           reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    LENGTH          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    READ            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    PRINT           reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    $end            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    END             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    LOC             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    RPAREN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)


state 161

    (47) string_mode -> CHARS . LBRACKET string_length RBRACKET

    LBRACKET        shift and go to state 229


state 162

    (34) discrete_mode -> character_mode .

    LPAREN          reduce using rule 34 (discrete_mode -> character_mode .)
    RBRACKET        reduce using rule 34 (discrete_mode -> character_mode .)
    COMMA           reduce using rule 34 (discrete_mode -> character_mode .)
    ASSIGN          reduce using rule 34 (discrete_mode -> character_mode .)
    SEMI            reduce using rule 34 (discrete_mode -> character_mode .)
    DCL             reduce using rule 34 (discrete_mode -> character_mode .)
    SYN             reduce using rule 34 (discrete_mode -> character_mode .)
    TYPE            reduce using rule 34 (discrete_mode -> character_mode .)
    ID              reduce using rule 34 (discrete_mode -> character_mode .)
    IF              reduce using rule 34 (discrete_mode -> character_mode .)
    DO              reduce using rule 34 (discrete_mode -> character_mode .)
    EXIT            reduce using rule 34 (discrete_mode -> character_mode .)
    RETURN          reduce using rule 34 (discrete_mode -> character_mode .)
    RESULT          reduce using rule 34 (discrete_mode -> character_mode .)
    NUM             reduce using rule 34 (discrete_mode -> character_mode .)
    PRED            reduce using rule 34 (discrete_mode -> character_mode .)
    SUCC            reduce using rule 34 (discrete_mode -> character_mode .)
    UPPER           reduce using rule 34 (discrete_mode -> character_mode .)
    LOWER           reduce using rule 34 (discrete_mode -> character_mode .)
    LENGTH          reduce using rule 34 (discrete_mode -> character_mode .)
    READ            reduce using rule 34 (discrete_mode -> character_mode .)
    PRINT           reduce using rule 34 (discrete_mode -> character_mode .)
    $end            reduce using rule 34 (discrete_mode -> character_mode .)
    END             reduce using rule 34 (discrete_mode -> character_mode .)
    LOC             reduce using rule 34 (discrete_mode -> character_mode .)
    RPAREN          reduce using rule 34 (discrete_mode -> character_mode .)


state 163

    (36) integer_mode -> INT .

    LPAREN          reduce using rule 36 (integer_mode -> INT .)
    RBRACKET        reduce using rule 36 (integer_mode -> INT .)
    COMMA           reduce using rule 36 (integer_mode -> INT .)
    ASSIGN          reduce using rule 36 (integer_mode -> INT .)
    SEMI            reduce using rule 36 (integer_mode -> INT .)
    DCL             reduce using rule 36 (integer_mode -> INT .)
    SYN             reduce using rule 36 (integer_mode -> INT .)
    TYPE            reduce using rule 36 (integer_mode -> INT .)
    ID              reduce using rule 36 (integer_mode -> INT .)
    IF              reduce using rule 36 (integer_mode -> INT .)
    DO              reduce using rule 36 (integer_mode -> INT .)
    EXIT            reduce using rule 36 (integer_mode -> INT .)
    RETURN          reduce using rule 36 (integer_mode -> INT .)
    RESULT          reduce using rule 36 (integer_mode -> INT .)
    NUM             reduce using rule 36 (integer_mode -> INT .)
    PRED            reduce using rule 36 (integer_mode -> INT .)
    SUCC            reduce using rule 36 (integer_mode -> INT .)
    UPPER           reduce using rule 36 (integer_mode -> INT .)
    LOWER           reduce using rule 36 (integer_mode -> INT .)
    LENGTH          reduce using rule 36 (integer_mode -> INT .)
    READ            reduce using rule 36 (integer_mode -> INT .)
    PRINT           reduce using rule 36 (integer_mode -> INT .)
    $end            reduce using rule 36 (integer_mode -> INT .)
    END             reduce using rule 36 (integer_mode -> INT .)
    LOC             reduce using rule 36 (integer_mode -> INT .)
    RPAREN          reduce using rule 36 (integer_mode -> INT .)


state 164

    (31) mode -> composite_mode .

    ASSIGN          reduce using rule 31 (mode -> composite_mode .)
    SEMI            reduce using rule 31 (mode -> composite_mode .)
    COMMA           reduce using rule 31 (mode -> composite_mode .)
    DCL             reduce using rule 31 (mode -> composite_mode .)
    SYN             reduce using rule 31 (mode -> composite_mode .)
    TYPE            reduce using rule 31 (mode -> composite_mode .)
    ID              reduce using rule 31 (mode -> composite_mode .)
    IF              reduce using rule 31 (mode -> composite_mode .)
    DO              reduce using rule 31 (mode -> composite_mode .)
    EXIT            reduce using rule 31 (mode -> composite_mode .)
    RETURN          reduce using rule 31 (mode -> composite_mode .)
    RESULT          reduce using rule 31 (mode -> composite_mode .)
    NUM             reduce using rule 31 (mode -> composite_mode .)
    PRED            reduce using rule 31 (mode -> composite_mode .)
    SUCC            reduce using rule 31 (mode -> composite_mode .)
    UPPER           reduce using rule 31 (mode -> composite_mode .)
    LOWER           reduce using rule 31 (mode -> composite_mode .)
    LENGTH          reduce using rule 31 (mode -> composite_mode .)
    READ            reduce using rule 31 (mode -> composite_mode .)
    PRINT           reduce using rule 31 (mode -> composite_mode .)
    $end            reduce using rule 31 (mode -> composite_mode .)
    END             reduce using rule 31 (mode -> composite_mode .)
    LOC             reduce using rule 31 (mode -> composite_mode .)
    RPAREN          reduce using rule 31 (mode -> composite_mode .)


state 165

    (37) boolean_mode -> BOOL .

    LPAREN          reduce using rule 37 (boolean_mode -> BOOL .)
    RBRACKET        reduce using rule 37 (boolean_mode -> BOOL .)
    COMMA           reduce using rule 37 (boolean_mode -> BOOL .)
    ASSIGN          reduce using rule 37 (boolean_mode -> BOOL .)
    SEMI            reduce using rule 37 (boolean_mode -> BOOL .)
    DCL             reduce using rule 37 (boolean_mode -> BOOL .)
    SYN             reduce using rule 37 (boolean_mode -> BOOL .)
    TYPE            reduce using rule 37 (boolean_mode -> BOOL .)
    ID              reduce using rule 37 (boolean_mode -> BOOL .)
    IF              reduce using rule 37 (boolean_mode -> BOOL .)
    DO              reduce using rule 37 (boolean_mode -> BOOL .)
    EXIT            reduce using rule 37 (boolean_mode -> BOOL .)
    RETURN          reduce using rule 37 (boolean_mode -> BOOL .)
    RESULT          reduce using rule 37 (boolean_mode -> BOOL .)
    NUM             reduce using rule 37 (boolean_mode -> BOOL .)
    PRED            reduce using rule 37 (boolean_mode -> BOOL .)
    SUCC            reduce using rule 37 (boolean_mode -> BOOL .)
    UPPER           reduce using rule 37 (boolean_mode -> BOOL .)
    LOWER           reduce using rule 37 (boolean_mode -> BOOL .)
    LENGTH          reduce using rule 37 (boolean_mode -> BOOL .)
    READ            reduce using rule 37 (boolean_mode -> BOOL .)
    PRINT           reduce using rule 37 (boolean_mode -> BOOL .)
    $end            reduce using rule 37 (boolean_mode -> BOOL .)
    END             reduce using rule 37 (boolean_mode -> BOOL .)
    LOC             reduce using rule 37 (boolean_mode -> BOOL .)
    RPAREN          reduce using rule 37 (boolean_mode -> BOOL .)


state 166

    (12) declaration -> identifier_list mode . initialization
    (13) declaration -> identifier_list mode .
    (14) initialization -> . ASSIGN expression

    SEMI            reduce using rule 13 (declaration -> identifier_list mode .)
    COMMA           reduce using rule 13 (declaration -> identifier_list mode .)
    ASSIGN          shift and go to state 231

    initialization                 shift and go to state 230

state 167

    (41) mode_name -> identifier .
    (42) discrete_mode_name -> identifier .

    COMMA           reduce using rule 41 (mode_name -> identifier .)
    DCL             reduce using rule 41 (mode_name -> identifier .)
    SYN             reduce using rule 41 (mode_name -> identifier .)
    TYPE            reduce using rule 41 (mode_name -> identifier .)
    ID              reduce using rule 41 (mode_name -> identifier .)
    IF              reduce using rule 41 (mode_name -> identifier .)
    DO              reduce using rule 41 (mode_name -> identifier .)
    EXIT            reduce using rule 41 (mode_name -> identifier .)
    RETURN          reduce using rule 41 (mode_name -> identifier .)
    RESULT          reduce using rule 41 (mode_name -> identifier .)
    NUM             reduce using rule 41 (mode_name -> identifier .)
    PRED            reduce using rule 41 (mode_name -> identifier .)
    SUCC            reduce using rule 41 (mode_name -> identifier .)
    UPPER           reduce using rule 41 (mode_name -> identifier .)
    LOWER           reduce using rule 41 (mode_name -> identifier .)
    LENGTH          reduce using rule 41 (mode_name -> identifier .)
    READ            reduce using rule 41 (mode_name -> identifier .)
    PRINT           reduce using rule 41 (mode_name -> identifier .)
    $end            reduce using rule 41 (mode_name -> identifier .)
    END             reduce using rule 41 (mode_name -> identifier .)
    ASSIGN          reduce using rule 41 (mode_name -> identifier .)
    SEMI            reduce using rule 41 (mode_name -> identifier .)
    LOC             reduce using rule 41 (mode_name -> identifier .)
    RPAREN          reduce using rule 41 (mode_name -> identifier .)
    LPAREN          reduce using rule 42 (discrete_mode_name -> identifier .)


state 168

    (129) assignment_action -> location assigning_operator expression .

    SEMI            reduce using rule 129 (assignment_action -> location assigning_operator expression .)


state 169

    (134) assigning_operator -> DIVIDE ASSIGN .

    IF              reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    MINUS           reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    NOT             reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    ID              reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    ICONST          reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    FALSE           reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    TRUE            reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    CCONST          reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    NULL            reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    SCONST          reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    LPAREN          reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    NUM             reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    PRED            reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    SUCC            reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    UPPER           reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    LOWER           reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    LENGTH          reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    READ            reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)
    PRINT           reduce using rule 134 (assigning_operator -> DIVIDE ASSIGN .)


state 170

    (132) assigning_operator -> MINUS ASSIGN .

    IF              reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    MINUS           reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    NOT             reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    ID              reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    ICONST          reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    FALSE           reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    TRUE            reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    CCONST          reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    NULL            reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    SCONST          reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    LPAREN          reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    NUM             reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    PRED            reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    SUCC            reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    UPPER           reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    LOWER           reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    LENGTH          reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    READ            reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)
    PRINT           reduce using rule 132 (assigning_operator -> MINUS ASSIGN .)


state 171

    (131) assigning_operator -> PLUS ASSIGN .

    IF              reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    MINUS           reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    NOT             reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    ID              reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    ICONST          reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    FALSE           reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    TRUE            reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    CCONST          reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    NULL            reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    SCONST          reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    LPAREN          reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    NUM             reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    PRED            reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    SUCC            reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    UPPER           reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    LOWER           reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    LENGTH          reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    READ            reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)
    PRINT           reduce using rule 131 (assigning_operator -> PLUS ASSIGN .)


state 172

    (68) array_slice -> location LBRACKET ICONST . COLON ICONST RBRACKET
    (73) literal -> ICONST .

    COLON           shift and go to state 232
    AND             reduce using rule 73 (literal -> ICONST .)
    OR              reduce using rule 73 (literal -> ICONST .)
    EQ              reduce using rule 73 (literal -> ICONST .)
    NEQ             reduce using rule 73 (literal -> ICONST .)
    GT              reduce using rule 73 (literal -> ICONST .)
    GE              reduce using rule 73 (literal -> ICONST .)
    LT              reduce using rule 73 (literal -> ICONST .)
    LE              reduce using rule 73 (literal -> ICONST .)
    PLUS            reduce using rule 73 (literal -> ICONST .)
    MINUS           reduce using rule 73 (literal -> ICONST .)
    TIMES           reduce using rule 73 (literal -> ICONST .)
    DIVIDE          reduce using rule 73 (literal -> ICONST .)
    MOD             reduce using rule 73 (literal -> ICONST .)
    NOT             reduce using rule 73 (literal -> ICONST .)
    IN              reduce using rule 73 (literal -> ICONST .)
    CONCAT          reduce using rule 73 (literal -> ICONST .)
    RBRACKET        reduce using rule 73 (literal -> ICONST .)
    COMMA           reduce using rule 73 (literal -> ICONST .)
    LBRACKET        reduce using rule 73 (literal -> ICONST .)


state 173

    (65) array_element -> location LBRACKET expression_list . RBRACKET
    (67) expression_list -> expression_list . COMMA expression

    RBRACKET        shift and go to state 234
    COMMA           shift and go to state 233


state 174

    (66) expression_list -> expression .

    RBRACKET        reduce using rule 66 (expression_list -> expression .)
    COMMA           reduce using rule 66 (expression_list -> expression .)


state 175

    (133) assigning_operator -> TIMES ASSIGN .

    IF              reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    MINUS           reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    NOT             reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    ID              reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    ICONST          reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    FALSE           reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    TRUE            reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    CCONST          reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    NULL            reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    SCONST          reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    LPAREN          reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    NUM             reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    PRED            reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    SUCC            reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    UPPER           reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    LOWER           reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    LENGTH          reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    READ            reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)
    PRINT           reduce using rule 133 (assigning_operator -> TIMES ASSIGN .)


state 176

    (136) assigning_operator -> CONCAT ASSIGN .

    IF              reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    MINUS           reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    NOT             reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    ID              reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    ICONST          reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    FALSE           reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    TRUE            reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    CCONST          reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    NULL            reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    SCONST          reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    LPAREN          reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    NUM             reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    PRED            reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    SUCC            reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    UPPER           reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    LOWER           reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    LENGTH          reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    READ            reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)
    PRINT           reduce using rule 136 (assigning_operator -> CONCAT ASSIGN .)


state 177

    (135) assigning_operator -> MOD ASSIGN .

    IF              reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    MINUS           reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    NOT             reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    ID              reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    ICONST          reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    FALSE           reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    TRUE            reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    CCONST          reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    NULL            reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    SCONST          reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    LPAREN          reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    NUM             reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    PRED            reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    SUCC            reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    UPPER           reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    LOWER           reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    LENGTH          reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    READ            reduce using rule 135 (assigning_operator -> MOD ASSIGN .)
    PRINT           reduce using rule 135 (assigning_operator -> MOD ASSIGN .)


state 178

    (140) then_clause -> THEN . action_statement_list
    (141) then_clause -> THEN .
    (120) action_statement_list -> . action_statement
    (121) action_statement_list -> . action_statement_list action_statement
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    FI              reduce using rule 141 (then_clause -> THEN .)
    ELSE            reduce using rule 141 (then_clause -> THEN .)
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    action_statement_list          shift and go to state 235
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 74
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 73

state 179

    (138) if_action -> IF boolean_expression then_clause . else_clause FI
    (139) if_action -> IF boolean_expression then_clause . FI
    (142) else_clause -> . ELSE action_statement_list
    (143) else_clause -> . ELSE

    FI              shift and go to state 238
    ELSE            shift and go to state 236

    else_clause                    shift and go to state 237

state 180

    (26) newmode_list -> newmode_list COMMA . mode_definition
    (27) mode_definition -> . identifier_list mode
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    mode_definition                shift and go to state 239
    identifier_list                shift and go to state 96
    identifier                     shift and go to state 76

state 181

    (27) mode_definition -> identifier_list mode .

    COMMA           reduce using rule 27 (mode_definition -> identifier_list mode .)
    DCL             reduce using rule 27 (mode_definition -> identifier_list mode .)
    SYN             reduce using rule 27 (mode_definition -> identifier_list mode .)
    TYPE            reduce using rule 27 (mode_definition -> identifier_list mode .)
    ID              reduce using rule 27 (mode_definition -> identifier_list mode .)
    IF              reduce using rule 27 (mode_definition -> identifier_list mode .)
    DO              reduce using rule 27 (mode_definition -> identifier_list mode .)
    EXIT            reduce using rule 27 (mode_definition -> identifier_list mode .)
    RETURN          reduce using rule 27 (mode_definition -> identifier_list mode .)
    RESULT          reduce using rule 27 (mode_definition -> identifier_list mode .)
    NUM             reduce using rule 27 (mode_definition -> identifier_list mode .)
    PRED            reduce using rule 27 (mode_definition -> identifier_list mode .)
    SUCC            reduce using rule 27 (mode_definition -> identifier_list mode .)
    UPPER           reduce using rule 27 (mode_definition -> identifier_list mode .)
    LOWER           reduce using rule 27 (mode_definition -> identifier_list mode .)
    LENGTH          reduce using rule 27 (mode_definition -> identifier_list mode .)
    READ            reduce using rule 27 (mode_definition -> identifier_list mode .)
    PRINT           reduce using rule 27 (mode_definition -> identifier_list mode .)
    $end            reduce using rule 27 (mode_definition -> identifier_list mode .)
    END             reduce using rule 27 (mode_definition -> identifier_list mode .)


state 182

    (20) synonym_list -> synonym_list COMMA . synonym_definition
    (21) synonym_definition -> . identifier_list mode ASSIGN constant_expression
    (22) synonym_definition -> . identifier_list ASSIGN constant_expression
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    synonym_definition             shift and go to state 240
    identifier_list                shift and go to state 99
    identifier                     shift and go to state 76

state 183

    (18) synonym_statement -> SYN synonym_list SEMI .

    END             reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    DCL             reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    SYN             reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    TYPE            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    ID              reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    IF              reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    DO              reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    EXIT            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    RETURN          reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    RESULT          reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    NUM             reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    PRED            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    SUCC            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    UPPER           reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    LOWER           reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    LENGTH          reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    READ            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    PRINT           reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    $end            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)


state 184

    (22) synonym_definition -> identifier_list ASSIGN . constant_expression
    (23) constant_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    constant_expression            shift and go to state 241
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 242
    primitive_value                shift and go to state 66

state 185

    (21) synonym_definition -> identifier_list mode . ASSIGN constant_expression

    ASSIGN          shift and go to state 243


state 186

    (130) assignment_action -> identifier assigning_operator expression .

    SEMI            reduce using rule 130 (assignment_action -> identifier assigning_operator expression .)


state 187

    (63) string_element -> identifier LBRACKET ICONST . RBRACKET
    (64) string_slice -> identifier LBRACKET ICONST . COLON ICONST RBRACKET

    RBRACKET        shift and go to state 245
    COLON           shift and go to state 244


state 188

    (118) action_statement -> identifier COLON action . SEMI

    SEMI            shift and go to state 246


state 189

    (185) procedure_statement -> identifier COLON procedure_definition . SEMI

    SEMI            shift and go to state 247


state 190

    (130) assignment_action -> identifier . assigning_operator expression
    (167) procedure_call -> identifier . LPAREN parameter_list RPAREN
    (168) procedure_call -> identifier . LPAREN RPAREN
    (63) string_element -> identifier . LBRACKET ICONST RBRACKET
    (64) string_slice -> identifier . LBRACKET ICONST COLON ICONST RBRACKET
    (131) assigning_operator -> . PLUS ASSIGN
    (132) assigning_operator -> . MINUS ASSIGN
    (133) assigning_operator -> . TIMES ASSIGN
    (134) assigning_operator -> . DIVIDE ASSIGN
    (135) assigning_operator -> . MOD ASSIGN
    (136) assigning_operator -> . CONCAT ASSIGN
    (137) assigning_operator -> . ASSIGN

    LPAREN          shift and go to state 105
    LBRACKET        shift and go to state 103
    PLUS            shift and go to state 83
    MINUS           shift and go to state 82
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 81
    MOD             shift and go to state 89
    CONCAT          shift and go to state 88
    ASSIGN          shift and go to state 87

    assigning_operator             shift and go to state 102

state 191

    (186) procedure_definition -> PROC . LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END
    (187) procedure_definition -> PROC . LPAREN formal_parameter_list RPAREN SEMI statement_list END
    (188) procedure_definition -> PROC . LPAREN RPAREN SEMI statement_list END

    LPAREN          shift and go to state 248


state 192

    (168) procedure_call -> identifier LPAREN RPAREN .

    ARROW           reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    LBRACKET        reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    AND             reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    OR              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    EQ              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    NEQ             reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    GT              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    GE              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    LT              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    LE              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    PLUS            reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    MINUS           reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    TIMES           reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    DIVIDE          reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    MOD             reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    NOT             reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    IN              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    CONCAT          reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    SEMI            reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    THEN            reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    RPAREN          reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    COMMA           reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    RBRACKET        reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    COLON           reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    ELSE            reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    ELSIF           reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    DOWN            reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    BY              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    TO              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    FI              reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    WHILE           reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)
    ASSIGN          reduce using rule 168 (procedure_call -> identifier LPAREN RPAREN .)


state 193

    (167) procedure_call -> identifier LPAREN parameter_list . RPAREN
    (170) parameter_list -> parameter_list . COMMA expression

    RPAREN          shift and go to state 249
    COMMA           shift and go to state 222


state 194

    (82) parenthesized_expression -> LPAREN expression RPAREN .

    AND             reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    MOD             reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    NOT             reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    IN              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    CONCAT          reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    SEMI            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    THEN            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    ELSIF           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    DOWN            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    BY              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    TO              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    FI              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)


state 195

    (117) referenced_location -> ARROW location .
    (62) dereferenced_reference -> location . ARROW
    (65) array_element -> location . LBRACKET expression_list RBRACKET
    (68) array_slice -> location . LBRACKET ICONST COLON ICONST RBRACKET

    AND             reduce using rule 117 (referenced_location -> ARROW location .)
    OR              reduce using rule 117 (referenced_location -> ARROW location .)
    EQ              reduce using rule 117 (referenced_location -> ARROW location .)
    NEQ             reduce using rule 117 (referenced_location -> ARROW location .)
    GT              reduce using rule 117 (referenced_location -> ARROW location .)
    GE              reduce using rule 117 (referenced_location -> ARROW location .)
    LT              reduce using rule 117 (referenced_location -> ARROW location .)
    LE              reduce using rule 117 (referenced_location -> ARROW location .)
    PLUS            reduce using rule 117 (referenced_location -> ARROW location .)
    MINUS           reduce using rule 117 (referenced_location -> ARROW location .)
    TIMES           reduce using rule 117 (referenced_location -> ARROW location .)
    DIVIDE          reduce using rule 117 (referenced_location -> ARROW location .)
    MOD             reduce using rule 117 (referenced_location -> ARROW location .)
    NOT             reduce using rule 117 (referenced_location -> ARROW location .)
    IN              reduce using rule 117 (referenced_location -> ARROW location .)
    CONCAT          reduce using rule 117 (referenced_location -> ARROW location .)
    SEMI            reduce using rule 117 (referenced_location -> ARROW location .)
    THEN            reduce using rule 117 (referenced_location -> ARROW location .)
    RPAREN          reduce using rule 117 (referenced_location -> ARROW location .)
    COMMA           reduce using rule 117 (referenced_location -> ARROW location .)
    RBRACKET        reduce using rule 117 (referenced_location -> ARROW location .)
    COLON           reduce using rule 117 (referenced_location -> ARROW location .)
    ELSE            reduce using rule 117 (referenced_location -> ARROW location .)
    ELSIF           reduce using rule 117 (referenced_location -> ARROW location .)
    DOWN            reduce using rule 117 (referenced_location -> ARROW location .)
    BY              reduce using rule 117 (referenced_location -> ARROW location .)
    TO              reduce using rule 117 (referenced_location -> ARROW location .)
    FI              reduce using rule 117 (referenced_location -> ARROW location .)
    WHILE           reduce using rule 117 (referenced_location -> ARROW location .)
    ARROW           shift and go to state 85
    LBRACKET        shift and go to state 84


state 196

    (93) binop -> binop AND binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 93 (binop -> binop AND binop .)
    OR              reduce using rule 93 (binop -> binop AND binop .)
    NOT             reduce using rule 93 (binop -> binop AND binop .)
    IN              reduce using rule 93 (binop -> binop AND binop .)
    CONCAT          reduce using rule 93 (binop -> binop AND binop .)
    RBRACKET        reduce using rule 93 (binop -> binop AND binop .)
    SEMI            reduce using rule 93 (binop -> binop AND binop .)
    THEN            reduce using rule 93 (binop -> binop AND binop .)
    RPAREN          reduce using rule 93 (binop -> binop AND binop .)
    COMMA           reduce using rule 93 (binop -> binop AND binop .)
    COLON           reduce using rule 93 (binop -> binop AND binop .)
    ELSE            reduce using rule 93 (binop -> binop AND binop .)
    ELSIF           reduce using rule 93 (binop -> binop AND binop .)
    DOWN            reduce using rule 93 (binop -> binop AND binop .)
    BY              reduce using rule 93 (binop -> binop AND binop .)
    TO              reduce using rule 93 (binop -> binop AND binop .)
    FI              reduce using rule 93 (binop -> binop AND binop .)
    WHILE           reduce using rule 93 (binop -> binop AND binop .)
    EQ              shift and go to state 125
    NEQ             shift and go to state 128
    GT              shift and go to state 114
    GE              shift and go to state 118
    LT              shift and go to state 116
    LE              shift and go to state 119
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! EQ              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! NEQ             [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! GT              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! GE              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! LT              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! LE              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! PLUS            [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! MINUS           [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! TIMES           [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! DIVIDE          [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! MOD             [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 197

    (97) binop -> binop GT binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 97 (binop -> binop GT binop .)
    OR              reduce using rule 97 (binop -> binop GT binop .)
    EQ              reduce using rule 97 (binop -> binop GT binop .)
    NEQ             reduce using rule 97 (binop -> binop GT binop .)
    GT              reduce using rule 97 (binop -> binop GT binop .)
    GE              reduce using rule 97 (binop -> binop GT binop .)
    LT              reduce using rule 97 (binop -> binop GT binop .)
    LE              reduce using rule 97 (binop -> binop GT binop .)
    NOT             reduce using rule 97 (binop -> binop GT binop .)
    IN              reduce using rule 97 (binop -> binop GT binop .)
    CONCAT          reduce using rule 97 (binop -> binop GT binop .)
    RBRACKET        reduce using rule 97 (binop -> binop GT binop .)
    SEMI            reduce using rule 97 (binop -> binop GT binop .)
    THEN            reduce using rule 97 (binop -> binop GT binop .)
    RPAREN          reduce using rule 97 (binop -> binop GT binop .)
    COMMA           reduce using rule 97 (binop -> binop GT binop .)
    COLON           reduce using rule 97 (binop -> binop GT binop .)
    ELSE            reduce using rule 97 (binop -> binop GT binop .)
    ELSIF           reduce using rule 97 (binop -> binop GT binop .)
    DOWN            reduce using rule 97 (binop -> binop GT binop .)
    BY              reduce using rule 97 (binop -> binop GT binop .)
    TO              reduce using rule 97 (binop -> binop GT binop .)
    FI              reduce using rule 97 (binop -> binop GT binop .)
    WHILE           reduce using rule 97 (binop -> binop GT binop .)
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! PLUS            [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! MINUS           [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! TIMES           [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! DIVIDE          [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! MOD             [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! GT              [ shift and go to state 114 ]
  ! GE              [ shift and go to state 118 ]
  ! LT              [ shift and go to state 116 ]
  ! LE              [ shift and go to state 119 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 198

    (104) binop -> binop DIVIDE binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 104 (binop -> binop DIVIDE binop .)
    OR              reduce using rule 104 (binop -> binop DIVIDE binop .)
    EQ              reduce using rule 104 (binop -> binop DIVIDE binop .)
    NEQ             reduce using rule 104 (binop -> binop DIVIDE binop .)
    GT              reduce using rule 104 (binop -> binop DIVIDE binop .)
    GE              reduce using rule 104 (binop -> binop DIVIDE binop .)
    LT              reduce using rule 104 (binop -> binop DIVIDE binop .)
    LE              reduce using rule 104 (binop -> binop DIVIDE binop .)
    PLUS            reduce using rule 104 (binop -> binop DIVIDE binop .)
    MINUS           reduce using rule 104 (binop -> binop DIVIDE binop .)
    TIMES           reduce using rule 104 (binop -> binop DIVIDE binop .)
    DIVIDE          reduce using rule 104 (binop -> binop DIVIDE binop .)
    MOD             reduce using rule 104 (binop -> binop DIVIDE binop .)
    NOT             reduce using rule 104 (binop -> binop DIVIDE binop .)
    IN              reduce using rule 104 (binop -> binop DIVIDE binop .)
    CONCAT          reduce using rule 104 (binop -> binop DIVIDE binop .)
    RBRACKET        reduce using rule 104 (binop -> binop DIVIDE binop .)
    SEMI            reduce using rule 104 (binop -> binop DIVIDE binop .)
    THEN            reduce using rule 104 (binop -> binop DIVIDE binop .)
    RPAREN          reduce using rule 104 (binop -> binop DIVIDE binop .)
    COMMA           reduce using rule 104 (binop -> binop DIVIDE binop .)
    COLON           reduce using rule 104 (binop -> binop DIVIDE binop .)
    ELSE            reduce using rule 104 (binop -> binop DIVIDE binop .)
    ELSIF           reduce using rule 104 (binop -> binop DIVIDE binop .)
    DOWN            reduce using rule 104 (binop -> binop DIVIDE binop .)
    BY              reduce using rule 104 (binop -> binop DIVIDE binop .)
    TO              reduce using rule 104 (binop -> binop DIVIDE binop .)
    FI              reduce using rule 104 (binop -> binop DIVIDE binop .)
    WHILE           reduce using rule 104 (binop -> binop DIVIDE binop .)

  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! GT              [ shift and go to state 114 ]
  ! GE              [ shift and go to state 118 ]
  ! LT              [ shift and go to state 116 ]
  ! LE              [ shift and go to state 119 ]
  ! PLUS            [ shift and go to state 120 ]
  ! MINUS           [ shift and go to state 117 ]
  ! TIMES           [ shift and go to state 124 ]
  ! DIVIDE          [ shift and go to state 115 ]
  ! MOD             [ shift and go to state 121 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 199

    (99) binop -> binop LT binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 99 (binop -> binop LT binop .)
    OR              reduce using rule 99 (binop -> binop LT binop .)
    EQ              reduce using rule 99 (binop -> binop LT binop .)
    NEQ             reduce using rule 99 (binop -> binop LT binop .)
    GT              reduce using rule 99 (binop -> binop LT binop .)
    GE              reduce using rule 99 (binop -> binop LT binop .)
    LT              reduce using rule 99 (binop -> binop LT binop .)
    LE              reduce using rule 99 (binop -> binop LT binop .)
    NOT             reduce using rule 99 (binop -> binop LT binop .)
    IN              reduce using rule 99 (binop -> binop LT binop .)
    CONCAT          reduce using rule 99 (binop -> binop LT binop .)
    RBRACKET        reduce using rule 99 (binop -> binop LT binop .)
    SEMI            reduce using rule 99 (binop -> binop LT binop .)
    THEN            reduce using rule 99 (binop -> binop LT binop .)
    RPAREN          reduce using rule 99 (binop -> binop LT binop .)
    COMMA           reduce using rule 99 (binop -> binop LT binop .)
    COLON           reduce using rule 99 (binop -> binop LT binop .)
    ELSE            reduce using rule 99 (binop -> binop LT binop .)
    ELSIF           reduce using rule 99 (binop -> binop LT binop .)
    DOWN            reduce using rule 99 (binop -> binop LT binop .)
    BY              reduce using rule 99 (binop -> binop LT binop .)
    TO              reduce using rule 99 (binop -> binop LT binop .)
    FI              reduce using rule 99 (binop -> binop LT binop .)
    WHILE           reduce using rule 99 (binop -> binop LT binop .)
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! PLUS            [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! MINUS           [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! TIMES           [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! DIVIDE          [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! MOD             [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! GT              [ shift and go to state 114 ]
  ! GE              [ shift and go to state 118 ]
  ! LT              [ shift and go to state 116 ]
  ! LE              [ shift and go to state 119 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 200

    (102) binop -> binop MINUS binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 102 (binop -> binop MINUS binop .)
    OR              reduce using rule 102 (binop -> binop MINUS binop .)
    EQ              reduce using rule 102 (binop -> binop MINUS binop .)
    NEQ             reduce using rule 102 (binop -> binop MINUS binop .)
    GT              reduce using rule 102 (binop -> binop MINUS binop .)
    GE              reduce using rule 102 (binop -> binop MINUS binop .)
    LT              reduce using rule 102 (binop -> binop MINUS binop .)
    LE              reduce using rule 102 (binop -> binop MINUS binop .)
    PLUS            reduce using rule 102 (binop -> binop MINUS binop .)
    MINUS           reduce using rule 102 (binop -> binop MINUS binop .)
    NOT             reduce using rule 102 (binop -> binop MINUS binop .)
    IN              reduce using rule 102 (binop -> binop MINUS binop .)
    CONCAT          reduce using rule 102 (binop -> binop MINUS binop .)
    RBRACKET        reduce using rule 102 (binop -> binop MINUS binop .)
    SEMI            reduce using rule 102 (binop -> binop MINUS binop .)
    THEN            reduce using rule 102 (binop -> binop MINUS binop .)
    RPAREN          reduce using rule 102 (binop -> binop MINUS binop .)
    COMMA           reduce using rule 102 (binop -> binop MINUS binop .)
    COLON           reduce using rule 102 (binop -> binop MINUS binop .)
    ELSE            reduce using rule 102 (binop -> binop MINUS binop .)
    ELSIF           reduce using rule 102 (binop -> binop MINUS binop .)
    DOWN            reduce using rule 102 (binop -> binop MINUS binop .)
    BY              reduce using rule 102 (binop -> binop MINUS binop .)
    TO              reduce using rule 102 (binop -> binop MINUS binop .)
    FI              reduce using rule 102 (binop -> binop MINUS binop .)
    WHILE           reduce using rule 102 (binop -> binop MINUS binop .)
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! TIMES           [ reduce using rule 102 (binop -> binop MINUS binop .) ]
  ! DIVIDE          [ reduce using rule 102 (binop -> binop MINUS binop .) ]
  ! MOD             [ reduce using rule 102 (binop -> binop MINUS binop .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! GT              [ shift and go to state 114 ]
  ! GE              [ shift and go to state 118 ]
  ! LT              [ shift and go to state 116 ]
  ! LE              [ shift and go to state 119 ]
  ! PLUS            [ shift and go to state 120 ]
  ! MINUS           [ shift and go to state 117 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 201

    (98) binop -> binop GE binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 98 (binop -> binop GE binop .)
    OR              reduce using rule 98 (binop -> binop GE binop .)
    EQ              reduce using rule 98 (binop -> binop GE binop .)
    NEQ             reduce using rule 98 (binop -> binop GE binop .)
    GT              reduce using rule 98 (binop -> binop GE binop .)
    GE              reduce using rule 98 (binop -> binop GE binop .)
    LT              reduce using rule 98 (binop -> binop GE binop .)
    LE              reduce using rule 98 (binop -> binop GE binop .)
    NOT             reduce using rule 98 (binop -> binop GE binop .)
    IN              reduce using rule 98 (binop -> binop GE binop .)
    CONCAT          reduce using rule 98 (binop -> binop GE binop .)
    RBRACKET        reduce using rule 98 (binop -> binop GE binop .)
    SEMI            reduce using rule 98 (binop -> binop GE binop .)
    THEN            reduce using rule 98 (binop -> binop GE binop .)
    RPAREN          reduce using rule 98 (binop -> binop GE binop .)
    COMMA           reduce using rule 98 (binop -> binop GE binop .)
    COLON           reduce using rule 98 (binop -> binop GE binop .)
    ELSE            reduce using rule 98 (binop -> binop GE binop .)
    ELSIF           reduce using rule 98 (binop -> binop GE binop .)
    DOWN            reduce using rule 98 (binop -> binop GE binop .)
    BY              reduce using rule 98 (binop -> binop GE binop .)
    TO              reduce using rule 98 (binop -> binop GE binop .)
    FI              reduce using rule 98 (binop -> binop GE binop .)
    WHILE           reduce using rule 98 (binop -> binop GE binop .)
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! PLUS            [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! MINUS           [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! TIMES           [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! DIVIDE          [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! MOD             [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! GT              [ shift and go to state 114 ]
  ! GE              [ shift and go to state 118 ]
  ! LT              [ shift and go to state 116 ]
  ! LE              [ shift and go to state 119 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 202

    (100) binop -> binop LE binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 100 (binop -> binop LE binop .)
    OR              reduce using rule 100 (binop -> binop LE binop .)
    EQ              reduce using rule 100 (binop -> binop LE binop .)
    NEQ             reduce using rule 100 (binop -> binop LE binop .)
    GT              reduce using rule 100 (binop -> binop LE binop .)
    GE              reduce using rule 100 (binop -> binop LE binop .)
    LT              reduce using rule 100 (binop -> binop LE binop .)
    LE              reduce using rule 100 (binop -> binop LE binop .)
    NOT             reduce using rule 100 (binop -> binop LE binop .)
    IN              reduce using rule 100 (binop -> binop LE binop .)
    CONCAT          reduce using rule 100 (binop -> binop LE binop .)
    RBRACKET        reduce using rule 100 (binop -> binop LE binop .)
    SEMI            reduce using rule 100 (binop -> binop LE binop .)
    THEN            reduce using rule 100 (binop -> binop LE binop .)
    RPAREN          reduce using rule 100 (binop -> binop LE binop .)
    COMMA           reduce using rule 100 (binop -> binop LE binop .)
    COLON           reduce using rule 100 (binop -> binop LE binop .)
    ELSE            reduce using rule 100 (binop -> binop LE binop .)
    ELSIF           reduce using rule 100 (binop -> binop LE binop .)
    DOWN            reduce using rule 100 (binop -> binop LE binop .)
    BY              reduce using rule 100 (binop -> binop LE binop .)
    TO              reduce using rule 100 (binop -> binop LE binop .)
    FI              reduce using rule 100 (binop -> binop LE binop .)
    WHILE           reduce using rule 100 (binop -> binop LE binop .)
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! PLUS            [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! MINUS           [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! TIMES           [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! DIVIDE          [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! MOD             [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! GT              [ shift and go to state 114 ]
  ! GE              [ shift and go to state 118 ]
  ! LT              [ shift and go to state 116 ]
  ! LE              [ shift and go to state 119 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 203

    (101) binop -> binop PLUS binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 101 (binop -> binop PLUS binop .)
    OR              reduce using rule 101 (binop -> binop PLUS binop .)
    EQ              reduce using rule 101 (binop -> binop PLUS binop .)
    NEQ             reduce using rule 101 (binop -> binop PLUS binop .)
    GT              reduce using rule 101 (binop -> binop PLUS binop .)
    GE              reduce using rule 101 (binop -> binop PLUS binop .)
    LT              reduce using rule 101 (binop -> binop PLUS binop .)
    LE              reduce using rule 101 (binop -> binop PLUS binop .)
    PLUS            reduce using rule 101 (binop -> binop PLUS binop .)
    MINUS           reduce using rule 101 (binop -> binop PLUS binop .)
    NOT             reduce using rule 101 (binop -> binop PLUS binop .)
    IN              reduce using rule 101 (binop -> binop PLUS binop .)
    CONCAT          reduce using rule 101 (binop -> binop PLUS binop .)
    RBRACKET        reduce using rule 101 (binop -> binop PLUS binop .)
    SEMI            reduce using rule 101 (binop -> binop PLUS binop .)
    THEN            reduce using rule 101 (binop -> binop PLUS binop .)
    RPAREN          reduce using rule 101 (binop -> binop PLUS binop .)
    COMMA           reduce using rule 101 (binop -> binop PLUS binop .)
    COLON           reduce using rule 101 (binop -> binop PLUS binop .)
    ELSE            reduce using rule 101 (binop -> binop PLUS binop .)
    ELSIF           reduce using rule 101 (binop -> binop PLUS binop .)
    DOWN            reduce using rule 101 (binop -> binop PLUS binop .)
    BY              reduce using rule 101 (binop -> binop PLUS binop .)
    TO              reduce using rule 101 (binop -> binop PLUS binop .)
    FI              reduce using rule 101 (binop -> binop PLUS binop .)
    WHILE           reduce using rule 101 (binop -> binop PLUS binop .)
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! TIMES           [ reduce using rule 101 (binop -> binop PLUS binop .) ]
  ! DIVIDE          [ reduce using rule 101 (binop -> binop PLUS binop .) ]
  ! MOD             [ reduce using rule 101 (binop -> binop PLUS binop .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! GT              [ shift and go to state 114 ]
  ! GE              [ shift and go to state 118 ]
  ! LT              [ shift and go to state 116 ]
  ! LE              [ shift and go to state 119 ]
  ! PLUS            [ shift and go to state 120 ]
  ! MINUS           [ shift and go to state 117 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 204

    (105) binop -> binop MOD binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 105 (binop -> binop MOD binop .)
    OR              reduce using rule 105 (binop -> binop MOD binop .)
    EQ              reduce using rule 105 (binop -> binop MOD binop .)
    NEQ             reduce using rule 105 (binop -> binop MOD binop .)
    GT              reduce using rule 105 (binop -> binop MOD binop .)
    GE              reduce using rule 105 (binop -> binop MOD binop .)
    LT              reduce using rule 105 (binop -> binop MOD binop .)
    LE              reduce using rule 105 (binop -> binop MOD binop .)
    PLUS            reduce using rule 105 (binop -> binop MOD binop .)
    MINUS           reduce using rule 105 (binop -> binop MOD binop .)
    TIMES           reduce using rule 105 (binop -> binop MOD binop .)
    DIVIDE          reduce using rule 105 (binop -> binop MOD binop .)
    MOD             reduce using rule 105 (binop -> binop MOD binop .)
    NOT             reduce using rule 105 (binop -> binop MOD binop .)
    IN              reduce using rule 105 (binop -> binop MOD binop .)
    CONCAT          reduce using rule 105 (binop -> binop MOD binop .)
    RBRACKET        reduce using rule 105 (binop -> binop MOD binop .)
    SEMI            reduce using rule 105 (binop -> binop MOD binop .)
    THEN            reduce using rule 105 (binop -> binop MOD binop .)
    RPAREN          reduce using rule 105 (binop -> binop MOD binop .)
    COMMA           reduce using rule 105 (binop -> binop MOD binop .)
    COLON           reduce using rule 105 (binop -> binop MOD binop .)
    ELSE            reduce using rule 105 (binop -> binop MOD binop .)
    ELSIF           reduce using rule 105 (binop -> binop MOD binop .)
    DOWN            reduce using rule 105 (binop -> binop MOD binop .)
    BY              reduce using rule 105 (binop -> binop MOD binop .)
    TO              reduce using rule 105 (binop -> binop MOD binop .)
    FI              reduce using rule 105 (binop -> binop MOD binop .)
    WHILE           reduce using rule 105 (binop -> binop MOD binop .)

  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! GT              [ shift and go to state 114 ]
  ! GE              [ shift and go to state 118 ]
  ! LT              [ shift and go to state 116 ]
  ! LE              [ shift and go to state 119 ]
  ! PLUS            [ shift and go to state 120 ]
  ! MINUS           [ shift and go to state 117 ]
  ! TIMES           [ shift and go to state 124 ]
  ! DIVIDE          [ shift and go to state 115 ]
  ! MOD             [ shift and go to state 121 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 205

    (107) binop -> binop IN binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    NOT             reduce using rule 107 (binop -> binop IN binop .)
    IN              reduce using rule 107 (binop -> binop IN binop .)
    CONCAT          reduce using rule 107 (binop -> binop IN binop .)
    RBRACKET        reduce using rule 107 (binop -> binop IN binop .)
    SEMI            reduce using rule 107 (binop -> binop IN binop .)
    THEN            reduce using rule 107 (binop -> binop IN binop .)
    RPAREN          reduce using rule 107 (binop -> binop IN binop .)
    COMMA           reduce using rule 107 (binop -> binop IN binop .)
    COLON           reduce using rule 107 (binop -> binop IN binop .)
    ELSE            reduce using rule 107 (binop -> binop IN binop .)
    ELSIF           reduce using rule 107 (binop -> binop IN binop .)
    DOWN            reduce using rule 107 (binop -> binop IN binop .)
    BY              reduce using rule 107 (binop -> binop IN binop .)
    TO              reduce using rule 107 (binop -> binop IN binop .)
    FI              reduce using rule 107 (binop -> binop IN binop .)
    WHILE           reduce using rule 107 (binop -> binop IN binop .)
    AND             shift and go to state 113
    OR              shift and go to state 126
    EQ              shift and go to state 125
    NEQ             shift and go to state 128
    GT              shift and go to state 114
    GE              shift and go to state 118
    LT              shift and go to state 116
    LE              shift and go to state 119
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! AND             [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! OR              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! EQ              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! NEQ             [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! GT              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! GE              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! LT              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! LE              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! PLUS            [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! MINUS           [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! TIMES           [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! DIVIDE          [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! MOD             [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 206

    (106) binop -> binop NOT binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    NOT             reduce using rule 106 (binop -> binop NOT binop .)
    CONCAT          reduce using rule 106 (binop -> binop NOT binop .)
    RBRACKET        reduce using rule 106 (binop -> binop NOT binop .)
    SEMI            reduce using rule 106 (binop -> binop NOT binop .)
    THEN            reduce using rule 106 (binop -> binop NOT binop .)
    RPAREN          reduce using rule 106 (binop -> binop NOT binop .)
    COMMA           reduce using rule 106 (binop -> binop NOT binop .)
    COLON           reduce using rule 106 (binop -> binop NOT binop .)
    ELSE            reduce using rule 106 (binop -> binop NOT binop .)
    ELSIF           reduce using rule 106 (binop -> binop NOT binop .)
    DOWN            reduce using rule 106 (binop -> binop NOT binop .)
    BY              reduce using rule 106 (binop -> binop NOT binop .)
    TO              reduce using rule 106 (binop -> binop NOT binop .)
    FI              reduce using rule 106 (binop -> binop NOT binop .)
    WHILE           reduce using rule 106 (binop -> binop NOT binop .)
    AND             shift and go to state 113
    OR              shift and go to state 126
    EQ              shift and go to state 125
    NEQ             shift and go to state 128
    GT              shift and go to state 114
    GE              shift and go to state 118
    LT              shift and go to state 116
    LE              shift and go to state 119
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121
    IN              shift and go to state 122

  ! AND             [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! OR              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! EQ              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! NEQ             [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! GT              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! GE              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! LT              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! LE              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! PLUS            [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! MINUS           [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! TIMES           [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! DIVIDE          [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! MOD             [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! IN              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! NOT             [ shift and go to state 123 ]
  ! CONCAT          [ shift and go to state 127 ]


state 207

    (103) binop -> binop TIMES binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 103 (binop -> binop TIMES binop .)
    OR              reduce using rule 103 (binop -> binop TIMES binop .)
    EQ              reduce using rule 103 (binop -> binop TIMES binop .)
    NEQ             reduce using rule 103 (binop -> binop TIMES binop .)
    GT              reduce using rule 103 (binop -> binop TIMES binop .)
    GE              reduce using rule 103 (binop -> binop TIMES binop .)
    LT              reduce using rule 103 (binop -> binop TIMES binop .)
    LE              reduce using rule 103 (binop -> binop TIMES binop .)
    PLUS            reduce using rule 103 (binop -> binop TIMES binop .)
    MINUS           reduce using rule 103 (binop -> binop TIMES binop .)
    TIMES           reduce using rule 103 (binop -> binop TIMES binop .)
    DIVIDE          reduce using rule 103 (binop -> binop TIMES binop .)
    MOD             reduce using rule 103 (binop -> binop TIMES binop .)
    NOT             reduce using rule 103 (binop -> binop TIMES binop .)
    IN              reduce using rule 103 (binop -> binop TIMES binop .)
    CONCAT          reduce using rule 103 (binop -> binop TIMES binop .)
    RBRACKET        reduce using rule 103 (binop -> binop TIMES binop .)
    SEMI            reduce using rule 103 (binop -> binop TIMES binop .)
    THEN            reduce using rule 103 (binop -> binop TIMES binop .)
    RPAREN          reduce using rule 103 (binop -> binop TIMES binop .)
    COMMA           reduce using rule 103 (binop -> binop TIMES binop .)
    COLON           reduce using rule 103 (binop -> binop TIMES binop .)
    ELSE            reduce using rule 103 (binop -> binop TIMES binop .)
    ELSIF           reduce using rule 103 (binop -> binop TIMES binop .)
    DOWN            reduce using rule 103 (binop -> binop TIMES binop .)
    BY              reduce using rule 103 (binop -> binop TIMES binop .)
    TO              reduce using rule 103 (binop -> binop TIMES binop .)
    FI              reduce using rule 103 (binop -> binop TIMES binop .)
    WHILE           reduce using rule 103 (binop -> binop TIMES binop .)

  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! GT              [ shift and go to state 114 ]
  ! GE              [ shift and go to state 118 ]
  ! LT              [ shift and go to state 116 ]
  ! LE              [ shift and go to state 119 ]
  ! PLUS            [ shift and go to state 120 ]
  ! MINUS           [ shift and go to state 117 ]
  ! TIMES           [ shift and go to state 124 ]
  ! DIVIDE          [ shift and go to state 115 ]
  ! MOD             [ shift and go to state 121 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 208

    (95) binop -> binop EQ binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 95 (binop -> binop EQ binop .)
    OR              reduce using rule 95 (binop -> binop EQ binop .)
    EQ              reduce using rule 95 (binop -> binop EQ binop .)
    NEQ             reduce using rule 95 (binop -> binop EQ binop .)
    NOT             reduce using rule 95 (binop -> binop EQ binop .)
    IN              reduce using rule 95 (binop -> binop EQ binop .)
    CONCAT          reduce using rule 95 (binop -> binop EQ binop .)
    RBRACKET        reduce using rule 95 (binop -> binop EQ binop .)
    SEMI            reduce using rule 95 (binop -> binop EQ binop .)
    THEN            reduce using rule 95 (binop -> binop EQ binop .)
    RPAREN          reduce using rule 95 (binop -> binop EQ binop .)
    COMMA           reduce using rule 95 (binop -> binop EQ binop .)
    COLON           reduce using rule 95 (binop -> binop EQ binop .)
    ELSE            reduce using rule 95 (binop -> binop EQ binop .)
    ELSIF           reduce using rule 95 (binop -> binop EQ binop .)
    DOWN            reduce using rule 95 (binop -> binop EQ binop .)
    BY              reduce using rule 95 (binop -> binop EQ binop .)
    TO              reduce using rule 95 (binop -> binop EQ binop .)
    FI              reduce using rule 95 (binop -> binop EQ binop .)
    WHILE           reduce using rule 95 (binop -> binop EQ binop .)
    GT              shift and go to state 114
    GE              shift and go to state 118
    LT              shift and go to state 116
    LE              shift and go to state 119
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! GT              [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! GE              [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! LT              [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! LE              [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! PLUS            [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! MINUS           [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! TIMES           [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! DIVIDE          [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! MOD             [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 209

    (94) binop -> binop OR binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    OR              reduce using rule 94 (binop -> binop OR binop .)
    NOT             reduce using rule 94 (binop -> binop OR binop .)
    IN              reduce using rule 94 (binop -> binop OR binop .)
    CONCAT          reduce using rule 94 (binop -> binop OR binop .)
    RBRACKET        reduce using rule 94 (binop -> binop OR binop .)
    SEMI            reduce using rule 94 (binop -> binop OR binop .)
    THEN            reduce using rule 94 (binop -> binop OR binop .)
    RPAREN          reduce using rule 94 (binop -> binop OR binop .)
    COMMA           reduce using rule 94 (binop -> binop OR binop .)
    COLON           reduce using rule 94 (binop -> binop OR binop .)
    ELSE            reduce using rule 94 (binop -> binop OR binop .)
    ELSIF           reduce using rule 94 (binop -> binop OR binop .)
    DOWN            reduce using rule 94 (binop -> binop OR binop .)
    BY              reduce using rule 94 (binop -> binop OR binop .)
    TO              reduce using rule 94 (binop -> binop OR binop .)
    FI              reduce using rule 94 (binop -> binop OR binop .)
    WHILE           reduce using rule 94 (binop -> binop OR binop .)
    AND             shift and go to state 113
    EQ              shift and go to state 125
    NEQ             shift and go to state 128
    GT              shift and go to state 114
    GE              shift and go to state 118
    LT              shift and go to state 116
    LE              shift and go to state 119
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! AND             [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! EQ              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! NEQ             [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! GT              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! GE              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! LT              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! LE              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! PLUS            [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! MINUS           [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! TIMES           [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! DIVIDE          [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! MOD             [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! OR              [ shift and go to state 126 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 210

    (108) binop -> binop CONCAT binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    CONCAT          reduce using rule 108 (binop -> binop CONCAT binop .)
    RBRACKET        reduce using rule 108 (binop -> binop CONCAT binop .)
    SEMI            reduce using rule 108 (binop -> binop CONCAT binop .)
    THEN            reduce using rule 108 (binop -> binop CONCAT binop .)
    RPAREN          reduce using rule 108 (binop -> binop CONCAT binop .)
    COMMA           reduce using rule 108 (binop -> binop CONCAT binop .)
    COLON           reduce using rule 108 (binop -> binop CONCAT binop .)
    ELSE            reduce using rule 108 (binop -> binop CONCAT binop .)
    ELSIF           reduce using rule 108 (binop -> binop CONCAT binop .)
    DOWN            reduce using rule 108 (binop -> binop CONCAT binop .)
    BY              reduce using rule 108 (binop -> binop CONCAT binop .)
    TO              reduce using rule 108 (binop -> binop CONCAT binop .)
    FI              reduce using rule 108 (binop -> binop CONCAT binop .)
    WHILE           reduce using rule 108 (binop -> binop CONCAT binop .)
    AND             shift and go to state 113
    OR              shift and go to state 126
    EQ              shift and go to state 125
    NEQ             shift and go to state 128
    GT              shift and go to state 114
    GE              shift and go to state 118
    LT              shift and go to state 116
    LE              shift and go to state 119
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121
    NOT             shift and go to state 123
    IN              shift and go to state 122

  ! AND             [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! OR              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! EQ              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! NEQ             [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! GT              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! GE              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! LT              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! LE              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! PLUS            [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! MINUS           [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! TIMES           [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! DIVIDE          [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! MOD             [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! NOT             [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! IN              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! CONCAT          [ shift and go to state 127 ]


state 211

    (96) binop -> binop NEQ binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 96 (binop -> binop NEQ binop .)
    OR              reduce using rule 96 (binop -> binop NEQ binop .)
    EQ              reduce using rule 96 (binop -> binop NEQ binop .)
    NEQ             reduce using rule 96 (binop -> binop NEQ binop .)
    NOT             reduce using rule 96 (binop -> binop NEQ binop .)
    IN              reduce using rule 96 (binop -> binop NEQ binop .)
    CONCAT          reduce using rule 96 (binop -> binop NEQ binop .)
    RBRACKET        reduce using rule 96 (binop -> binop NEQ binop .)
    SEMI            reduce using rule 96 (binop -> binop NEQ binop .)
    THEN            reduce using rule 96 (binop -> binop NEQ binop .)
    RPAREN          reduce using rule 96 (binop -> binop NEQ binop .)
    COMMA           reduce using rule 96 (binop -> binop NEQ binop .)
    COLON           reduce using rule 96 (binop -> binop NEQ binop .)
    ELSE            reduce using rule 96 (binop -> binop NEQ binop .)
    ELSIF           reduce using rule 96 (binop -> binop NEQ binop .)
    DOWN            reduce using rule 96 (binop -> binop NEQ binop .)
    BY              reduce using rule 96 (binop -> binop NEQ binop .)
    TO              reduce using rule 96 (binop -> binop NEQ binop .)
    FI              reduce using rule 96 (binop -> binop NEQ binop .)
    WHILE           reduce using rule 96 (binop -> binop NEQ binop .)
    GT              shift and go to state 114
    GE              shift and go to state 118
    LT              shift and go to state 116
    LE              shift and go to state 119
    PLUS            shift and go to state 120
    MINUS           shift and go to state 117
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 121

  ! GT              [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! GE              [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! LT              [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! LE              [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! PLUS            [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! MINUS           [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! TIMES           [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! DIVIDE          [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! MOD             [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 126 ]
  ! EQ              [ shift and go to state 125 ]
  ! NEQ             [ shift and go to state 128 ]
  ! NOT             [ shift and go to state 123 ]
  ! IN              [ shift and go to state 122 ]
  ! CONCAT          [ shift and go to state 127 ]


state 212

    (88) then_expression -> THEN . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 250
    primitive_value                shift and go to state 66

state 213

    (85) conditional_expression -> IF boolean_expression then_expression . else_expression FI
    (86) conditional_expression -> IF boolean_expression then_expression . elsif_expression else_expression FI
    (89) else_expression -> . ELSE expression
    (90) elsif_expression -> . ELSIF boolean_expression then_expression
    (91) elsif_expression -> . elsif_expression ELSIF boolean_expression then_expression

    ELSE            shift and go to state 251
    ELSIF           shift and go to state 253

    elsif_expression               shift and go to state 252
    else_expression                shift and go to state 254

state 214

    (79) value_array_element -> array_primitive_value LBRACKET expression_list . RBRACKET
    (67) expression_list -> expression_list . COMMA expression

    RBRACKET        shift and go to state 255
    COMMA           shift and go to state 233


state 215

    (80) value_array_slice -> array_primitive_value LBRACKET expression . COLON expression RBRACKET
    (66) expression_list -> expression .

    COLON           shift and go to state 256
    RBRACKET        reduce using rule 66 (expression_list -> expression .)
    COMMA           reduce using rule 66 (expression_list -> expression .)


state 216

    (144) do_action -> DO control_part SEMI action_statement_list . OD
    (121) action_statement_list -> action_statement_list . action_statement
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    OD              shift and go to state 257
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 134
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 73

state 217

    (145) do_action -> DO control_part SEMI OD .

    SEMI            reduce using rule 145 (do_action -> DO control_part SEMI OD .)


state 218

    (162) range_enumeration -> loop_counter DOWN . IN discrete_mode_name

    IN              shift and go to state 258


state 219

    (163) range_enumeration -> loop_counter IN . discrete_mode_name
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    discrete_mode_name             shift and go to state 259
    identifier                     shift and go to state 260

state 220

    (153) step_enumeration -> loop_counter ASSIGN . start_value step_value DOWN end_value
    (154) step_enumeration -> loop_counter ASSIGN . start_value DOWN end_value
    (155) step_enumeration -> loop_counter ASSIGN . start_value step_value end_value
    (156) step_enumeration -> loop_counter ASSIGN . start_value end_value
    (158) start_value -> . discrete_expression
    (161) discrete_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    discrete_expression            shift and go to state 261
    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    start_value                    shift and go to state 262
    identifier                     shift and go to state 64
    expression                     shift and go to state 263
    primitive_value                shift and go to state 66

state 221

    (175) builtin_call -> builtin_name LPAREN parameter_list RPAREN .

    SEMI            reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    ARROW           reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    LBRACKET        reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    PLUS            reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    MINUS           reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    TIMES           reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    DIVIDE          reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    MOD             reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    CONCAT          reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    ASSIGN          reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    AND             reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    OR              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    EQ              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    NEQ             reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    GT              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    GE              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    LT              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    LE              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    NOT             reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    IN              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    RPAREN          reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    COMMA           reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    THEN            reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    RBRACKET        reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    COLON           reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    ELSE            reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    ELSIF           reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    DOWN            reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    BY              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    TO              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    FI              reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    WHILE           reduce using rule 175 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)


state 222

    (170) parameter_list -> parameter_list COMMA . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 264
    primitive_value                shift and go to state 66

state 223

    (11) declaration_list -> declaration_list COMMA declaration .

    SEMI            reduce using rule 11 (declaration_list -> declaration_list COMMA declaration .)
    COMMA           reduce using rule 11 (declaration_list -> declaration_list COMMA declaration .)


state 224

    (39) discrete_range_mode -> discrete_mode_name LPAREN . literal_range RPAREN
    (43) literal_range -> . ICONST COLON ICONST

    ICONST          shift and go to state 265

    literal_range                  shift and go to state 266

state 225

    (40) discrete_range_mode -> discrete_mode LPAREN . literal_range RPAREN
    (43) literal_range -> . ICONST COLON ICONST

    ICONST          shift and go to state 265

    literal_range                  shift and go to state 267

state 226

    (44) reference_mode -> REF mode .

    COMMA           reduce using rule 44 (reference_mode -> REF mode .)
    DCL             reduce using rule 44 (reference_mode -> REF mode .)
    SYN             reduce using rule 44 (reference_mode -> REF mode .)
    TYPE            reduce using rule 44 (reference_mode -> REF mode .)
    ID              reduce using rule 44 (reference_mode -> REF mode .)
    IF              reduce using rule 44 (reference_mode -> REF mode .)
    DO              reduce using rule 44 (reference_mode -> REF mode .)
    EXIT            reduce using rule 44 (reference_mode -> REF mode .)
    RETURN          reduce using rule 44 (reference_mode -> REF mode .)
    RESULT          reduce using rule 44 (reference_mode -> REF mode .)
    NUM             reduce using rule 44 (reference_mode -> REF mode .)
    PRED            reduce using rule 44 (reference_mode -> REF mode .)
    SUCC            reduce using rule 44 (reference_mode -> REF mode .)
    UPPER           reduce using rule 44 (reference_mode -> REF mode .)
    LOWER           reduce using rule 44 (reference_mode -> REF mode .)
    LENGTH          reduce using rule 44 (reference_mode -> REF mode .)
    READ            reduce using rule 44 (reference_mode -> REF mode .)
    PRINT           reduce using rule 44 (reference_mode -> REF mode .)
    $end            reduce using rule 44 (reference_mode -> REF mode .)
    END             reduce using rule 44 (reference_mode -> REF mode .)
    ASSIGN          reduce using rule 44 (reference_mode -> REF mode .)
    SEMI            reduce using rule 44 (reference_mode -> REF mode .)
    LOC             reduce using rule 44 (reference_mode -> REF mode .)
    RPAREN          reduce using rule 44 (reference_mode -> REF mode .)


state 227

    (16) identifier_list -> identifier_list COMMA identifier .

    COMMA           reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    REF             reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    ID              reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    INT             reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    BOOL            reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    CHAR            reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    CHARS           reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    ARRAY           reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    ASSIGN          reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)


state 228

    (49) array_mode -> ARRAY LBRACKET . index_mode RBRACKET element_mode
    (50) array_mode -> ARRAY LBRACKET . index_mode COMMA index_mode_list RBRACKET element_mode
    (53) index_mode -> . discrete_mode
    (54) index_mode -> . literal_range
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (43) literal_range -> . ICONST COLON ICONST
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ICONST          shift and go to state 265
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    ID              shift and go to state 31

    discrete_range_mode            shift and go to state 160
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    discrete_mode                  shift and go to state 268
    discrete_mode_name             shift and go to state 151
    integer_mode                   shift and go to state 159
    index_mode                     shift and go to state 269
    identifier                     shift and go to state 260
    literal_range                  shift and go to state 270

state 229

    (47) string_mode -> CHARS LBRACKET . string_length RBRACKET
    (48) string_length -> . ICONST

    ICONST          shift and go to state 271

    string_length                  shift and go to state 272

state 230

    (12) declaration -> identifier_list mode initialization .

    SEMI            reduce using rule 12 (declaration -> identifier_list mode initialization .)
    COMMA           reduce using rule 12 (declaration -> identifier_list mode initialization .)


state 231

    (14) initialization -> ASSIGN . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 273
    primitive_value                shift and go to state 66

state 232

    (68) array_slice -> location LBRACKET ICONST COLON . ICONST RBRACKET

    ICONST          shift and go to state 274


state 233

    (67) expression_list -> expression_list COMMA . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 275
    primitive_value                shift and go to state 66

state 234

    (65) array_element -> location LBRACKET expression_list RBRACKET .

    ARROW           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    LBRACKET        reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    PLUS            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    MINUS           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    TIMES           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    DIVIDE          reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    MOD             reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    CONCAT          reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    ASSIGN          reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    AND             reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    OR              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    EQ              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    NEQ             reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    GT              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    GE              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    LT              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    LE              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    NOT             reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    IN              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    SEMI            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    COMMA           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    THEN            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    RPAREN          reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    RBRACKET        reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    COLON           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    ELSE            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    ELSIF           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    DOWN            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    BY              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    TO              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    FI              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    WHILE           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)


state 235

    (140) then_clause -> THEN action_statement_list .
    (121) action_statement_list -> action_statement_list . action_statement
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    FI              reduce using rule 140 (then_clause -> THEN action_statement_list .)
    ELSE            reduce using rule 140 (then_clause -> THEN action_statement_list .)
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 134
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 73

state 236

    (142) else_clause -> ELSE . action_statement_list
    (143) else_clause -> ELSE .
    (120) action_statement_list -> . action_statement
    (121) action_statement_list -> . action_statement_list action_statement
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    FI              reduce using rule 143 (else_clause -> ELSE .)
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    action_statement_list          shift and go to state 276
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 74
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 73

state 237

    (138) if_action -> IF boolean_expression then_clause else_clause . FI

    FI              shift and go to state 277


state 238

    (139) if_action -> IF boolean_expression then_clause FI .

    SEMI            reduce using rule 139 (if_action -> IF boolean_expression then_clause FI .)


state 239

    (26) newmode_list -> newmode_list COMMA mode_definition .

    COMMA           reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    DCL             reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    SYN             reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    TYPE            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    ID              reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    IF              reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    DO              reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    EXIT            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    RETURN          reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    RESULT          reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    NUM             reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    PRED            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    SUCC            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    UPPER           reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    LOWER           reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    LENGTH          reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    READ            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    PRINT           reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    $end            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    END             reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)


state 240

    (20) synonym_list -> synonym_list COMMA synonym_definition .

    SEMI            reduce using rule 20 (synonym_list -> synonym_list COMMA synonym_definition .)
    COMMA           reduce using rule 20 (synonym_list -> synonym_list COMMA synonym_definition .)


state 241

    (22) synonym_definition -> identifier_list ASSIGN constant_expression .

    SEMI            reduce using rule 22 (synonym_definition -> identifier_list ASSIGN constant_expression .)
    COMMA           reduce using rule 22 (synonym_definition -> identifier_list ASSIGN constant_expression .)


state 242

    (23) constant_expression -> expression .

    SEMI            reduce using rule 23 (constant_expression -> expression .)
    COMMA           reduce using rule 23 (constant_expression -> expression .)


state 243

    (21) synonym_definition -> identifier_list mode ASSIGN . constant_expression
    (23) constant_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    constant_expression            shift and go to state 278
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 242
    primitive_value                shift and go to state 66

state 244

    (64) string_slice -> identifier LBRACKET ICONST COLON . ICONST RBRACKET

    ICONST          shift and go to state 279


state 245

    (63) string_element -> identifier LBRACKET ICONST RBRACKET .

    ARROW           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    LBRACKET        reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    AND             reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    OR              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    EQ              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    NEQ             reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    GT              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    GE              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    LT              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    LE              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    PLUS            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    MINUS           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    TIMES           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    DIVIDE          reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    MOD             reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    NOT             reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    IN              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    CONCAT          reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    RBRACKET        reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    ASSIGN          reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    SEMI            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    THEN            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    RPAREN          reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    COMMA           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    COLON           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    ELSE            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    ELSIF           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    DOWN            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    BY              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    TO              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    FI              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    WHILE           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)


state 246

    (118) action_statement -> identifier COLON action SEMI .

    OD              reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    ID              reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    IF              reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    DO              reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    EXIT            reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    RETURN          reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    RESULT          reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    NUM             reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    PRED            reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    SUCC            reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    UPPER           reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    LOWER           reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    LENGTH          reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    READ            reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    PRINT           reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    END             reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    DCL             reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    SYN             reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    TYPE            reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    FI              reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    ELSE            reduce using rule 118 (action_statement -> identifier COLON action SEMI .)
    $end            reduce using rule 118 (action_statement -> identifier COLON action SEMI .)


state 247

    (185) procedure_statement -> identifier COLON procedure_definition SEMI .

    DCL             reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    SYN             reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    TYPE            reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    ID              reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    IF              reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    DO              reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    EXIT            reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    RETURN          reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    RESULT          reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    NUM             reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    PRED            reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    SUCC            reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    UPPER           reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    LOWER           reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    LENGTH          reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    READ            reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    PRINT           reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    $end            reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    END             reduce using rule 185 (procedure_statement -> identifier COLON procedure_definition SEMI .)


state 248

    (186) procedure_definition -> PROC LPAREN . formal_parameter_list RPAREN result_spec SEMI statement_list END
    (187) procedure_definition -> PROC LPAREN . formal_parameter_list RPAREN SEMI statement_list END
    (188) procedure_definition -> PROC LPAREN . RPAREN SEMI statement_list END
    (189) formal_parameter_list -> . formal_parameter
    (190) formal_parameter_list -> . formal_parameter_list COMMA formal_parameter
    (191) formal_parameter -> . identifier_list parameter_spec
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    RPAREN          shift and go to state 281
    ID              shift and go to state 31

    formal_parameter_list          shift and go to state 280
    identifier                     shift and go to state 76
    formal_parameter               shift and go to state 282
    identifier_list                shift and go to state 283

state 249

    (167) procedure_call -> identifier LPAREN parameter_list RPAREN .

    ARROW           reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    LBRACKET        reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    AND             reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    OR              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    EQ              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    NEQ             reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    GT              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    GE              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    LT              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    LE              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    PLUS            reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    MINUS           reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    TIMES           reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    DIVIDE          reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    MOD             reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    NOT             reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    IN              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    CONCAT          reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    SEMI            reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    THEN            reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    RPAREN          reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    COMMA           reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    RBRACKET        reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    COLON           reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    ELSE            reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    ELSIF           reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    DOWN            reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    BY              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    TO              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    FI              reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    WHILE           reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    ASSIGN          reduce using rule 167 (procedure_call -> identifier LPAREN parameter_list RPAREN .)


state 250

    (88) then_expression -> THEN expression .

    ELSIF           reduce using rule 88 (then_expression -> THEN expression .)
    ELSE            reduce using rule 88 (then_expression -> THEN expression .)


state 251

    (89) else_expression -> ELSE . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 284
    primitive_value                shift and go to state 66

state 252

    (86) conditional_expression -> IF boolean_expression then_expression elsif_expression . else_expression FI
    (91) elsif_expression -> elsif_expression . ELSIF boolean_expression then_expression
    (89) else_expression -> . ELSE expression

    ELSIF           shift and go to state 285
    ELSE            shift and go to state 251

    else_expression                shift and go to state 286

state 253

    (90) elsif_expression -> ELSIF . boolean_expression then_expression
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    boolean_expression             shift and go to state 287
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 93
    primitive_value                shift and go to state 66

state 254

    (85) conditional_expression -> IF boolean_expression then_expression else_expression . FI

    FI              shift and go to state 288


state 255

    (79) value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .

    AND             reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    OR              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    EQ              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    NEQ             reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    GT              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    GE              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    LT              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    LE              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    PLUS            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    MINUS           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    TIMES           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    DIVIDE          reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    MOD             reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    NOT             reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    IN              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    CONCAT          reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    SEMI            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    THEN            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    RPAREN          reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    COMMA           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    RBRACKET        reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    COLON           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    ELSE            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    ELSIF           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    DOWN            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    BY              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    TO              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    FI              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    WHILE           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    LBRACKET        reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)


state 256

    (80) value_array_slice -> array_primitive_value LBRACKET expression COLON . expression RBRACKET
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 289
    primitive_value                shift and go to state 66

state 257

    (144) do_action -> DO control_part SEMI action_statement_list OD .

    SEMI            reduce using rule 144 (do_action -> DO control_part SEMI action_statement_list OD .)


state 258

    (162) range_enumeration -> loop_counter DOWN IN . discrete_mode_name
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    discrete_mode_name             shift and go to state 290
    identifier                     shift and go to state 260

state 259

    (163) range_enumeration -> loop_counter IN discrete_mode_name .

    WHILE           reduce using rule 163 (range_enumeration -> loop_counter IN discrete_mode_name .)
    SEMI            reduce using rule 163 (range_enumeration -> loop_counter IN discrete_mode_name .)


state 260

    (42) discrete_mode_name -> identifier .

    LPAREN          reduce using rule 42 (discrete_mode_name -> identifier .)
    WHILE           reduce using rule 42 (discrete_mode_name -> identifier .)
    SEMI            reduce using rule 42 (discrete_mode_name -> identifier .)


state 261

    (158) start_value -> discrete_expression .

    DOWN            reduce using rule 158 (start_value -> discrete_expression .)
    BY              reduce using rule 158 (start_value -> discrete_expression .)
    TO              reduce using rule 158 (start_value -> discrete_expression .)


state 262

    (153) step_enumeration -> loop_counter ASSIGN start_value . step_value DOWN end_value
    (154) step_enumeration -> loop_counter ASSIGN start_value . DOWN end_value
    (155) step_enumeration -> loop_counter ASSIGN start_value . step_value end_value
    (156) step_enumeration -> loop_counter ASSIGN start_value . end_value
    (159) step_value -> . BY ICONST
    (160) end_value -> . TO discrete_expression

    DOWN            shift and go to state 294
    BY              shift and go to state 293
    TO              shift and go to state 295

    end_value                      shift and go to state 291
    step_value                     shift and go to state 292

state 263

    (161) discrete_expression -> expression .

    DOWN            reduce using rule 161 (discrete_expression -> expression .)
    BY              reduce using rule 161 (discrete_expression -> expression .)
    TO              reduce using rule 161 (discrete_expression -> expression .)
    WHILE           reduce using rule 161 (discrete_expression -> expression .)
    SEMI            reduce using rule 161 (discrete_expression -> expression .)


state 264

    (170) parameter_list -> parameter_list COMMA expression .

    RPAREN          reduce using rule 170 (parameter_list -> parameter_list COMMA expression .)
    COMMA           reduce using rule 170 (parameter_list -> parameter_list COMMA expression .)


state 265

    (43) literal_range -> ICONST . COLON ICONST

    COLON           shift and go to state 296


state 266

    (39) discrete_range_mode -> discrete_mode_name LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 297


state 267

    (40) discrete_range_mode -> discrete_mode LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 298


state 268

    (53) index_mode -> discrete_mode .
    (40) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    RBRACKET        reduce using rule 53 (index_mode -> discrete_mode .)
    COMMA           reduce using rule 53 (index_mode -> discrete_mode .)
    LPAREN          shift and go to state 225


state 269

    (49) array_mode -> ARRAY LBRACKET index_mode . RBRACKET element_mode
    (50) array_mode -> ARRAY LBRACKET index_mode . COMMA index_mode_list RBRACKET element_mode

    RBRACKET        shift and go to state 299
    COMMA           shift and go to state 300


state 270

    (54) index_mode -> literal_range .

    RBRACKET        reduce using rule 54 (index_mode -> literal_range .)
    COMMA           reduce using rule 54 (index_mode -> literal_range .)


state 271

    (48) string_length -> ICONST .

    RBRACKET        reduce using rule 48 (string_length -> ICONST .)


state 272

    (47) string_mode -> CHARS LBRACKET string_length . RBRACKET

    RBRACKET        shift and go to state 301


state 273

    (14) initialization -> ASSIGN expression .

    SEMI            reduce using rule 14 (initialization -> ASSIGN expression .)
    COMMA           reduce using rule 14 (initialization -> ASSIGN expression .)


state 274

    (68) array_slice -> location LBRACKET ICONST COLON ICONST . RBRACKET

    RBRACKET        shift and go to state 302


state 275

    (67) expression_list -> expression_list COMMA expression .

    RBRACKET        reduce using rule 67 (expression_list -> expression_list COMMA expression .)
    COMMA           reduce using rule 67 (expression_list -> expression_list COMMA expression .)


state 276

    (142) else_clause -> ELSE action_statement_list .
    (121) action_statement_list -> action_statement_list . action_statement
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    FI              reduce using rule 142 (else_clause -> ELSE action_statement_list .)
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 134
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 73

state 277

    (138) if_action -> IF boolean_expression then_clause else_clause FI .

    SEMI            reduce using rule 138 (if_action -> IF boolean_expression then_clause else_clause FI .)


state 278

    (21) synonym_definition -> identifier_list mode ASSIGN constant_expression .

    SEMI            reduce using rule 21 (synonym_definition -> identifier_list mode ASSIGN constant_expression .)
    COMMA           reduce using rule 21 (synonym_definition -> identifier_list mode ASSIGN constant_expression .)


state 279

    (64) string_slice -> identifier LBRACKET ICONST COLON ICONST . RBRACKET

    RBRACKET        shift and go to state 303


state 280

    (186) procedure_definition -> PROC LPAREN formal_parameter_list . RPAREN result_spec SEMI statement_list END
    (187) procedure_definition -> PROC LPAREN formal_parameter_list . RPAREN SEMI statement_list END
    (190) formal_parameter_list -> formal_parameter_list . COMMA formal_parameter

    RPAREN          shift and go to state 304
    COMMA           shift and go to state 305


state 281

    (188) procedure_definition -> PROC LPAREN RPAREN . SEMI statement_list END

    SEMI            shift and go to state 306


state 282

    (189) formal_parameter_list -> formal_parameter .

    RPAREN          reduce using rule 189 (formal_parameter_list -> formal_parameter .)
    COMMA           reduce using rule 189 (formal_parameter_list -> formal_parameter .)


state 283

    (191) formal_parameter -> identifier_list . parameter_spec
    (16) identifier_list -> identifier_list . COMMA identifier
    (193) parameter_spec -> . mode LOC
    (194) parameter_spec -> . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    COMMA           shift and go to state 157
    REF             shift and go to state 153
    ID              shift and go to state 31
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    CHARS           shift and go to state 161
    ARRAY           shift and go to state 158

    string_mode                    shift and go to state 155
    identifier                     shift and go to state 167
    array_mode                     shift and go to state 154
    discrete_range_mode            shift and go to state 160
    discrete_mode_name             shift and go to state 151
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    reference_mode                 shift and go to state 150
    composite_mode                 shift and go to state 164
    integer_mode                   shift and go to state 159
    mode                           shift and go to state 308
    parameter_spec                 shift and go to state 307
    discrete_mode                  shift and go to state 152
    mode_name                      shift and go to state 156

state 284

    (89) else_expression -> ELSE expression .

    FI              reduce using rule 89 (else_expression -> ELSE expression .)


state 285

    (91) elsif_expression -> elsif_expression ELSIF . boolean_expression then_expression
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    boolean_expression             shift and go to state 309
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 93
    primitive_value                shift and go to state 66

state 286

    (86) conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression . FI

    FI              shift and go to state 310


state 287

    (90) elsif_expression -> ELSIF boolean_expression . then_expression
    (88) then_expression -> . THEN expression

    THEN            shift and go to state 212

    then_expression                shift and go to state 311

state 288

    (85) conditional_expression -> IF boolean_expression then_expression else_expression FI .

    SEMI            reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    THEN            reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    RPAREN          reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    COMMA           reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    RBRACKET        reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    FI              reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    ELSE            reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    ELSIF           reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    WHILE           reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    DOWN            reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    BY              reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    TO              reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    COLON           reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)


state 289

    (80) value_array_slice -> array_primitive_value LBRACKET expression COLON expression . RBRACKET

    RBRACKET        shift and go to state 312


state 290

    (162) range_enumeration -> loop_counter DOWN IN discrete_mode_name .

    WHILE           reduce using rule 162 (range_enumeration -> loop_counter DOWN IN discrete_mode_name .)
    SEMI            reduce using rule 162 (range_enumeration -> loop_counter DOWN IN discrete_mode_name .)


state 291

    (156) step_enumeration -> loop_counter ASSIGN start_value end_value .

    WHILE           reduce using rule 156 (step_enumeration -> loop_counter ASSIGN start_value end_value .)
    SEMI            reduce using rule 156 (step_enumeration -> loop_counter ASSIGN start_value end_value .)


state 292

    (153) step_enumeration -> loop_counter ASSIGN start_value step_value . DOWN end_value
    (155) step_enumeration -> loop_counter ASSIGN start_value step_value . end_value
    (160) end_value -> . TO discrete_expression

    DOWN            shift and go to state 314
    TO              shift and go to state 295

    end_value                      shift and go to state 313

state 293

    (159) step_value -> BY . ICONST

    ICONST          shift and go to state 315


state 294

    (154) step_enumeration -> loop_counter ASSIGN start_value DOWN . end_value
    (160) end_value -> . TO discrete_expression

    TO              shift and go to state 295

    end_value                      shift and go to state 316

state 295

    (160) end_value -> TO . discrete_expression
    (161) discrete_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . location
    (112) operand -> . primitive_value
    (113) operand -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    IF              shift and go to state 59
    MINUS           shift and go to state 49
    NOT             shift and go to state 63
    ID              shift and go to state 31
    ICONST          shift and go to state 57
    FALSE           shift and go to state 58
    TRUE            shift and go to state 48
    CCONST          shift and go to state 55
    NULL            shift and go to state 47
    SCONST          shift and go to state 51
    LPAREN          shift and go to state 44
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    discrete_expression            shift and go to state 317
    procedure_call                 shift and go to state 12
    array_element                  shift and go to state 6
    operand                        shift and go to state 46
    value_array_element            shift and go to state 54
    string_element                 shift and go to state 15
    literal                        shift and go to state 50
    location                       shift and go to state 52
    call_action                    shift and go to state 53
    builtin_call                   shift and go to state 24
    binop                          shift and go to state 56
    conditional_expression         shift and go to state 62
    array_primitive_value          shift and go to state 60
    parenthesized_expression       shift and go to state 45
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 61
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 64
    expression                     shift and go to state 263
    primitive_value                shift and go to state 66

state 296

    (43) literal_range -> ICONST COLON . ICONST

    ICONST          shift and go to state 318


state 297

    (39) discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    DCL             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SYN             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    TYPE            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    ID              reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    IF              reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    DO              reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    EXIT            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RETURN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RESULT          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    NUM             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    PRED            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SUCC            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    UPPER           reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    LOWER           reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    LENGTH          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    READ            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    PRINT           reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    $end            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    END             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    LOC             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RPAREN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)


state 298

    (40) discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    DCL             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SYN             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    TYPE            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    ID              reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    IF              reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    DO              reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    EXIT            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RETURN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RESULT          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    NUM             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    PRED            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SUCC            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    UPPER           reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    LOWER           reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    LENGTH          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    READ            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    PRINT           reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    $end            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    END             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    LOC             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RPAREN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)


state 299

    (49) array_mode -> ARRAY LBRACKET index_mode RBRACKET . element_mode
    (55) element_mode -> . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    REF             shift and go to state 153
    ID              shift and go to state 31
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    CHARS           shift and go to state 161
    ARRAY           shift and go to state 158

    string_mode                    shift and go to state 155
    array_mode                     shift and go to state 154
    reference_mode                 shift and go to state 150
    discrete_range_mode            shift and go to state 160
    discrete_mode_name             shift and go to state 151
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    discrete_mode                  shift and go to state 152
    composite_mode                 shift and go to state 164
    integer_mode                   shift and go to state 159
    mode                           shift and go to state 320
    element_mode                   shift and go to state 319
    identifier                     shift and go to state 167
    mode_name                      shift and go to state 156

state 300

    (50) array_mode -> ARRAY LBRACKET index_mode COMMA . index_mode_list RBRACKET element_mode
    (51) index_mode_list -> . index_mode
    (52) index_mode_list -> . index_mode_list COMMA index_mode
    (53) index_mode -> . discrete_mode
    (54) index_mode -> . literal_range
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (43) literal_range -> . ICONST COLON ICONST
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ICONST          shift and go to state 265
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    ID              shift and go to state 31

    discrete_range_mode            shift and go to state 160
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    discrete_mode                  shift and go to state 268
    discrete_mode_name             shift and go to state 151
    integer_mode                   shift and go to state 159
    index_mode                     shift and go to state 321
    identifier                     shift and go to state 260
    literal_range                  shift and go to state 270
    index_mode_list                shift and go to state 322

state 301

    (47) string_mode -> CHARS LBRACKET string_length RBRACKET .

    ASSIGN          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    SEMI            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    COMMA           reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    DCL             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    SYN             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    TYPE            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    ID              reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    IF              reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    DO              reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    EXIT            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    RETURN          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    RESULT          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    NUM             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    PRED            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    SUCC            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    UPPER           reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    LOWER           reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    LENGTH          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    READ            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    PRINT           reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    $end            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    END             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    LOC             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    RPAREN          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)


state 302

    (68) array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .

    ARROW           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    LBRACKET        reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    AND             reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    OR              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    EQ              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    NEQ             reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    GT              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    GE              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    LT              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    LE              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    PLUS            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    MINUS           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    TIMES           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    DIVIDE          reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    MOD             reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    NOT             reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    IN              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    CONCAT          reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    DOWN            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    BY              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    TO              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    ASSIGN          reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    SEMI            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    THEN            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    RPAREN          reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    COMMA           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    RBRACKET        reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    COLON           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    ELSE            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    ELSIF           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    FI              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    WHILE           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)


state 303

    (64) string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .

    ARROW           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    LBRACKET        reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    AND             reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    OR              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    EQ              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    NEQ             reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    GT              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    GE              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    LT              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    LE              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    PLUS            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    MINUS           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    TIMES           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    DIVIDE          reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    MOD             reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    NOT             reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    IN              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    CONCAT          reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    SEMI            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    THEN            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    RPAREN          reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    COMMA           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    RBRACKET        reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    COLON           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    ELSE            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    ELSIF           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    DOWN            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    BY              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    TO              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    FI              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    WHILE           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    ASSIGN          reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)


state 304

    (186) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN . result_spec SEMI statement_list END
    (187) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN . SEMI statement_list END
    (192) result_spec -> . RETURNS LPAREN parameter_spec RPAREN

    SEMI            shift and go to state 323
    RETURNS         shift and go to state 324

    result_spec                    shift and go to state 325

state 305

    (190) formal_parameter_list -> formal_parameter_list COMMA . formal_parameter
    (191) formal_parameter -> . identifier_list parameter_spec
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier_list                shift and go to state 283
    identifier                     shift and go to state 76
    formal_parameter               shift and go to state 326

state 306

    (188) procedure_definition -> PROC LPAREN RPAREN SEMI . statement_list END
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (185) procedure_statement -> . identifier COLON procedure_definition SEMI
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 22
    statement_list                 shift and go to state 327
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 307

    (191) formal_parameter -> identifier_list parameter_spec .

    RPAREN          reduce using rule 191 (formal_parameter -> identifier_list parameter_spec .)
    COMMA           reduce using rule 191 (formal_parameter -> identifier_list parameter_spec .)


state 308

    (193) parameter_spec -> mode . LOC
    (194) parameter_spec -> mode .

    LOC             shift and go to state 328
    RPAREN          reduce using rule 194 (parameter_spec -> mode .)
    COMMA           reduce using rule 194 (parameter_spec -> mode .)


state 309

    (91) elsif_expression -> elsif_expression ELSIF boolean_expression . then_expression
    (88) then_expression -> . THEN expression

    THEN            shift and go to state 212

    then_expression                shift and go to state 329

state 310

    (86) conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .

    SEMI            reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    THEN            reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    RPAREN          reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    COMMA           reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    RBRACKET        reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    FI              reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    ELSE            reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    ELSIF           reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    WHILE           reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    DOWN            reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    BY              reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    TO              reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    COLON           reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)


state 311

    (90) elsif_expression -> ELSIF boolean_expression then_expression .

    ELSIF           reduce using rule 90 (elsif_expression -> ELSIF boolean_expression then_expression .)
    ELSE            reduce using rule 90 (elsif_expression -> ELSIF boolean_expression then_expression .)


state 312

    (80) value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .

    AND             reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    OR              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    EQ              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    NEQ             reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    GT              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    GE              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    LT              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    LE              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    PLUS            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    MINUS           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    TIMES           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    DIVIDE          reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    MOD             reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    NOT             reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    IN              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    CONCAT          reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    SEMI            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    THEN            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    RPAREN          reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    COMMA           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    RBRACKET        reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    COLON           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    ELSE            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    ELSIF           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    DOWN            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    BY              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    TO              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    FI              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    WHILE           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    LBRACKET        reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)


state 313

    (155) step_enumeration -> loop_counter ASSIGN start_value step_value end_value .

    WHILE           reduce using rule 155 (step_enumeration -> loop_counter ASSIGN start_value step_value end_value .)
    SEMI            reduce using rule 155 (step_enumeration -> loop_counter ASSIGN start_value step_value end_value .)


state 314

    (153) step_enumeration -> loop_counter ASSIGN start_value step_value DOWN . end_value
    (160) end_value -> . TO discrete_expression

    TO              shift and go to state 295

    end_value                      shift and go to state 330

state 315

    (159) step_value -> BY ICONST .

    DOWN            reduce using rule 159 (step_value -> BY ICONST .)
    TO              reduce using rule 159 (step_value -> BY ICONST .)


state 316

    (154) step_enumeration -> loop_counter ASSIGN start_value DOWN end_value .

    WHILE           reduce using rule 154 (step_enumeration -> loop_counter ASSIGN start_value DOWN end_value .)
    SEMI            reduce using rule 154 (step_enumeration -> loop_counter ASSIGN start_value DOWN end_value .)


state 317

    (160) end_value -> TO discrete_expression .

    WHILE           reduce using rule 160 (end_value -> TO discrete_expression .)
    SEMI            reduce using rule 160 (end_value -> TO discrete_expression .)


state 318

    (43) literal_range -> ICONST COLON ICONST .

    RPAREN          reduce using rule 43 (literal_range -> ICONST COLON ICONST .)
    RBRACKET        reduce using rule 43 (literal_range -> ICONST COLON ICONST .)
    COMMA           reduce using rule 43 (literal_range -> ICONST COLON ICONST .)


state 319

    (49) array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .

    ASSIGN          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    SEMI            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    COMMA           reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    DCL             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    SYN             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    TYPE            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    ID              reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    IF              reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    DO              reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    EXIT            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    RETURN          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    RESULT          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    NUM             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    PRED            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    SUCC            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    UPPER           reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    LOWER           reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    LENGTH          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    READ            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    PRINT           reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    $end            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    END             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    LOC             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    RPAREN          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)


state 320

    (55) element_mode -> mode .

    ASSIGN          reduce using rule 55 (element_mode -> mode .)
    SEMI            reduce using rule 55 (element_mode -> mode .)
    COMMA           reduce using rule 55 (element_mode -> mode .)
    DCL             reduce using rule 55 (element_mode -> mode .)
    SYN             reduce using rule 55 (element_mode -> mode .)
    TYPE            reduce using rule 55 (element_mode -> mode .)
    ID              reduce using rule 55 (element_mode -> mode .)
    IF              reduce using rule 55 (element_mode -> mode .)
    DO              reduce using rule 55 (element_mode -> mode .)
    EXIT            reduce using rule 55 (element_mode -> mode .)
    RETURN          reduce using rule 55 (element_mode -> mode .)
    RESULT          reduce using rule 55 (element_mode -> mode .)
    NUM             reduce using rule 55 (element_mode -> mode .)
    PRED            reduce using rule 55 (element_mode -> mode .)
    SUCC            reduce using rule 55 (element_mode -> mode .)
    UPPER           reduce using rule 55 (element_mode -> mode .)
    LOWER           reduce using rule 55 (element_mode -> mode .)
    LENGTH          reduce using rule 55 (element_mode -> mode .)
    READ            reduce using rule 55 (element_mode -> mode .)
    PRINT           reduce using rule 55 (element_mode -> mode .)
    $end            reduce using rule 55 (element_mode -> mode .)
    END             reduce using rule 55 (element_mode -> mode .)
    LOC             reduce using rule 55 (element_mode -> mode .)
    RPAREN          reduce using rule 55 (element_mode -> mode .)


state 321

    (51) index_mode_list -> index_mode .

    RBRACKET        reduce using rule 51 (index_mode_list -> index_mode .)
    COMMA           reduce using rule 51 (index_mode_list -> index_mode .)


state 322

    (50) array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list . RBRACKET element_mode
    (52) index_mode_list -> index_mode_list . COMMA index_mode

    RBRACKET        shift and go to state 332
    COMMA           shift and go to state 331


state 323

    (187) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI . statement_list END
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (185) procedure_statement -> . identifier COLON procedure_definition SEMI
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 22
    statement_list                 shift and go to state 333
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 324

    (192) result_spec -> RETURNS . LPAREN parameter_spec RPAREN

    LPAREN          shift and go to state 334


state 325

    (186) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec . SEMI statement_list END

    SEMI            shift and go to state 335


state 326

    (190) formal_parameter_list -> formal_parameter_list COMMA formal_parameter .

    RPAREN          reduce using rule 190 (formal_parameter_list -> formal_parameter_list COMMA formal_parameter .)
    COMMA           reduce using rule 190 (formal_parameter_list -> formal_parameter_list COMMA formal_parameter .)


state 327

    (188) procedure_definition -> PROC LPAREN RPAREN SEMI statement_list . END
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (185) procedure_statement -> . identifier COLON procedure_definition SEMI
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    END             shift and go to state 336
    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 90
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 328

    (193) parameter_spec -> mode LOC .

    RPAREN          reduce using rule 193 (parameter_spec -> mode LOC .)
    COMMA           reduce using rule 193 (parameter_spec -> mode LOC .)


state 329

    (91) elsif_expression -> elsif_expression ELSIF boolean_expression then_expression .

    ELSIF           reduce using rule 91 (elsif_expression -> elsif_expression ELSIF boolean_expression then_expression .)
    ELSE            reduce using rule 91 (elsif_expression -> elsif_expression ELSIF boolean_expression then_expression .)


state 330

    (153) step_enumeration -> loop_counter ASSIGN start_value step_value DOWN end_value .

    WHILE           reduce using rule 153 (step_enumeration -> loop_counter ASSIGN start_value step_value DOWN end_value .)
    SEMI            reduce using rule 153 (step_enumeration -> loop_counter ASSIGN start_value step_value DOWN end_value .)


state 331

    (52) index_mode_list -> index_mode_list COMMA . index_mode
    (53) index_mode -> . discrete_mode
    (54) index_mode -> . literal_range
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (43) literal_range -> . ICONST COLON ICONST
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ICONST          shift and go to state 265
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    ID              shift and go to state 31

    discrete_range_mode            shift and go to state 160
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    discrete_mode                  shift and go to state 268
    discrete_mode_name             shift and go to state 151
    integer_mode                   shift and go to state 159
    index_mode                     shift and go to state 337
    literal_range                  shift and go to state 270
    identifier                     shift and go to state 260

state 332

    (50) array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET . element_mode
    (55) element_mode -> . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    REF             shift and go to state 153
    ID              shift and go to state 31
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    CHARS           shift and go to state 161
    ARRAY           shift and go to state 158

    string_mode                    shift and go to state 155
    array_mode                     shift and go to state 154
    reference_mode                 shift and go to state 150
    discrete_range_mode            shift and go to state 160
    discrete_mode_name             shift and go to state 151
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    discrete_mode                  shift and go to state 152
    composite_mode                 shift and go to state 164
    integer_mode                   shift and go to state 159
    mode                           shift and go to state 320
    element_mode                   shift and go to state 338
    identifier                     shift and go to state 167
    mode_name                      shift and go to state 156

state 333

    (187) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_list . END
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (185) procedure_statement -> . identifier COLON procedure_definition SEMI
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    END             shift and go to state 339
    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 90
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 334

    (192) result_spec -> RETURNS LPAREN . parameter_spec RPAREN
    (193) parameter_spec -> . mode LOC
    (194) parameter_spec -> . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    REF             shift and go to state 153
    ID              shift and go to state 31
    INT             shift and go to state 163
    BOOL            shift and go to state 165
    CHAR            shift and go to state 149
    CHARS           shift and go to state 161
    ARRAY           shift and go to state 158

    string_mode                    shift and go to state 155
    array_mode                     shift and go to state 154
    discrete_range_mode            shift and go to state 160
    discrete_mode_name             shift and go to state 151
    boolean_mode                   shift and go to state 148
    character_mode                 shift and go to state 162
    reference_mode                 shift and go to state 150
    composite_mode                 shift and go to state 164
    integer_mode                   shift and go to state 159
    mode                           shift and go to state 308
    parameter_spec                 shift and go to state 340
    discrete_mode                  shift and go to state 152
    identifier                     shift and go to state 167
    mode_name                      shift and go to state 156

state 335

    (186) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI . statement_list END
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (185) procedure_statement -> . identifier COLON procedure_definition SEMI
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 22
    statement_list                 shift and go to state 341
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 336

    (188) procedure_definition -> PROC LPAREN RPAREN SEMI statement_list END .

    SEMI            reduce using rule 188 (procedure_definition -> PROC LPAREN RPAREN SEMI statement_list END .)


state 337

    (52) index_mode_list -> index_mode_list COMMA index_mode .

    RBRACKET        reduce using rule 52 (index_mode_list -> index_mode_list COMMA index_mode .)
    COMMA           reduce using rule 52 (index_mode_list -> index_mode_list COMMA index_mode .)


state 338

    (50) array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .

    ASSIGN          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    SEMI            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    COMMA           reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    DCL             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    SYN             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    TYPE            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    ID              reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    IF              reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    DO              reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    EXIT            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    RETURN          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    RESULT          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    NUM             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    PRED            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    SUCC            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    UPPER           reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    LOWER           reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    LENGTH          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    READ            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    PRINT           reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    $end            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    END             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    LOC             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    RPAREN          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)


state 339

    (187) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_list END .

    SEMI            reduce using rule 187 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_list END .)


state 340

    (192) result_spec -> RETURNS LPAREN parameter_spec . RPAREN

    RPAREN          shift and go to state 342


state 341

    (186) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list . END
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (185) procedure_statement -> . identifier COLON procedure_definition SEMI
    (118) action_statement -> . identifier COLON action SEMI
    (119) action_statement -> . action SEMI
    (17) identifier -> . ID
    (122) action -> . if_action
    (123) action -> . do_action
    (124) action -> . assignment_action
    (125) action -> . call_action
    (126) action -> . exit_action
    (127) action -> . return_action
    (128) action -> . result_action
    (138) if_action -> . IF boolean_expression then_clause else_clause FI
    (139) if_action -> . IF boolean_expression then_clause FI
    (144) do_action -> . DO control_part SEMI action_statement_list OD
    (145) do_action -> . DO control_part SEMI OD
    (146) do_action -> . DO action_statement_list OD
    (129) assignment_action -> . location assigning_operator expression
    (130) assignment_action -> . identifier assigning_operator expression
    (165) call_action -> . procedure_call
    (166) call_action -> . builtin_call
    (171) exit_action -> . EXIT identifier
    (172) return_action -> . RETURN expression
    (173) return_action -> . RETURN
    (174) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (167) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (168) procedure_call -> . identifier LPAREN RPAREN
    (175) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (176) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (177) builtin_name -> . NUM
    (178) builtin_name -> . PRED
    (179) builtin_name -> . SUCC
    (180) builtin_name -> . UPPER
    (181) builtin_name -> . LOWER
    (182) builtin_name -> . LENGTH
    (183) builtin_name -> . READ
    (184) builtin_name -> . PRINT

    END             shift and go to state 343
    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 90
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 342

    (192) result_spec -> RETURNS LPAREN parameter_spec RPAREN .

    SEMI            reduce using rule 192 (result_spec -> RETURNS LPAREN parameter_spec RPAREN .)


state 343

    (186) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END .

    SEMI            reduce using rule 186 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END .)

