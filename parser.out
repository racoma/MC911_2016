Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> declaration_statement
Rule 5     statement -> synonym_statement
Rule 6     statement -> newmode_statement
Rule 7     statement -> procedure_statement
Rule 8     statement -> action_statement
Rule 9     declaration_statement -> DCL declaration_list SEMI
Rule 10    declaration_list -> declaration
Rule 11    declaration_list -> declaration_list COMMA declaration
Rule 12    declaration -> identifier_list mode initialization
Rule 13    declaration -> identifier_list mode
Rule 14    initialization -> ASSIGN expression
Rule 15    identifier_list -> identifier
Rule 16    identifier_list -> identifier_list COMMA identifier
Rule 17    identifier -> ID
Rule 18    synonym_statement -> SYN synonym_list SEMI
Rule 19    synonym_list -> synonym_definition
Rule 20    synonym_list -> synonym_list COMMA synonym_definition
Rule 21    synonym_definition -> identifier_list mode ASSIGN constant_expression
Rule 22    synonym_definition -> identifier_list ASSIGN constant_expression
Rule 23    constant_expression -> expression
Rule 24    newmode_statement -> TYPE newmode_list
Rule 25    newmode_list -> mode_definition
Rule 26    newmode_list -> newmode_list COMMA mode_definition
Rule 27    mode_definition -> identifier_list mode
Rule 28    mode -> mode_name
Rule 29    mode -> discrete_mode
Rule 30    mode -> reference_mode
Rule 31    mode -> composite_mode
Rule 32    discrete_mode -> integer_mode
Rule 33    discrete_mode -> boolean_mode
Rule 34    discrete_mode -> character_mode
Rule 35    discrete_mode -> discrete_range_mode
Rule 36    integer_mode -> INT
Rule 37    boolean_mode -> BOOL
Rule 38    character_mode -> CHAR
Rule 39    discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN
Rule 40    discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN
Rule 41    mode_name -> identifier
Rule 42    discrete_mode_name -> identifier
Rule 43    literal_range -> ICONST COLON ICONST
Rule 44    reference_mode -> REF mode
Rule 45    composite_mode -> string_mode
Rule 46    composite_mode -> array_mode
Rule 47    string_mode -> CHARS LBRACKET string_length RBRACKET
Rule 48    string_length -> ICONST
Rule 49    array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode
Rule 50    array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
Rule 51    index_mode_list -> index_mode
Rule 52    index_mode_list -> index_mode_list COMMA index_mode
Rule 53    index_mode -> discrete_mode
Rule 54    index_mode -> literal_range
Rule 55    element_mode -> mode
Rule 56    location -> dereferenced_reference
Rule 57    location -> string_element
Rule 58    location -> string_slice
Rule 59    location -> array_element
Rule 60    location -> array_slice
Rule 61    location -> call_action
Rule 62    dereferenced_reference -> location ARROW
Rule 63    string_element -> identifier LBRACKET ICONST RBRACKET
Rule 64    string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET
Rule 65    array_element -> location LBRACKET expression_list RBRACKET
Rule 66    expression_list -> expression
Rule 67    expression_list -> expression_list COMMA expression
Rule 68    array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET
Rule 69    primitive_value -> literal
Rule 70    primitive_value -> value_array_element
Rule 71    primitive_value -> value_array_slice
Rule 72    primitive_value -> parenthesized_expression
Rule 73    literal -> ICONST
Rule 74    literal -> FALSE
Rule 75    literal -> TRUE
Rule 76    literal -> CCONST
Rule 77    literal -> NULL
Rule 78    literal -> SCONST
Rule 79    value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET
Rule 80    value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET
Rule 81    array_primitive_value -> primitive_value
Rule 82    parenthesized_expression -> LPAREN expression RPAREN
Rule 83    expression -> binop
Rule 84    expression -> conditional_expression
Rule 85    conditional_expression -> IF boolean_expression then_expression else_expression FI
Rule 86    conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI
Rule 87    boolean_expression -> expression
Rule 88    then_expression -> THEN expression
Rule 89    else_expression -> ELSE expression
Rule 90    elsif_expression -> ELSIF boolean_expression then_expression
Rule 91    elsif_expression -> elsif_expression ELSIF boolean_expression then_expression
Rule 92    binop -> operand
Rule 93    binop -> binop AND binop
Rule 94    binop -> binop OR binop
Rule 95    binop -> binop EQ binop
Rule 96    binop -> binop NEQ binop
Rule 97    binop -> binop GT binop
Rule 98    binop -> binop GE binop
Rule 99    binop -> binop LT binop
Rule 100   binop -> binop LE binop
Rule 101   binop -> binop PLUS binop
Rule 102   binop -> binop MINUS binop
Rule 103   binop -> binop TIMES binop
Rule 104   binop -> binop DIVIDE binop
Rule 105   binop -> binop MOD binop
Rule 106   binop -> binop NOT binop
Rule 107   binop -> binop IN binop
Rule 108   binop -> binop CONCAT binop
Rule 109   operand -> MINUS operand1
Rule 110   operand -> NOT operand1
Rule 111   operand -> primitive_value
Rule 112   operand -> identifier
Rule 113   operand1 -> location
Rule 114   operand1 -> referenced_location
Rule 115   operand1 -> primitive_value
Rule 116   referenced_location -> ARROW location
Rule 117   action_statement -> identifier COLON action SEMI
Rule 118   action_statement -> action SEMI
Rule 119   action -> if_action
Rule 120   action -> do_action
Rule 121   action -> assignment_action
Rule 122   action -> call_action
Rule 123   action -> exit_action
Rule 124   action -> return_action
Rule 125   action -> result_action
Rule 126   assignment_action -> location assigning_operator expression
Rule 127   assignment_action -> identifier assigning_operator expression
Rule 128   assigning_operator -> PLUS ASSIGN
Rule 129   assigning_operator -> MINUS ASSIGN
Rule 130   assigning_operator -> TIMES ASSIGN
Rule 131   assigning_operator -> DIVIDE ASSIGN
Rule 132   assigning_operator -> MOD ASSIGN
Rule 133   assigning_operator -> CONCAT ASSIGN
Rule 134   assigning_operator -> ASSIGN
Rule 135   if_action -> IF boolean_expression then_clause else_clause FI
Rule 136   if_action -> IF boolean_expression then_clause FI
Rule 137   then_clause -> THEN action_statement
Rule 138   then_clause -> THEN
Rule 139   else_clause -> ELSE action_statement
Rule 140   else_clause -> ELSE
Rule 141   else_clause -> ELSIF boolean_expression then_clause else_clause
Rule 142   else_clause -> ELSIF boolean_expression then_clause
Rule 143   do_action -> DO control_part SEMI action_statement OD
Rule 144   do_action -> DO control_part SEMI OD
Rule 145   do_action -> DO action_statement OD
Rule 146   control_part -> for_control while_control
Rule 147   control_part -> while_control
Rule 148   for_control -> FOR iteration
Rule 149   iteration -> step_enumeration
Rule 150   iteration -> range_enumeration
Rule 151   step_enumeration -> loop_counter ASSIGN start_value step_value DOWN end_value
Rule 152   step_enumeration -> loop_counter ASSIGN start_value DOWN end_value
Rule 153   step_enumeration -> loop_counter ASSIGN start_value step_value end_value
Rule 154   step_enumeration -> loop_counter ASSIGN start_value end_value
Rule 155   loop_counter -> identifier
Rule 156   start_value -> discrete_expression
Rule 157   step_value -> BY ICONST
Rule 158   end_value -> TO discrete_expression
Rule 159   discrete_expression -> expression
Rule 160   range_enumeration -> loop_counter DOWN IN discrete_mode_name
Rule 161   range_enumeration -> loop_counter IN discrete_mode_name
Rule 162   while_control -> WHILE boolean_expression
Rule 163   call_action -> procedure_call
Rule 164   call_action -> builtin_call
Rule 165   procedure_call -> identifier LPAREN parameter_list RPAREN
Rule 166   procedure_call -> identifier LPAREN RPAREN
Rule 167   parameter_list -> expression
Rule 168   parameter_list -> parameter_list COMMA expression
Rule 169   exit_action -> EXIT identifier
Rule 170   return_action -> RETURN expression
Rule 171   return_action -> RETURN
Rule 172   result_action -> RESULT expression
Rule 173   builtin_call -> builtin_name LPAREN parameter_list RPAREN
Rule 174   builtin_call -> builtin_name LPAREN RPAREN
Rule 175   builtin_name -> NUM
Rule 176   builtin_name -> PRED
Rule 177   builtin_name -> SUCC
Rule 178   builtin_name -> UPPER
Rule 179   builtin_name -> LOWER
Rule 180   builtin_name -> LENGTH
Rule 181   builtin_name -> READ
Rule 182   builtin_name -> PRINT
Rule 183   procedure_statement -> identifier COLON procedure_definition SEMI
Rule 184   procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END
Rule 185   procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_list END
Rule 186   procedure_definition -> PROC LPAREN RPAREN SEMI statement_list END
Rule 187   formal_parameter_list -> formal_parameter
Rule 188   formal_parameter_list -> formal_parameter_list COMMA formal_parameter
Rule 189   formal_parameter -> identifier_list parameter_spec
Rule 190   result_spec -> RETURNS LPAREN parameter_spec RPAREN
Rule 191   parameter_spec -> mode LOC
Rule 192   parameter_spec -> mode

Terminals, with rules where they appear

AND                  : 93
ARRAY                : 49 50
ARROW                : 62 116
ASSIGN               : 14 21 22 128 129 130 131 132 133 134 151 152 153 154
BOOL                 : 37
BY                   : 157
CCONST               : 76
CHAR                 : 38
CHARS                : 47
COLON                : 43 64 68 80 117 183
COMMA                : 11 16 20 26 50 52 67 168 188
CONCAT               : 108 133
DCL                  : 9
DIVIDE               : 104 131
DO                   : 143 144 145
DOWN                 : 151 152 160
ELSE                 : 89 139 140
ELSIF                : 90 91 141 142
END                  : 184 185 186
EQ                   : 95
EXIT                 : 169
FALSE                : 74
FI                   : 85 86 135 136
FOR                  : 148
GE                   : 98
GT                   : 97
ICONST               : 43 43 48 63 64 64 68 68 73 157
ID                   : 17
IF                   : 85 86 135 136
IN                   : 107 160 161
INT                  : 36
LBRACKET             : 47 49 50 63 64 65 68 79 80
LE                   : 100
LENGTH               : 180
LOC                  : 191
LOWER                : 179
LPAREN               : 39 40 82 165 166 173 174 184 185 186 190
LT                   : 99
MINUS                : 102 109 129
MOD                  : 105 132
NEQ                  : 96
NOT                  : 106 110
NULL                 : 77
NUM                  : 175
OD                   : 143 144 145
OR                   : 94
PLUS                 : 101 128
PRED                 : 176
PRINT                : 182
PROC                 : 184 185 186
RBRACKET             : 47 49 50 63 64 65 68 79 80
READ                 : 181
REF                  : 44
RESULT               : 172
RETURN               : 170 171
RETURNS              : 190
RPAREN               : 39 40 82 165 166 173 174 184 185 186 190
SCONST               : 78
SEMI                 : 9 18 117 118 143 144 183 184 185 186
SUCC                 : 177
SYN                  : 18
THEN                 : 88 137 138
TIMES                : 103 130
TO                   : 158
TRUE                 : 75
TYPE                 : 24
UPPER                : 178
WHILE                : 162
error                : 

Nonterminals, with rules where they appear

action               : 117 118
action_statement     : 8 137 139 143 145
array_element        : 59
array_mode           : 46
array_primitive_value : 79 80
array_slice          : 60
assigning_operator   : 126 127
assignment_action    : 121
binop                : 83 93 93 94 94 95 95 96 96 97 97 98 98 99 99 100 100 101 101 102 102 103 103 104 104 105 105 106 106 107 107 108 108
boolean_expression   : 85 86 90 91 135 136 141 142 162
boolean_mode         : 33
builtin_call         : 164
builtin_name         : 173 174
call_action          : 61 122
character_mode       : 34
composite_mode       : 31
conditional_expression : 84
constant_expression  : 21 22
control_part         : 143 144
declaration          : 10 11
declaration_list     : 9 11
declaration_statement : 4
dereferenced_reference : 56
discrete_expression  : 156 158
discrete_mode        : 29 40 53
discrete_mode_name   : 39 160 161
discrete_range_mode  : 35
do_action            : 120
element_mode         : 49 50
else_clause          : 135 141
else_expression      : 85 86
elsif_expression     : 86 91
end_value            : 151 152 153 154
exit_action          : 123
expression           : 14 23 66 67 80 80 82 87 88 89 126 127 159 167 168 170 172
expression_list      : 65 67 79
for_control          : 146
formal_parameter     : 187 188
formal_parameter_list : 184 185 188
identifier           : 15 16 41 42 63 64 112 117 127 155 165 166 169 183
identifier_list      : 12 13 16 21 22 27 189
if_action            : 119
index_mode           : 49 50 51 52
index_mode_list      : 50 52
initialization       : 12
integer_mode         : 32
iteration            : 148
literal              : 69
literal_range        : 39 40 54
location             : 62 65 68 113 116 126
loop_counter         : 151 152 153 154 160 161
mode                 : 12 13 21 27 44 55 191 192
mode_definition      : 25 26
mode_name            : 28
newmode_list         : 24 26
newmode_statement    : 6
operand              : 92
operand1             : 109 110
parameter_list       : 165 168 173
parameter_spec       : 189 190
parenthesized_expression : 72
primitive_value      : 81 111 115
procedure_call       : 163
procedure_definition : 183
procedure_statement  : 7
program              : 0
range_enumeration    : 150
reference_mode       : 30
referenced_location  : 114
result_action        : 125
result_spec          : 184
return_action        : 124
start_value          : 151 152 153 154
statement            : 2 3
statement_list       : 1 3 184 185 186
step_enumeration     : 149
step_value           : 151 153
string_element       : 57
string_length        : 47
string_mode          : 45
string_slice         : 58
synonym_definition   : 19 20
synonym_list         : 18 20
synonym_statement    : 5
then_clause          : 135 136 141 142
then_expression      : 85 86 90 91
value_array_element  : 70
value_array_slice    : 71
while_control        : 146 147

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (183) procedure_statement -> . identifier COLON procedure_definition SEMI
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    program                        shift and go to state 20
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 22
    statement_list                 shift and go to state 26
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 1

    (121) action -> assignment_action .

    SEMI            reduce using rule 121 (action -> assignment_action .)


state 2

    (179) builtin_name -> LOWER .

    LPAREN          reduce using rule 179 (builtin_name -> LOWER .)


state 3

    (170) return_action -> RETURN . expression
    (171) return_action -> RETURN .
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    SEMI            reduce using rule 171 (return_action -> RETURN .)
    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 63
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 4

    (143) do_action -> DO . control_part SEMI action_statement OD
    (144) do_action -> DO . control_part SEMI OD
    (145) do_action -> DO . action_statement OD
    (146) control_part -> . for_control while_control
    (147) control_part -> . while_control
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (148) for_control -> . FOR iteration
    (162) while_control -> . WHILE boolean_expression
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    FOR             shift and go to state 68
    WHILE           shift and go to state 65
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    control_part                   shift and go to state 66
    for_control                    shift and go to state 67
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    while_control                  shift and go to state 69
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 70
    action_statement               shift and go to state 71

state 5

    (5) statement -> synonym_statement .

    DCL             reduce using rule 5 (statement -> synonym_statement .)
    SYN             reduce using rule 5 (statement -> synonym_statement .)
    TYPE            reduce using rule 5 (statement -> synonym_statement .)
    ID              reduce using rule 5 (statement -> synonym_statement .)
    IF              reduce using rule 5 (statement -> synonym_statement .)
    DO              reduce using rule 5 (statement -> synonym_statement .)
    EXIT            reduce using rule 5 (statement -> synonym_statement .)
    RETURN          reduce using rule 5 (statement -> synonym_statement .)
    RESULT          reduce using rule 5 (statement -> synonym_statement .)
    NUM             reduce using rule 5 (statement -> synonym_statement .)
    PRED            reduce using rule 5 (statement -> synonym_statement .)
    SUCC            reduce using rule 5 (statement -> synonym_statement .)
    UPPER           reduce using rule 5 (statement -> synonym_statement .)
    LOWER           reduce using rule 5 (statement -> synonym_statement .)
    LENGTH          reduce using rule 5 (statement -> synonym_statement .)
    READ            reduce using rule 5 (statement -> synonym_statement .)
    PRINT           reduce using rule 5 (statement -> synonym_statement .)
    $end            reduce using rule 5 (statement -> synonym_statement .)
    END             reduce using rule 5 (statement -> synonym_statement .)


state 6

    (59) location -> array_element .

    ARROW           reduce using rule 59 (location -> array_element .)
    LBRACKET        reduce using rule 59 (location -> array_element .)
    PLUS            reduce using rule 59 (location -> array_element .)
    MINUS           reduce using rule 59 (location -> array_element .)
    TIMES           reduce using rule 59 (location -> array_element .)
    DIVIDE          reduce using rule 59 (location -> array_element .)
    MOD             reduce using rule 59 (location -> array_element .)
    CONCAT          reduce using rule 59 (location -> array_element .)
    ASSIGN          reduce using rule 59 (location -> array_element .)
    AND             reduce using rule 59 (location -> array_element .)
    OR              reduce using rule 59 (location -> array_element .)
    EQ              reduce using rule 59 (location -> array_element .)
    NEQ             reduce using rule 59 (location -> array_element .)
    GT              reduce using rule 59 (location -> array_element .)
    GE              reduce using rule 59 (location -> array_element .)
    LT              reduce using rule 59 (location -> array_element .)
    LE              reduce using rule 59 (location -> array_element .)
    NOT             reduce using rule 59 (location -> array_element .)
    IN              reduce using rule 59 (location -> array_element .)
    SEMI            reduce using rule 59 (location -> array_element .)
    THEN            reduce using rule 59 (location -> array_element .)
    RPAREN          reduce using rule 59 (location -> array_element .)
    COMMA           reduce using rule 59 (location -> array_element .)
    RBRACKET        reduce using rule 59 (location -> array_element .)
    COLON           reduce using rule 59 (location -> array_element .)
    ELSE            reduce using rule 59 (location -> array_element .)
    ELSIF           reduce using rule 59 (location -> array_element .)
    DOWN            reduce using rule 59 (location -> array_element .)
    BY              reduce using rule 59 (location -> array_element .)
    TO              reduce using rule 59 (location -> array_element .)
    FI              reduce using rule 59 (location -> array_element .)
    WHILE           reduce using rule 59 (location -> array_element .)


state 7

    (125) action -> result_action .

    SEMI            reduce using rule 125 (action -> result_action .)


state 8

    (173) builtin_call -> builtin_name . LPAREN parameter_list RPAREN
    (174) builtin_call -> builtin_name . LPAREN RPAREN

    LPAREN          shift and go to state 72


state 9

    (182) builtin_name -> PRINT .

    LPAREN          reduce using rule 182 (builtin_name -> PRINT .)


state 10

    (177) builtin_name -> SUCC .

    LPAREN          reduce using rule 177 (builtin_name -> SUCC .)


state 11

    (124) action -> return_action .

    SEMI            reduce using rule 124 (action -> return_action .)


state 12

    (163) call_action -> procedure_call .

    SEMI            reduce using rule 163 (call_action -> procedure_call .)
    ARROW           reduce using rule 163 (call_action -> procedure_call .)
    LBRACKET        reduce using rule 163 (call_action -> procedure_call .)
    PLUS            reduce using rule 163 (call_action -> procedure_call .)
    MINUS           reduce using rule 163 (call_action -> procedure_call .)
    TIMES           reduce using rule 163 (call_action -> procedure_call .)
    DIVIDE          reduce using rule 163 (call_action -> procedure_call .)
    MOD             reduce using rule 163 (call_action -> procedure_call .)
    CONCAT          reduce using rule 163 (call_action -> procedure_call .)
    ASSIGN          reduce using rule 163 (call_action -> procedure_call .)
    AND             reduce using rule 163 (call_action -> procedure_call .)
    OR              reduce using rule 163 (call_action -> procedure_call .)
    EQ              reduce using rule 163 (call_action -> procedure_call .)
    NEQ             reduce using rule 163 (call_action -> procedure_call .)
    GT              reduce using rule 163 (call_action -> procedure_call .)
    GE              reduce using rule 163 (call_action -> procedure_call .)
    LT              reduce using rule 163 (call_action -> procedure_call .)
    LE              reduce using rule 163 (call_action -> procedure_call .)
    NOT             reduce using rule 163 (call_action -> procedure_call .)
    IN              reduce using rule 163 (call_action -> procedure_call .)
    THEN            reduce using rule 163 (call_action -> procedure_call .)
    RPAREN          reduce using rule 163 (call_action -> procedure_call .)
    COMMA           reduce using rule 163 (call_action -> procedure_call .)
    RBRACKET        reduce using rule 163 (call_action -> procedure_call .)
    COLON           reduce using rule 163 (call_action -> procedure_call .)
    ELSE            reduce using rule 163 (call_action -> procedure_call .)
    ELSIF           reduce using rule 163 (call_action -> procedure_call .)
    DOWN            reduce using rule 163 (call_action -> procedure_call .)
    BY              reduce using rule 163 (call_action -> procedure_call .)
    TO              reduce using rule 163 (call_action -> procedure_call .)
    FI              reduce using rule 163 (call_action -> procedure_call .)
    WHILE           reduce using rule 163 (call_action -> procedure_call .)


state 13

    (120) action -> do_action .

    SEMI            reduce using rule 120 (action -> do_action .)


state 14

    (119) action -> if_action .

    SEMI            reduce using rule 119 (action -> if_action .)


state 15

    (57) location -> string_element .

    ARROW           reduce using rule 57 (location -> string_element .)
    LBRACKET        reduce using rule 57 (location -> string_element .)
    PLUS            reduce using rule 57 (location -> string_element .)
    MINUS           reduce using rule 57 (location -> string_element .)
    TIMES           reduce using rule 57 (location -> string_element .)
    DIVIDE          reduce using rule 57 (location -> string_element .)
    MOD             reduce using rule 57 (location -> string_element .)
    CONCAT          reduce using rule 57 (location -> string_element .)
    ASSIGN          reduce using rule 57 (location -> string_element .)
    AND             reduce using rule 57 (location -> string_element .)
    OR              reduce using rule 57 (location -> string_element .)
    EQ              reduce using rule 57 (location -> string_element .)
    NEQ             reduce using rule 57 (location -> string_element .)
    GT              reduce using rule 57 (location -> string_element .)
    GE              reduce using rule 57 (location -> string_element .)
    LT              reduce using rule 57 (location -> string_element .)
    LE              reduce using rule 57 (location -> string_element .)
    NOT             reduce using rule 57 (location -> string_element .)
    IN              reduce using rule 57 (location -> string_element .)
    SEMI            reduce using rule 57 (location -> string_element .)
    THEN            reduce using rule 57 (location -> string_element .)
    RPAREN          reduce using rule 57 (location -> string_element .)
    COMMA           reduce using rule 57 (location -> string_element .)
    RBRACKET        reduce using rule 57 (location -> string_element .)
    COLON           reduce using rule 57 (location -> string_element .)
    ELSE            reduce using rule 57 (location -> string_element .)
    ELSIF           reduce using rule 57 (location -> string_element .)
    DOWN            reduce using rule 57 (location -> string_element .)
    BY              reduce using rule 57 (location -> string_element .)
    TO              reduce using rule 57 (location -> string_element .)
    FI              reduce using rule 57 (location -> string_element .)
    WHILE           reduce using rule 57 (location -> string_element .)


state 16

    (9) declaration_statement -> DCL . declaration_list SEMI
    (10) declaration_list -> . declaration
    (11) declaration_list -> . declaration_list COMMA declaration
    (12) declaration -> . identifier_list mode initialization
    (13) declaration -> . identifier_list mode
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier_list                shift and go to state 76
    declaration_list               shift and go to state 74
    declaration                    shift and go to state 75
    identifier                     shift and go to state 73

state 17

    (180) builtin_name -> LENGTH .

    LPAREN          reduce using rule 180 (builtin_name -> LENGTH .)


state 18

    (7) statement -> procedure_statement .

    DCL             reduce using rule 7 (statement -> procedure_statement .)
    SYN             reduce using rule 7 (statement -> procedure_statement .)
    TYPE            reduce using rule 7 (statement -> procedure_statement .)
    ID              reduce using rule 7 (statement -> procedure_statement .)
    IF              reduce using rule 7 (statement -> procedure_statement .)
    DO              reduce using rule 7 (statement -> procedure_statement .)
    EXIT            reduce using rule 7 (statement -> procedure_statement .)
    RETURN          reduce using rule 7 (statement -> procedure_statement .)
    RESULT          reduce using rule 7 (statement -> procedure_statement .)
    NUM             reduce using rule 7 (statement -> procedure_statement .)
    PRED            reduce using rule 7 (statement -> procedure_statement .)
    SUCC            reduce using rule 7 (statement -> procedure_statement .)
    UPPER           reduce using rule 7 (statement -> procedure_statement .)
    LOWER           reduce using rule 7 (statement -> procedure_statement .)
    LENGTH          reduce using rule 7 (statement -> procedure_statement .)
    READ            reduce using rule 7 (statement -> procedure_statement .)
    PRINT           reduce using rule 7 (statement -> procedure_statement .)
    $end            reduce using rule 7 (statement -> procedure_statement .)
    END             reduce using rule 7 (statement -> procedure_statement .)


state 19

    (181) builtin_name -> READ .

    LPAREN          reduce using rule 181 (builtin_name -> READ .)


state 20

    (0) S' -> program .



state 21

    (126) assignment_action -> location . assigning_operator expression
    (62) dereferenced_reference -> location . ARROW
    (65) array_element -> location . LBRACKET expression_list RBRACKET
    (68) array_slice -> location . LBRACKET ICONST COLON ICONST RBRACKET
    (128) assigning_operator -> . PLUS ASSIGN
    (129) assigning_operator -> . MINUS ASSIGN
    (130) assigning_operator -> . TIMES ASSIGN
    (131) assigning_operator -> . DIVIDE ASSIGN
    (132) assigning_operator -> . MOD ASSIGN
    (133) assigning_operator -> . CONCAT ASSIGN
    (134) assigning_operator -> . ASSIGN

    ARROW           shift and go to state 82
    LBRACKET        shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 79
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 78
    MOD             shift and go to state 86
    CONCAT          shift and go to state 85
    ASSIGN          shift and go to state 84

    assigning_operator             shift and go to state 77

state 22

    (2) statement_list -> statement .

    END             reduce using rule 2 (statement_list -> statement .)
    DCL             reduce using rule 2 (statement_list -> statement .)
    SYN             reduce using rule 2 (statement_list -> statement .)
    TYPE            reduce using rule 2 (statement_list -> statement .)
    ID              reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    DO              reduce using rule 2 (statement_list -> statement .)
    EXIT            reduce using rule 2 (statement_list -> statement .)
    RETURN          reduce using rule 2 (statement_list -> statement .)
    RESULT          reduce using rule 2 (statement_list -> statement .)
    NUM             reduce using rule 2 (statement_list -> statement .)
    PRED            reduce using rule 2 (statement_list -> statement .)
    SUCC            reduce using rule 2 (statement_list -> statement .)
    UPPER           reduce using rule 2 (statement_list -> statement .)
    LOWER           reduce using rule 2 (statement_list -> statement .)
    LENGTH          reduce using rule 2 (statement_list -> statement .)
    READ            reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)


state 23

    (58) location -> string_slice .

    ARROW           reduce using rule 58 (location -> string_slice .)
    LBRACKET        reduce using rule 58 (location -> string_slice .)
    PLUS            reduce using rule 58 (location -> string_slice .)
    MINUS           reduce using rule 58 (location -> string_slice .)
    TIMES           reduce using rule 58 (location -> string_slice .)
    DIVIDE          reduce using rule 58 (location -> string_slice .)
    MOD             reduce using rule 58 (location -> string_slice .)
    CONCAT          reduce using rule 58 (location -> string_slice .)
    ASSIGN          reduce using rule 58 (location -> string_slice .)
    AND             reduce using rule 58 (location -> string_slice .)
    OR              reduce using rule 58 (location -> string_slice .)
    EQ              reduce using rule 58 (location -> string_slice .)
    NEQ             reduce using rule 58 (location -> string_slice .)
    GT              reduce using rule 58 (location -> string_slice .)
    GE              reduce using rule 58 (location -> string_slice .)
    LT              reduce using rule 58 (location -> string_slice .)
    LE              reduce using rule 58 (location -> string_slice .)
    NOT             reduce using rule 58 (location -> string_slice .)
    IN              reduce using rule 58 (location -> string_slice .)
    SEMI            reduce using rule 58 (location -> string_slice .)
    THEN            reduce using rule 58 (location -> string_slice .)
    RPAREN          reduce using rule 58 (location -> string_slice .)
    COMMA           reduce using rule 58 (location -> string_slice .)
    RBRACKET        reduce using rule 58 (location -> string_slice .)
    COLON           reduce using rule 58 (location -> string_slice .)
    ELSE            reduce using rule 58 (location -> string_slice .)
    ELSIF           reduce using rule 58 (location -> string_slice .)
    DOWN            reduce using rule 58 (location -> string_slice .)
    BY              reduce using rule 58 (location -> string_slice .)
    TO              reduce using rule 58 (location -> string_slice .)
    FI              reduce using rule 58 (location -> string_slice .)
    WHILE           reduce using rule 58 (location -> string_slice .)


state 24

    (164) call_action -> builtin_call .

    SEMI            reduce using rule 164 (call_action -> builtin_call .)
    ARROW           reduce using rule 164 (call_action -> builtin_call .)
    LBRACKET        reduce using rule 164 (call_action -> builtin_call .)
    PLUS            reduce using rule 164 (call_action -> builtin_call .)
    MINUS           reduce using rule 164 (call_action -> builtin_call .)
    TIMES           reduce using rule 164 (call_action -> builtin_call .)
    DIVIDE          reduce using rule 164 (call_action -> builtin_call .)
    MOD             reduce using rule 164 (call_action -> builtin_call .)
    CONCAT          reduce using rule 164 (call_action -> builtin_call .)
    ASSIGN          reduce using rule 164 (call_action -> builtin_call .)
    AND             reduce using rule 164 (call_action -> builtin_call .)
    OR              reduce using rule 164 (call_action -> builtin_call .)
    EQ              reduce using rule 164 (call_action -> builtin_call .)
    NEQ             reduce using rule 164 (call_action -> builtin_call .)
    GT              reduce using rule 164 (call_action -> builtin_call .)
    GE              reduce using rule 164 (call_action -> builtin_call .)
    LT              reduce using rule 164 (call_action -> builtin_call .)
    LE              reduce using rule 164 (call_action -> builtin_call .)
    NOT             reduce using rule 164 (call_action -> builtin_call .)
    IN              reduce using rule 164 (call_action -> builtin_call .)
    THEN            reduce using rule 164 (call_action -> builtin_call .)
    RPAREN          reduce using rule 164 (call_action -> builtin_call .)
    COMMA           reduce using rule 164 (call_action -> builtin_call .)
    RBRACKET        reduce using rule 164 (call_action -> builtin_call .)
    COLON           reduce using rule 164 (call_action -> builtin_call .)
    ELSE            reduce using rule 164 (call_action -> builtin_call .)
    ELSIF           reduce using rule 164 (call_action -> builtin_call .)
    DOWN            reduce using rule 164 (call_action -> builtin_call .)
    BY              reduce using rule 164 (call_action -> builtin_call .)
    TO              reduce using rule 164 (call_action -> builtin_call .)
    FI              reduce using rule 164 (call_action -> builtin_call .)
    WHILE           reduce using rule 164 (call_action -> builtin_call .)


state 25

    (122) action -> call_action .
    (61) location -> call_action .

    SEMI            reduce using rule 122 (action -> call_action .)
    ARROW           reduce using rule 61 (location -> call_action .)
    LBRACKET        reduce using rule 61 (location -> call_action .)
    PLUS            reduce using rule 61 (location -> call_action .)
    MINUS           reduce using rule 61 (location -> call_action .)
    TIMES           reduce using rule 61 (location -> call_action .)
    DIVIDE          reduce using rule 61 (location -> call_action .)
    MOD             reduce using rule 61 (location -> call_action .)
    CONCAT          reduce using rule 61 (location -> call_action .)
    ASSIGN          reduce using rule 61 (location -> call_action .)


state 26

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (183) procedure_statement -> . identifier COLON procedure_definition SEMI
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    $end            reduce using rule 1 (program -> statement_list .)
    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 87
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 27

    (172) result_action -> RESULT . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 88
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 28

    (123) action -> exit_action .

    SEMI            reduce using rule 123 (action -> exit_action .)


state 29

    (175) builtin_name -> NUM .

    LPAREN          reduce using rule 175 (builtin_name -> NUM .)


state 30

    (6) statement -> newmode_statement .

    DCL             reduce using rule 6 (statement -> newmode_statement .)
    SYN             reduce using rule 6 (statement -> newmode_statement .)
    TYPE            reduce using rule 6 (statement -> newmode_statement .)
    ID              reduce using rule 6 (statement -> newmode_statement .)
    IF              reduce using rule 6 (statement -> newmode_statement .)
    DO              reduce using rule 6 (statement -> newmode_statement .)
    EXIT            reduce using rule 6 (statement -> newmode_statement .)
    RETURN          reduce using rule 6 (statement -> newmode_statement .)
    RESULT          reduce using rule 6 (statement -> newmode_statement .)
    NUM             reduce using rule 6 (statement -> newmode_statement .)
    PRED            reduce using rule 6 (statement -> newmode_statement .)
    SUCC            reduce using rule 6 (statement -> newmode_statement .)
    UPPER           reduce using rule 6 (statement -> newmode_statement .)
    LOWER           reduce using rule 6 (statement -> newmode_statement .)
    LENGTH          reduce using rule 6 (statement -> newmode_statement .)
    READ            reduce using rule 6 (statement -> newmode_statement .)
    PRINT           reduce using rule 6 (statement -> newmode_statement .)
    $end            reduce using rule 6 (statement -> newmode_statement .)
    END             reduce using rule 6 (statement -> newmode_statement .)


state 31

    (17) identifier -> ID .

    AND             reduce using rule 17 (identifier -> ID .)
    OR              reduce using rule 17 (identifier -> ID .)
    EQ              reduce using rule 17 (identifier -> ID .)
    NEQ             reduce using rule 17 (identifier -> ID .)
    GT              reduce using rule 17 (identifier -> ID .)
    GE              reduce using rule 17 (identifier -> ID .)
    LT              reduce using rule 17 (identifier -> ID .)
    LE              reduce using rule 17 (identifier -> ID .)
    PLUS            reduce using rule 17 (identifier -> ID .)
    MINUS           reduce using rule 17 (identifier -> ID .)
    TIMES           reduce using rule 17 (identifier -> ID .)
    DIVIDE          reduce using rule 17 (identifier -> ID .)
    MOD             reduce using rule 17 (identifier -> ID .)
    NOT             reduce using rule 17 (identifier -> ID .)
    IN              reduce using rule 17 (identifier -> ID .)
    CONCAT          reduce using rule 17 (identifier -> ID .)
    SEMI            reduce using rule 17 (identifier -> ID .)
    COMMA           reduce using rule 17 (identifier -> ID .)
    LBRACKET        reduce using rule 17 (identifier -> ID .)
    LPAREN          reduce using rule 17 (identifier -> ID .)
    THEN            reduce using rule 17 (identifier -> ID .)
    RPAREN          reduce using rule 17 (identifier -> ID .)
    RBRACKET        reduce using rule 17 (identifier -> ID .)
    COLON           reduce using rule 17 (identifier -> ID .)
    ELSE            reduce using rule 17 (identifier -> ID .)
    ELSIF           reduce using rule 17 (identifier -> ID .)
    DOWN            reduce using rule 17 (identifier -> ID .)
    BY              reduce using rule 17 (identifier -> ID .)
    TO              reduce using rule 17 (identifier -> ID .)
    FI              reduce using rule 17 (identifier -> ID .)
    WHILE           reduce using rule 17 (identifier -> ID .)
    LOC             reduce using rule 17 (identifier -> ID .)
    REF             reduce using rule 17 (identifier -> ID .)
    ID              reduce using rule 17 (identifier -> ID .)
    INT             reduce using rule 17 (identifier -> ID .)
    BOOL            reduce using rule 17 (identifier -> ID .)
    CHAR            reduce using rule 17 (identifier -> ID .)
    CHARS           reduce using rule 17 (identifier -> ID .)
    ARRAY           reduce using rule 17 (identifier -> ID .)
    ASSIGN          reduce using rule 17 (identifier -> ID .)
    DCL             reduce using rule 17 (identifier -> ID .)
    SYN             reduce using rule 17 (identifier -> ID .)
    TYPE            reduce using rule 17 (identifier -> ID .)
    IF              reduce using rule 17 (identifier -> ID .)
    DO              reduce using rule 17 (identifier -> ID .)
    EXIT            reduce using rule 17 (identifier -> ID .)
    RETURN          reduce using rule 17 (identifier -> ID .)
    RESULT          reduce using rule 17 (identifier -> ID .)
    NUM             reduce using rule 17 (identifier -> ID .)
    PRED            reduce using rule 17 (identifier -> ID .)
    SUCC            reduce using rule 17 (identifier -> ID .)
    UPPER           reduce using rule 17 (identifier -> ID .)
    LOWER           reduce using rule 17 (identifier -> ID .)
    LENGTH          reduce using rule 17 (identifier -> ID .)
    READ            reduce using rule 17 (identifier -> ID .)
    PRINT           reduce using rule 17 (identifier -> ID .)
    $end            reduce using rule 17 (identifier -> ID .)
    END             reduce using rule 17 (identifier -> ID .)


state 32

    (135) if_action -> IF . boolean_expression then_clause else_clause FI
    (136) if_action -> IF . boolean_expression then_clause FI
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    boolean_expression             shift and go to state 89
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 90
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 33

    (178) builtin_name -> UPPER .

    LPAREN          reduce using rule 178 (builtin_name -> UPPER .)


state 34

    (56) location -> dereferenced_reference .

    ARROW           reduce using rule 56 (location -> dereferenced_reference .)
    LBRACKET        reduce using rule 56 (location -> dereferenced_reference .)
    PLUS            reduce using rule 56 (location -> dereferenced_reference .)
    MINUS           reduce using rule 56 (location -> dereferenced_reference .)
    TIMES           reduce using rule 56 (location -> dereferenced_reference .)
    DIVIDE          reduce using rule 56 (location -> dereferenced_reference .)
    MOD             reduce using rule 56 (location -> dereferenced_reference .)
    CONCAT          reduce using rule 56 (location -> dereferenced_reference .)
    ASSIGN          reduce using rule 56 (location -> dereferenced_reference .)
    AND             reduce using rule 56 (location -> dereferenced_reference .)
    OR              reduce using rule 56 (location -> dereferenced_reference .)
    EQ              reduce using rule 56 (location -> dereferenced_reference .)
    NEQ             reduce using rule 56 (location -> dereferenced_reference .)
    GT              reduce using rule 56 (location -> dereferenced_reference .)
    GE              reduce using rule 56 (location -> dereferenced_reference .)
    LT              reduce using rule 56 (location -> dereferenced_reference .)
    LE              reduce using rule 56 (location -> dereferenced_reference .)
    NOT             reduce using rule 56 (location -> dereferenced_reference .)
    IN              reduce using rule 56 (location -> dereferenced_reference .)
    SEMI            reduce using rule 56 (location -> dereferenced_reference .)
    THEN            reduce using rule 56 (location -> dereferenced_reference .)
    RPAREN          reduce using rule 56 (location -> dereferenced_reference .)
    COMMA           reduce using rule 56 (location -> dereferenced_reference .)
    RBRACKET        reduce using rule 56 (location -> dereferenced_reference .)
    COLON           reduce using rule 56 (location -> dereferenced_reference .)
    ELSE            reduce using rule 56 (location -> dereferenced_reference .)
    ELSIF           reduce using rule 56 (location -> dereferenced_reference .)
    DOWN            reduce using rule 56 (location -> dereferenced_reference .)
    BY              reduce using rule 56 (location -> dereferenced_reference .)
    TO              reduce using rule 56 (location -> dereferenced_reference .)
    FI              reduce using rule 56 (location -> dereferenced_reference .)
    WHILE           reduce using rule 56 (location -> dereferenced_reference .)


state 35

    (24) newmode_statement -> TYPE . newmode_list
    (25) newmode_list -> . mode_definition
    (26) newmode_list -> . newmode_list COMMA mode_definition
    (27) mode_definition -> . identifier_list mode
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    mode_definition                shift and go to state 91
    newmode_list                   shift and go to state 92
    identifier_list                shift and go to state 93
    identifier                     shift and go to state 73

state 36

    (18) synonym_statement -> SYN . synonym_list SEMI
    (19) synonym_list -> . synonym_definition
    (20) synonym_list -> . synonym_list COMMA synonym_definition
    (21) synonym_definition -> . identifier_list mode ASSIGN constant_expression
    (22) synonym_definition -> . identifier_list ASSIGN constant_expression
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    synonym_definition             shift and go to state 94
    identifier_list                shift and go to state 96
    synonym_list                   shift and go to state 95
    identifier                     shift and go to state 73

state 37

    (4) statement -> declaration_statement .

    DCL             reduce using rule 4 (statement -> declaration_statement .)
    SYN             reduce using rule 4 (statement -> declaration_statement .)
    TYPE            reduce using rule 4 (statement -> declaration_statement .)
    ID              reduce using rule 4 (statement -> declaration_statement .)
    IF              reduce using rule 4 (statement -> declaration_statement .)
    DO              reduce using rule 4 (statement -> declaration_statement .)
    EXIT            reduce using rule 4 (statement -> declaration_statement .)
    RETURN          reduce using rule 4 (statement -> declaration_statement .)
    RESULT          reduce using rule 4 (statement -> declaration_statement .)
    NUM             reduce using rule 4 (statement -> declaration_statement .)
    PRED            reduce using rule 4 (statement -> declaration_statement .)
    SUCC            reduce using rule 4 (statement -> declaration_statement .)
    UPPER           reduce using rule 4 (statement -> declaration_statement .)
    LOWER           reduce using rule 4 (statement -> declaration_statement .)
    LENGTH          reduce using rule 4 (statement -> declaration_statement .)
    READ            reduce using rule 4 (statement -> declaration_statement .)
    PRINT           reduce using rule 4 (statement -> declaration_statement .)
    $end            reduce using rule 4 (statement -> declaration_statement .)
    END             reduce using rule 4 (statement -> declaration_statement .)


state 38

    (169) exit_action -> EXIT . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier                     shift and go to state 97

state 39

    (60) location -> array_slice .

    ARROW           reduce using rule 60 (location -> array_slice .)
    LBRACKET        reduce using rule 60 (location -> array_slice .)
    PLUS            reduce using rule 60 (location -> array_slice .)
    MINUS           reduce using rule 60 (location -> array_slice .)
    TIMES           reduce using rule 60 (location -> array_slice .)
    DIVIDE          reduce using rule 60 (location -> array_slice .)
    MOD             reduce using rule 60 (location -> array_slice .)
    CONCAT          reduce using rule 60 (location -> array_slice .)
    ASSIGN          reduce using rule 60 (location -> array_slice .)
    AND             reduce using rule 60 (location -> array_slice .)
    OR              reduce using rule 60 (location -> array_slice .)
    EQ              reduce using rule 60 (location -> array_slice .)
    NEQ             reduce using rule 60 (location -> array_slice .)
    GT              reduce using rule 60 (location -> array_slice .)
    GE              reduce using rule 60 (location -> array_slice .)
    LT              reduce using rule 60 (location -> array_slice .)
    LE              reduce using rule 60 (location -> array_slice .)
    NOT             reduce using rule 60 (location -> array_slice .)
    IN              reduce using rule 60 (location -> array_slice .)
    SEMI            reduce using rule 60 (location -> array_slice .)
    THEN            reduce using rule 60 (location -> array_slice .)
    RPAREN          reduce using rule 60 (location -> array_slice .)
    COMMA           reduce using rule 60 (location -> array_slice .)
    RBRACKET        reduce using rule 60 (location -> array_slice .)
    COLON           reduce using rule 60 (location -> array_slice .)
    ELSE            reduce using rule 60 (location -> array_slice .)
    ELSIF           reduce using rule 60 (location -> array_slice .)
    DOWN            reduce using rule 60 (location -> array_slice .)
    BY              reduce using rule 60 (location -> array_slice .)
    TO              reduce using rule 60 (location -> array_slice .)
    FI              reduce using rule 60 (location -> array_slice .)
    WHILE           reduce using rule 60 (location -> array_slice .)


state 40

    (118) action_statement -> action . SEMI

    SEMI            shift and go to state 98


state 41

    (183) procedure_statement -> identifier . COLON procedure_definition SEMI
    (117) action_statement -> identifier . COLON action SEMI
    (127) assignment_action -> identifier . assigning_operator expression
    (165) procedure_call -> identifier . LPAREN parameter_list RPAREN
    (166) procedure_call -> identifier . LPAREN RPAREN
    (63) string_element -> identifier . LBRACKET ICONST RBRACKET
    (64) string_slice -> identifier . LBRACKET ICONST COLON ICONST RBRACKET
    (128) assigning_operator -> . PLUS ASSIGN
    (129) assigning_operator -> . MINUS ASSIGN
    (130) assigning_operator -> . TIMES ASSIGN
    (131) assigning_operator -> . DIVIDE ASSIGN
    (132) assigning_operator -> . MOD ASSIGN
    (133) assigning_operator -> . CONCAT ASSIGN
    (134) assigning_operator -> . ASSIGN

    COLON           shift and go to state 101
    LPAREN          shift and go to state 102
    LBRACKET        shift and go to state 100
    PLUS            shift and go to state 80
    MINUS           shift and go to state 79
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 78
    MOD             shift and go to state 86
    CONCAT          shift and go to state 85
    ASSIGN          shift and go to state 84

    assigning_operator             shift and go to state 99

state 42

    (8) statement -> action_statement .

    DCL             reduce using rule 8 (statement -> action_statement .)
    SYN             reduce using rule 8 (statement -> action_statement .)
    TYPE            reduce using rule 8 (statement -> action_statement .)
    ID              reduce using rule 8 (statement -> action_statement .)
    IF              reduce using rule 8 (statement -> action_statement .)
    DO              reduce using rule 8 (statement -> action_statement .)
    EXIT            reduce using rule 8 (statement -> action_statement .)
    RETURN          reduce using rule 8 (statement -> action_statement .)
    RESULT          reduce using rule 8 (statement -> action_statement .)
    NUM             reduce using rule 8 (statement -> action_statement .)
    PRED            reduce using rule 8 (statement -> action_statement .)
    SUCC            reduce using rule 8 (statement -> action_statement .)
    UPPER           reduce using rule 8 (statement -> action_statement .)
    LOWER           reduce using rule 8 (statement -> action_statement .)
    LENGTH          reduce using rule 8 (statement -> action_statement .)
    READ            reduce using rule 8 (statement -> action_statement .)
    PRINT           reduce using rule 8 (statement -> action_statement .)
    $end            reduce using rule 8 (statement -> action_statement .)
    END             reduce using rule 8 (statement -> action_statement .)


state 43

    (176) builtin_name -> PRED .

    LPAREN          reduce using rule 176 (builtin_name -> PRED .)


state 44

    (72) primitive_value -> parenthesized_expression .

    AND             reduce using rule 72 (primitive_value -> parenthesized_expression .)
    OR              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    EQ              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    NEQ             reduce using rule 72 (primitive_value -> parenthesized_expression .)
    GT              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    GE              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    LT              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    LE              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    PLUS            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    MINUS           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    TIMES           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    DIVIDE          reduce using rule 72 (primitive_value -> parenthesized_expression .)
    MOD             reduce using rule 72 (primitive_value -> parenthesized_expression .)
    NOT             reduce using rule 72 (primitive_value -> parenthesized_expression .)
    IN              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    CONCAT          reduce using rule 72 (primitive_value -> parenthesized_expression .)
    SEMI            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    COMMA           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    LBRACKET        reduce using rule 72 (primitive_value -> parenthesized_expression .)
    THEN            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    RPAREN          reduce using rule 72 (primitive_value -> parenthesized_expression .)
    RBRACKET        reduce using rule 72 (primitive_value -> parenthesized_expression .)
    COLON           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    ELSE            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    ELSIF           reduce using rule 72 (primitive_value -> parenthesized_expression .)
    DOWN            reduce using rule 72 (primitive_value -> parenthesized_expression .)
    BY              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    TO              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    FI              reduce using rule 72 (primitive_value -> parenthesized_expression .)
    WHILE           reduce using rule 72 (primitive_value -> parenthesized_expression .)


state 45

    (92) binop -> operand .

    AND             reduce using rule 92 (binop -> operand .)
    OR              reduce using rule 92 (binop -> operand .)
    EQ              reduce using rule 92 (binop -> operand .)
    NEQ             reduce using rule 92 (binop -> operand .)
    GT              reduce using rule 92 (binop -> operand .)
    GE              reduce using rule 92 (binop -> operand .)
    LT              reduce using rule 92 (binop -> operand .)
    LE              reduce using rule 92 (binop -> operand .)
    PLUS            reduce using rule 92 (binop -> operand .)
    MINUS           reduce using rule 92 (binop -> operand .)
    TIMES           reduce using rule 92 (binop -> operand .)
    DIVIDE          reduce using rule 92 (binop -> operand .)
    MOD             reduce using rule 92 (binop -> operand .)
    NOT             reduce using rule 92 (binop -> operand .)
    IN              reduce using rule 92 (binop -> operand .)
    CONCAT          reduce using rule 92 (binop -> operand .)
    ELSE            reduce using rule 92 (binop -> operand .)
    ELSIF           reduce using rule 92 (binop -> operand .)
    SEMI            reduce using rule 92 (binop -> operand .)
    THEN            reduce using rule 92 (binop -> operand .)
    RPAREN          reduce using rule 92 (binop -> operand .)
    COMMA           reduce using rule 92 (binop -> operand .)
    RBRACKET        reduce using rule 92 (binop -> operand .)
    COLON           reduce using rule 92 (binop -> operand .)
    DOWN            reduce using rule 92 (binop -> operand .)
    BY              reduce using rule 92 (binop -> operand .)
    TO              reduce using rule 92 (binop -> operand .)
    FI              reduce using rule 92 (binop -> operand .)
    WHILE           reduce using rule 92 (binop -> operand .)


state 46

    (77) literal -> NULL .

    AND             reduce using rule 77 (literal -> NULL .)
    OR              reduce using rule 77 (literal -> NULL .)
    EQ              reduce using rule 77 (literal -> NULL .)
    NEQ             reduce using rule 77 (literal -> NULL .)
    GT              reduce using rule 77 (literal -> NULL .)
    GE              reduce using rule 77 (literal -> NULL .)
    LT              reduce using rule 77 (literal -> NULL .)
    LE              reduce using rule 77 (literal -> NULL .)
    PLUS            reduce using rule 77 (literal -> NULL .)
    MINUS           reduce using rule 77 (literal -> NULL .)
    TIMES           reduce using rule 77 (literal -> NULL .)
    DIVIDE          reduce using rule 77 (literal -> NULL .)
    MOD             reduce using rule 77 (literal -> NULL .)
    NOT             reduce using rule 77 (literal -> NULL .)
    IN              reduce using rule 77 (literal -> NULL .)
    CONCAT          reduce using rule 77 (literal -> NULL .)
    WHILE           reduce using rule 77 (literal -> NULL .)
    LBRACKET        reduce using rule 77 (literal -> NULL .)
    SEMI            reduce using rule 77 (literal -> NULL .)
    THEN            reduce using rule 77 (literal -> NULL .)
    RPAREN          reduce using rule 77 (literal -> NULL .)
    COMMA           reduce using rule 77 (literal -> NULL .)
    RBRACKET        reduce using rule 77 (literal -> NULL .)
    COLON           reduce using rule 77 (literal -> NULL .)
    ELSE            reduce using rule 77 (literal -> NULL .)
    ELSIF           reduce using rule 77 (literal -> NULL .)
    DOWN            reduce using rule 77 (literal -> NULL .)
    BY              reduce using rule 77 (literal -> NULL .)
    TO              reduce using rule 77 (literal -> NULL .)
    FI              reduce using rule 77 (literal -> NULL .)


state 47

    (75) literal -> TRUE .

    AND             reduce using rule 75 (literal -> TRUE .)
    OR              reduce using rule 75 (literal -> TRUE .)
    EQ              reduce using rule 75 (literal -> TRUE .)
    NEQ             reduce using rule 75 (literal -> TRUE .)
    GT              reduce using rule 75 (literal -> TRUE .)
    GE              reduce using rule 75 (literal -> TRUE .)
    LT              reduce using rule 75 (literal -> TRUE .)
    LE              reduce using rule 75 (literal -> TRUE .)
    PLUS            reduce using rule 75 (literal -> TRUE .)
    MINUS           reduce using rule 75 (literal -> TRUE .)
    TIMES           reduce using rule 75 (literal -> TRUE .)
    DIVIDE          reduce using rule 75 (literal -> TRUE .)
    MOD             reduce using rule 75 (literal -> TRUE .)
    NOT             reduce using rule 75 (literal -> TRUE .)
    IN              reduce using rule 75 (literal -> TRUE .)
    CONCAT          reduce using rule 75 (literal -> TRUE .)
    WHILE           reduce using rule 75 (literal -> TRUE .)
    LBRACKET        reduce using rule 75 (literal -> TRUE .)
    SEMI            reduce using rule 75 (literal -> TRUE .)
    THEN            reduce using rule 75 (literal -> TRUE .)
    RPAREN          reduce using rule 75 (literal -> TRUE .)
    COMMA           reduce using rule 75 (literal -> TRUE .)
    RBRACKET        reduce using rule 75 (literal -> TRUE .)
    COLON           reduce using rule 75 (literal -> TRUE .)
    ELSE            reduce using rule 75 (literal -> TRUE .)
    ELSIF           reduce using rule 75 (literal -> TRUE .)
    DOWN            reduce using rule 75 (literal -> TRUE .)
    BY              reduce using rule 75 (literal -> TRUE .)
    TO              reduce using rule 75 (literal -> TRUE .)
    FI              reduce using rule 75 (literal -> TRUE .)


state 48

    (109) operand -> MINUS . operand1
    (113) operand1 -> . location
    (114) operand1 -> . referenced_location
    (115) operand1 -> . primitive_value
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (116) referenced_location -> . ARROW location
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (17) identifier -> . ID
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    ARROW           shift and go to state 107
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55
    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 51
    string_element                 shift and go to state 15
    operand1                       shift and go to state 103
    literal                        shift and go to state 49
    location                       shift and go to state 104
    call_action                    shift and go to state 105
    referenced_location            shift and go to state 106
    builtin_call                   shift and go to state 24
    array_primitive_value          shift and go to state 58
    parenthesized_expression       shift and go to state 44
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 59
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 108
    primitive_value                shift and go to state 109

state 49

    (69) primitive_value -> literal .

    AND             reduce using rule 69 (primitive_value -> literal .)
    OR              reduce using rule 69 (primitive_value -> literal .)
    EQ              reduce using rule 69 (primitive_value -> literal .)
    NEQ             reduce using rule 69 (primitive_value -> literal .)
    GT              reduce using rule 69 (primitive_value -> literal .)
    GE              reduce using rule 69 (primitive_value -> literal .)
    LT              reduce using rule 69 (primitive_value -> literal .)
    LE              reduce using rule 69 (primitive_value -> literal .)
    PLUS            reduce using rule 69 (primitive_value -> literal .)
    MINUS           reduce using rule 69 (primitive_value -> literal .)
    TIMES           reduce using rule 69 (primitive_value -> literal .)
    DIVIDE          reduce using rule 69 (primitive_value -> literal .)
    MOD             reduce using rule 69 (primitive_value -> literal .)
    NOT             reduce using rule 69 (primitive_value -> literal .)
    IN              reduce using rule 69 (primitive_value -> literal .)
    CONCAT          reduce using rule 69 (primitive_value -> literal .)
    SEMI            reduce using rule 69 (primitive_value -> literal .)
    COMMA           reduce using rule 69 (primitive_value -> literal .)
    LBRACKET        reduce using rule 69 (primitive_value -> literal .)
    THEN            reduce using rule 69 (primitive_value -> literal .)
    RPAREN          reduce using rule 69 (primitive_value -> literal .)
    RBRACKET        reduce using rule 69 (primitive_value -> literal .)
    COLON           reduce using rule 69 (primitive_value -> literal .)
    ELSE            reduce using rule 69 (primitive_value -> literal .)
    ELSIF           reduce using rule 69 (primitive_value -> literal .)
    DOWN            reduce using rule 69 (primitive_value -> literal .)
    BY              reduce using rule 69 (primitive_value -> literal .)
    TO              reduce using rule 69 (primitive_value -> literal .)
    FI              reduce using rule 69 (primitive_value -> literal .)
    WHILE           reduce using rule 69 (primitive_value -> literal .)


state 50

    (78) literal -> SCONST .

    AND             reduce using rule 78 (literal -> SCONST .)
    OR              reduce using rule 78 (literal -> SCONST .)
    EQ              reduce using rule 78 (literal -> SCONST .)
    NEQ             reduce using rule 78 (literal -> SCONST .)
    GT              reduce using rule 78 (literal -> SCONST .)
    GE              reduce using rule 78 (literal -> SCONST .)
    LT              reduce using rule 78 (literal -> SCONST .)
    LE              reduce using rule 78 (literal -> SCONST .)
    PLUS            reduce using rule 78 (literal -> SCONST .)
    MINUS           reduce using rule 78 (literal -> SCONST .)
    TIMES           reduce using rule 78 (literal -> SCONST .)
    DIVIDE          reduce using rule 78 (literal -> SCONST .)
    MOD             reduce using rule 78 (literal -> SCONST .)
    NOT             reduce using rule 78 (literal -> SCONST .)
    IN              reduce using rule 78 (literal -> SCONST .)
    CONCAT          reduce using rule 78 (literal -> SCONST .)
    WHILE           reduce using rule 78 (literal -> SCONST .)
    LBRACKET        reduce using rule 78 (literal -> SCONST .)
    SEMI            reduce using rule 78 (literal -> SCONST .)
    THEN            reduce using rule 78 (literal -> SCONST .)
    RPAREN          reduce using rule 78 (literal -> SCONST .)
    COMMA           reduce using rule 78 (literal -> SCONST .)
    RBRACKET        reduce using rule 78 (literal -> SCONST .)
    COLON           reduce using rule 78 (literal -> SCONST .)
    ELSE            reduce using rule 78 (literal -> SCONST .)
    ELSIF           reduce using rule 78 (literal -> SCONST .)
    DOWN            reduce using rule 78 (literal -> SCONST .)
    BY              reduce using rule 78 (literal -> SCONST .)
    TO              reduce using rule 78 (literal -> SCONST .)
    FI              reduce using rule 78 (literal -> SCONST .)


state 51

    (70) primitive_value -> value_array_element .

    AND             reduce using rule 70 (primitive_value -> value_array_element .)
    OR              reduce using rule 70 (primitive_value -> value_array_element .)
    EQ              reduce using rule 70 (primitive_value -> value_array_element .)
    NEQ             reduce using rule 70 (primitive_value -> value_array_element .)
    GT              reduce using rule 70 (primitive_value -> value_array_element .)
    GE              reduce using rule 70 (primitive_value -> value_array_element .)
    LT              reduce using rule 70 (primitive_value -> value_array_element .)
    LE              reduce using rule 70 (primitive_value -> value_array_element .)
    PLUS            reduce using rule 70 (primitive_value -> value_array_element .)
    MINUS           reduce using rule 70 (primitive_value -> value_array_element .)
    TIMES           reduce using rule 70 (primitive_value -> value_array_element .)
    DIVIDE          reduce using rule 70 (primitive_value -> value_array_element .)
    MOD             reduce using rule 70 (primitive_value -> value_array_element .)
    NOT             reduce using rule 70 (primitive_value -> value_array_element .)
    IN              reduce using rule 70 (primitive_value -> value_array_element .)
    CONCAT          reduce using rule 70 (primitive_value -> value_array_element .)
    SEMI            reduce using rule 70 (primitive_value -> value_array_element .)
    COMMA           reduce using rule 70 (primitive_value -> value_array_element .)
    LBRACKET        reduce using rule 70 (primitive_value -> value_array_element .)
    THEN            reduce using rule 70 (primitive_value -> value_array_element .)
    RPAREN          reduce using rule 70 (primitive_value -> value_array_element .)
    RBRACKET        reduce using rule 70 (primitive_value -> value_array_element .)
    COLON           reduce using rule 70 (primitive_value -> value_array_element .)
    ELSE            reduce using rule 70 (primitive_value -> value_array_element .)
    ELSIF           reduce using rule 70 (primitive_value -> value_array_element .)
    DOWN            reduce using rule 70 (primitive_value -> value_array_element .)
    BY              reduce using rule 70 (primitive_value -> value_array_element .)
    TO              reduce using rule 70 (primitive_value -> value_array_element .)
    FI              reduce using rule 70 (primitive_value -> value_array_element .)
    WHILE           reduce using rule 70 (primitive_value -> value_array_element .)


state 52

    (76) literal -> CCONST .

    AND             reduce using rule 76 (literal -> CCONST .)
    OR              reduce using rule 76 (literal -> CCONST .)
    EQ              reduce using rule 76 (literal -> CCONST .)
    NEQ             reduce using rule 76 (literal -> CCONST .)
    GT              reduce using rule 76 (literal -> CCONST .)
    GE              reduce using rule 76 (literal -> CCONST .)
    LT              reduce using rule 76 (literal -> CCONST .)
    LE              reduce using rule 76 (literal -> CCONST .)
    PLUS            reduce using rule 76 (literal -> CCONST .)
    MINUS           reduce using rule 76 (literal -> CCONST .)
    TIMES           reduce using rule 76 (literal -> CCONST .)
    DIVIDE          reduce using rule 76 (literal -> CCONST .)
    MOD             reduce using rule 76 (literal -> CCONST .)
    NOT             reduce using rule 76 (literal -> CCONST .)
    IN              reduce using rule 76 (literal -> CCONST .)
    CONCAT          reduce using rule 76 (literal -> CCONST .)
    WHILE           reduce using rule 76 (literal -> CCONST .)
    LBRACKET        reduce using rule 76 (literal -> CCONST .)
    SEMI            reduce using rule 76 (literal -> CCONST .)
    THEN            reduce using rule 76 (literal -> CCONST .)
    RPAREN          reduce using rule 76 (literal -> CCONST .)
    COMMA           reduce using rule 76 (literal -> CCONST .)
    RBRACKET        reduce using rule 76 (literal -> CCONST .)
    COLON           reduce using rule 76 (literal -> CCONST .)
    ELSE            reduce using rule 76 (literal -> CCONST .)
    ELSIF           reduce using rule 76 (literal -> CCONST .)
    DOWN            reduce using rule 76 (literal -> CCONST .)
    BY              reduce using rule 76 (literal -> CCONST .)
    TO              reduce using rule 76 (literal -> CCONST .)
    FI              reduce using rule 76 (literal -> CCONST .)


state 53

    (83) expression -> binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    RPAREN          reduce using rule 83 (expression -> binop .)
    COMMA           reduce using rule 83 (expression -> binop .)
    SEMI            reduce using rule 83 (expression -> binop .)
    RBRACKET        reduce using rule 83 (expression -> binop .)
    THEN            reduce using rule 83 (expression -> binop .)
    DOWN            reduce using rule 83 (expression -> binop .)
    BY              reduce using rule 83 (expression -> binop .)
    TO              reduce using rule 83 (expression -> binop .)
    WHILE           reduce using rule 83 (expression -> binop .)
    FI              reduce using rule 83 (expression -> binop .)
    ELSE            reduce using rule 83 (expression -> binop .)
    ELSIF           reduce using rule 83 (expression -> binop .)
    COLON           reduce using rule 83 (expression -> binop .)
    AND             shift and go to state 110
    OR              shift and go to state 123
    EQ              shift and go to state 122
    NEQ             shift and go to state 125
    GT              shift and go to state 111
    GE              shift and go to state 115
    LT              shift and go to state 113
    LE              shift and go to state 116
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118
    NOT             shift and go to state 120
    IN              shift and go to state 119
    CONCAT          shift and go to state 124


state 54

    (73) literal -> ICONST .

    AND             reduce using rule 73 (literal -> ICONST .)
    OR              reduce using rule 73 (literal -> ICONST .)
    EQ              reduce using rule 73 (literal -> ICONST .)
    NEQ             reduce using rule 73 (literal -> ICONST .)
    GT              reduce using rule 73 (literal -> ICONST .)
    GE              reduce using rule 73 (literal -> ICONST .)
    LT              reduce using rule 73 (literal -> ICONST .)
    LE              reduce using rule 73 (literal -> ICONST .)
    PLUS            reduce using rule 73 (literal -> ICONST .)
    MINUS           reduce using rule 73 (literal -> ICONST .)
    TIMES           reduce using rule 73 (literal -> ICONST .)
    DIVIDE          reduce using rule 73 (literal -> ICONST .)
    MOD             reduce using rule 73 (literal -> ICONST .)
    NOT             reduce using rule 73 (literal -> ICONST .)
    IN              reduce using rule 73 (literal -> ICONST .)
    CONCAT          reduce using rule 73 (literal -> ICONST .)
    WHILE           reduce using rule 73 (literal -> ICONST .)
    LBRACKET        reduce using rule 73 (literal -> ICONST .)
    SEMI            reduce using rule 73 (literal -> ICONST .)
    THEN            reduce using rule 73 (literal -> ICONST .)
    RPAREN          reduce using rule 73 (literal -> ICONST .)
    COMMA           reduce using rule 73 (literal -> ICONST .)
    RBRACKET        reduce using rule 73 (literal -> ICONST .)
    COLON           reduce using rule 73 (literal -> ICONST .)
    ELSE            reduce using rule 73 (literal -> ICONST .)
    ELSIF           reduce using rule 73 (literal -> ICONST .)
    DOWN            reduce using rule 73 (literal -> ICONST .)
    BY              reduce using rule 73 (literal -> ICONST .)
    TO              reduce using rule 73 (literal -> ICONST .)
    FI              reduce using rule 73 (literal -> ICONST .)


state 55

    (82) parenthesized_expression -> LPAREN . expression RPAREN
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 126
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 56

    (85) conditional_expression -> IF . boolean_expression then_expression else_expression FI
    (86) conditional_expression -> IF . boolean_expression then_expression elsif_expression else_expression FI
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    boolean_expression             shift and go to state 127
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 90
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 57

    (74) literal -> FALSE .

    AND             reduce using rule 74 (literal -> FALSE .)
    OR              reduce using rule 74 (literal -> FALSE .)
    EQ              reduce using rule 74 (literal -> FALSE .)
    NEQ             reduce using rule 74 (literal -> FALSE .)
    GT              reduce using rule 74 (literal -> FALSE .)
    GE              reduce using rule 74 (literal -> FALSE .)
    LT              reduce using rule 74 (literal -> FALSE .)
    LE              reduce using rule 74 (literal -> FALSE .)
    PLUS            reduce using rule 74 (literal -> FALSE .)
    MINUS           reduce using rule 74 (literal -> FALSE .)
    TIMES           reduce using rule 74 (literal -> FALSE .)
    DIVIDE          reduce using rule 74 (literal -> FALSE .)
    MOD             reduce using rule 74 (literal -> FALSE .)
    NOT             reduce using rule 74 (literal -> FALSE .)
    IN              reduce using rule 74 (literal -> FALSE .)
    CONCAT          reduce using rule 74 (literal -> FALSE .)
    WHILE           reduce using rule 74 (literal -> FALSE .)
    LBRACKET        reduce using rule 74 (literal -> FALSE .)
    SEMI            reduce using rule 74 (literal -> FALSE .)
    THEN            reduce using rule 74 (literal -> FALSE .)
    RPAREN          reduce using rule 74 (literal -> FALSE .)
    COMMA           reduce using rule 74 (literal -> FALSE .)
    RBRACKET        reduce using rule 74 (literal -> FALSE .)
    COLON           reduce using rule 74 (literal -> FALSE .)
    ELSE            reduce using rule 74 (literal -> FALSE .)
    ELSIF           reduce using rule 74 (literal -> FALSE .)
    DOWN            reduce using rule 74 (literal -> FALSE .)
    BY              reduce using rule 74 (literal -> FALSE .)
    TO              reduce using rule 74 (literal -> FALSE .)
    FI              reduce using rule 74 (literal -> FALSE .)


state 58

    (79) value_array_element -> array_primitive_value . LBRACKET expression_list RBRACKET
    (80) value_array_slice -> array_primitive_value . LBRACKET expression COLON expression RBRACKET

    LBRACKET        shift and go to state 128


state 59

    (71) primitive_value -> value_array_slice .

    AND             reduce using rule 71 (primitive_value -> value_array_slice .)
    OR              reduce using rule 71 (primitive_value -> value_array_slice .)
    EQ              reduce using rule 71 (primitive_value -> value_array_slice .)
    NEQ             reduce using rule 71 (primitive_value -> value_array_slice .)
    GT              reduce using rule 71 (primitive_value -> value_array_slice .)
    GE              reduce using rule 71 (primitive_value -> value_array_slice .)
    LT              reduce using rule 71 (primitive_value -> value_array_slice .)
    LE              reduce using rule 71 (primitive_value -> value_array_slice .)
    PLUS            reduce using rule 71 (primitive_value -> value_array_slice .)
    MINUS           reduce using rule 71 (primitive_value -> value_array_slice .)
    TIMES           reduce using rule 71 (primitive_value -> value_array_slice .)
    DIVIDE          reduce using rule 71 (primitive_value -> value_array_slice .)
    MOD             reduce using rule 71 (primitive_value -> value_array_slice .)
    NOT             reduce using rule 71 (primitive_value -> value_array_slice .)
    IN              reduce using rule 71 (primitive_value -> value_array_slice .)
    CONCAT          reduce using rule 71 (primitive_value -> value_array_slice .)
    SEMI            reduce using rule 71 (primitive_value -> value_array_slice .)
    COMMA           reduce using rule 71 (primitive_value -> value_array_slice .)
    LBRACKET        reduce using rule 71 (primitive_value -> value_array_slice .)
    THEN            reduce using rule 71 (primitive_value -> value_array_slice .)
    RPAREN          reduce using rule 71 (primitive_value -> value_array_slice .)
    RBRACKET        reduce using rule 71 (primitive_value -> value_array_slice .)
    COLON           reduce using rule 71 (primitive_value -> value_array_slice .)
    ELSE            reduce using rule 71 (primitive_value -> value_array_slice .)
    ELSIF           reduce using rule 71 (primitive_value -> value_array_slice .)
    DOWN            reduce using rule 71 (primitive_value -> value_array_slice .)
    BY              reduce using rule 71 (primitive_value -> value_array_slice .)
    TO              reduce using rule 71 (primitive_value -> value_array_slice .)
    FI              reduce using rule 71 (primitive_value -> value_array_slice .)
    WHILE           reduce using rule 71 (primitive_value -> value_array_slice .)


state 60

    (84) expression -> conditional_expression .

    RPAREN          reduce using rule 84 (expression -> conditional_expression .)
    COMMA           reduce using rule 84 (expression -> conditional_expression .)
    SEMI            reduce using rule 84 (expression -> conditional_expression .)
    RBRACKET        reduce using rule 84 (expression -> conditional_expression .)
    THEN            reduce using rule 84 (expression -> conditional_expression .)
    DOWN            reduce using rule 84 (expression -> conditional_expression .)
    BY              reduce using rule 84 (expression -> conditional_expression .)
    TO              reduce using rule 84 (expression -> conditional_expression .)
    WHILE           reduce using rule 84 (expression -> conditional_expression .)
    FI              reduce using rule 84 (expression -> conditional_expression .)
    ELSE            reduce using rule 84 (expression -> conditional_expression .)
    ELSIF           reduce using rule 84 (expression -> conditional_expression .)
    COLON           reduce using rule 84 (expression -> conditional_expression .)


state 61

    (110) operand -> NOT . operand1
    (113) operand1 -> . location
    (114) operand1 -> . referenced_location
    (115) operand1 -> . primitive_value
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (116) referenced_location -> . ARROW location
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (17) identifier -> . ID
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (81) array_primitive_value -> . primitive_value
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    ARROW           shift and go to state 107
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55
    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    value_array_element            shift and go to state 51
    string_element                 shift and go to state 15
    operand1                       shift and go to state 129
    literal                        shift and go to state 49
    location                       shift and go to state 104
    call_action                    shift and go to state 105
    referenced_location            shift and go to state 106
    builtin_call                   shift and go to state 24
    array_primitive_value          shift and go to state 58
    parenthesized_expression       shift and go to state 44
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    value_array_slice              shift and go to state 59
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    identifier                     shift and go to state 108
    primitive_value                shift and go to state 109

state 62

    (112) operand -> identifier .

    AND             reduce using rule 112 (operand -> identifier .)
    OR              reduce using rule 112 (operand -> identifier .)
    EQ              reduce using rule 112 (operand -> identifier .)
    NEQ             reduce using rule 112 (operand -> identifier .)
    GT              reduce using rule 112 (operand -> identifier .)
    GE              reduce using rule 112 (operand -> identifier .)
    LT              reduce using rule 112 (operand -> identifier .)
    LE              reduce using rule 112 (operand -> identifier .)
    PLUS            reduce using rule 112 (operand -> identifier .)
    MINUS           reduce using rule 112 (operand -> identifier .)
    TIMES           reduce using rule 112 (operand -> identifier .)
    DIVIDE          reduce using rule 112 (operand -> identifier .)
    MOD             reduce using rule 112 (operand -> identifier .)
    NOT             reduce using rule 112 (operand -> identifier .)
    IN              reduce using rule 112 (operand -> identifier .)
    CONCAT          reduce using rule 112 (operand -> identifier .)
    RPAREN          reduce using rule 112 (operand -> identifier .)
    COMMA           reduce using rule 112 (operand -> identifier .)
    RBRACKET        reduce using rule 112 (operand -> identifier .)
    THEN            reduce using rule 112 (operand -> identifier .)
    SEMI            reduce using rule 112 (operand -> identifier .)
    COLON           reduce using rule 112 (operand -> identifier .)
    ELSE            reduce using rule 112 (operand -> identifier .)
    ELSIF           reduce using rule 112 (operand -> identifier .)
    DOWN            reduce using rule 112 (operand -> identifier .)
    BY              reduce using rule 112 (operand -> identifier .)
    TO              reduce using rule 112 (operand -> identifier .)
    FI              reduce using rule 112 (operand -> identifier .)
    WHILE           reduce using rule 112 (operand -> identifier .)


state 63

    (170) return_action -> RETURN expression .

    SEMI            reduce using rule 170 (return_action -> RETURN expression .)


state 64

    (111) operand -> primitive_value .
    (81) array_primitive_value -> primitive_value .

    AND             reduce using rule 111 (operand -> primitive_value .)
    OR              reduce using rule 111 (operand -> primitive_value .)
    EQ              reduce using rule 111 (operand -> primitive_value .)
    NEQ             reduce using rule 111 (operand -> primitive_value .)
    GT              reduce using rule 111 (operand -> primitive_value .)
    GE              reduce using rule 111 (operand -> primitive_value .)
    LT              reduce using rule 111 (operand -> primitive_value .)
    LE              reduce using rule 111 (operand -> primitive_value .)
    PLUS            reduce using rule 111 (operand -> primitive_value .)
    MINUS           reduce using rule 111 (operand -> primitive_value .)
    TIMES           reduce using rule 111 (operand -> primitive_value .)
    DIVIDE          reduce using rule 111 (operand -> primitive_value .)
    MOD             reduce using rule 111 (operand -> primitive_value .)
    NOT             reduce using rule 111 (operand -> primitive_value .)
    IN              reduce using rule 111 (operand -> primitive_value .)
    CONCAT          reduce using rule 111 (operand -> primitive_value .)
    RPAREN          reduce using rule 111 (operand -> primitive_value .)
    COMMA           reduce using rule 111 (operand -> primitive_value .)
    RBRACKET        reduce using rule 111 (operand -> primitive_value .)
    THEN            reduce using rule 111 (operand -> primitive_value .)
    SEMI            reduce using rule 111 (operand -> primitive_value .)
    COLON           reduce using rule 111 (operand -> primitive_value .)
    ELSE            reduce using rule 111 (operand -> primitive_value .)
    ELSIF           reduce using rule 111 (operand -> primitive_value .)
    DOWN            reduce using rule 111 (operand -> primitive_value .)
    BY              reduce using rule 111 (operand -> primitive_value .)
    TO              reduce using rule 111 (operand -> primitive_value .)
    FI              reduce using rule 111 (operand -> primitive_value .)
    WHILE           reduce using rule 111 (operand -> primitive_value .)
    LBRACKET        reduce using rule 81 (array_primitive_value -> primitive_value .)


state 65

    (162) while_control -> WHILE . boolean_expression
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    boolean_expression             shift and go to state 130
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 90
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 66

    (143) do_action -> DO control_part . SEMI action_statement OD
    (144) do_action -> DO control_part . SEMI OD

    SEMI            shift and go to state 131


state 67

    (146) control_part -> for_control . while_control
    (162) while_control -> . WHILE boolean_expression

    WHILE           shift and go to state 65

    while_control                  shift and go to state 132

state 68

    (148) for_control -> FOR . iteration
    (149) iteration -> . step_enumeration
    (150) iteration -> . range_enumeration
    (151) step_enumeration -> . loop_counter ASSIGN start_value step_value DOWN end_value
    (152) step_enumeration -> . loop_counter ASSIGN start_value DOWN end_value
    (153) step_enumeration -> . loop_counter ASSIGN start_value step_value end_value
    (154) step_enumeration -> . loop_counter ASSIGN start_value end_value
    (160) range_enumeration -> . loop_counter DOWN IN discrete_mode_name
    (161) range_enumeration -> . loop_counter IN discrete_mode_name
    (155) loop_counter -> . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    range_enumeration              shift and go to state 133
    loop_counter                   shift and go to state 134
    iteration                      shift and go to state 135
    step_enumeration               shift and go to state 136
    identifier                     shift and go to state 137

state 69

    (147) control_part -> while_control .

    SEMI            reduce using rule 147 (control_part -> while_control .)


state 70

    (117) action_statement -> identifier . COLON action SEMI
    (127) assignment_action -> identifier . assigning_operator expression
    (165) procedure_call -> identifier . LPAREN parameter_list RPAREN
    (166) procedure_call -> identifier . LPAREN RPAREN
    (63) string_element -> identifier . LBRACKET ICONST RBRACKET
    (64) string_slice -> identifier . LBRACKET ICONST COLON ICONST RBRACKET
    (128) assigning_operator -> . PLUS ASSIGN
    (129) assigning_operator -> . MINUS ASSIGN
    (130) assigning_operator -> . TIMES ASSIGN
    (131) assigning_operator -> . DIVIDE ASSIGN
    (132) assigning_operator -> . MOD ASSIGN
    (133) assigning_operator -> . CONCAT ASSIGN
    (134) assigning_operator -> . ASSIGN

    COLON           shift and go to state 138
    LPAREN          shift and go to state 102
    LBRACKET        shift and go to state 100
    PLUS            shift and go to state 80
    MINUS           shift and go to state 79
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 78
    MOD             shift and go to state 86
    CONCAT          shift and go to state 85
    ASSIGN          shift and go to state 84

    assigning_operator             shift and go to state 99

state 71

    (145) do_action -> DO action_statement . OD

    OD              shift and go to state 139


state 72

    (173) builtin_call -> builtin_name LPAREN . parameter_list RPAREN
    (174) builtin_call -> builtin_name LPAREN . RPAREN
    (167) parameter_list -> . expression
    (168) parameter_list -> . parameter_list COMMA expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    RPAREN          shift and go to state 140
    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parameter_list                 shift and go to state 141
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    parenthesized_expression       shift and go to state 44
    identifier                     shift and go to state 62
    expression                     shift and go to state 142
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 73

    (15) identifier_list -> identifier .

    COMMA           reduce using rule 15 (identifier_list -> identifier .)
    REF             reduce using rule 15 (identifier_list -> identifier .)
    ID              reduce using rule 15 (identifier_list -> identifier .)
    INT             reduce using rule 15 (identifier_list -> identifier .)
    BOOL            reduce using rule 15 (identifier_list -> identifier .)
    CHAR            reduce using rule 15 (identifier_list -> identifier .)
    CHARS           reduce using rule 15 (identifier_list -> identifier .)
    ARRAY           reduce using rule 15 (identifier_list -> identifier .)
    ASSIGN          reduce using rule 15 (identifier_list -> identifier .)


state 74

    (9) declaration_statement -> DCL declaration_list . SEMI
    (11) declaration_list -> declaration_list . COMMA declaration

    SEMI            shift and go to state 144
    COMMA           shift and go to state 143


state 75

    (10) declaration_list -> declaration .

    SEMI            reduce using rule 10 (declaration_list -> declaration .)
    COMMA           reduce using rule 10 (declaration_list -> declaration .)


state 76

    (12) declaration -> identifier_list . mode initialization
    (13) declaration -> identifier_list . mode
    (16) identifier_list -> identifier_list . COMMA identifier
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    COMMA           shift and go to state 154
    REF             shift and go to state 150
    ID              shift and go to state 31
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    CHARS           shift and go to state 158
    ARRAY           shift and go to state 155

    string_mode                    shift and go to state 152
    identifier                     shift and go to state 164
    array_mode                     shift and go to state 151
    discrete_range_mode            shift and go to state 157
    discrete_mode_name             shift and go to state 148
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    reference_mode                 shift and go to state 147
    composite_mode                 shift and go to state 161
    integer_mode                   shift and go to state 156
    mode                           shift and go to state 163
    discrete_mode                  shift and go to state 149
    mode_name                      shift and go to state 153

state 77

    (126) assignment_action -> location assigning_operator . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 165
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 78

    (131) assigning_operator -> DIVIDE . ASSIGN

    ASSIGN          shift and go to state 166


state 79

    (129) assigning_operator -> MINUS . ASSIGN

    ASSIGN          shift and go to state 167


state 80

    (128) assigning_operator -> PLUS . ASSIGN

    ASSIGN          shift and go to state 168


state 81

    (65) array_element -> location LBRACKET . expression_list RBRACKET
    (68) array_slice -> location LBRACKET . ICONST COLON ICONST RBRACKET
    (66) expression_list -> . expression
    (67) expression_list -> . expression_list COMMA expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    ICONST          shift and go to state 169
    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    expression_list                shift and go to state 170
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 171
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 82

    (62) dereferenced_reference -> location ARROW .

    ARROW           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    LBRACKET        reduce using rule 62 (dereferenced_reference -> location ARROW .)
    PLUS            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    MINUS           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    TIMES           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    DIVIDE          reduce using rule 62 (dereferenced_reference -> location ARROW .)
    MOD             reduce using rule 62 (dereferenced_reference -> location ARROW .)
    CONCAT          reduce using rule 62 (dereferenced_reference -> location ARROW .)
    ASSIGN          reduce using rule 62 (dereferenced_reference -> location ARROW .)
    AND             reduce using rule 62 (dereferenced_reference -> location ARROW .)
    OR              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    EQ              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    NEQ             reduce using rule 62 (dereferenced_reference -> location ARROW .)
    GT              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    GE              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    LT              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    LE              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    NOT             reduce using rule 62 (dereferenced_reference -> location ARROW .)
    IN              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    SEMI            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    THEN            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    RPAREN          reduce using rule 62 (dereferenced_reference -> location ARROW .)
    COMMA           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    RBRACKET        reduce using rule 62 (dereferenced_reference -> location ARROW .)
    COLON           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    ELSE            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    ELSIF           reduce using rule 62 (dereferenced_reference -> location ARROW .)
    DOWN            reduce using rule 62 (dereferenced_reference -> location ARROW .)
    BY              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    TO              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    FI              reduce using rule 62 (dereferenced_reference -> location ARROW .)
    WHILE           reduce using rule 62 (dereferenced_reference -> location ARROW .)


state 83

    (130) assigning_operator -> TIMES . ASSIGN

    ASSIGN          shift and go to state 172


state 84

    (134) assigning_operator -> ASSIGN .

    IF              reduce using rule 134 (assigning_operator -> ASSIGN .)
    MINUS           reduce using rule 134 (assigning_operator -> ASSIGN .)
    NOT             reduce using rule 134 (assigning_operator -> ASSIGN .)
    ID              reduce using rule 134 (assigning_operator -> ASSIGN .)
    ICONST          reduce using rule 134 (assigning_operator -> ASSIGN .)
    FALSE           reduce using rule 134 (assigning_operator -> ASSIGN .)
    TRUE            reduce using rule 134 (assigning_operator -> ASSIGN .)
    CCONST          reduce using rule 134 (assigning_operator -> ASSIGN .)
    NULL            reduce using rule 134 (assigning_operator -> ASSIGN .)
    SCONST          reduce using rule 134 (assigning_operator -> ASSIGN .)
    LPAREN          reduce using rule 134 (assigning_operator -> ASSIGN .)


state 85

    (133) assigning_operator -> CONCAT . ASSIGN

    ASSIGN          shift and go to state 173


state 86

    (132) assigning_operator -> MOD . ASSIGN

    ASSIGN          shift and go to state 174


state 87

    (3) statement_list -> statement_list statement .

    END             reduce using rule 3 (statement_list -> statement_list statement .)
    DCL             reduce using rule 3 (statement_list -> statement_list statement .)
    SYN             reduce using rule 3 (statement_list -> statement_list statement .)
    TYPE            reduce using rule 3 (statement_list -> statement_list statement .)
    ID              reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    DO              reduce using rule 3 (statement_list -> statement_list statement .)
    EXIT            reduce using rule 3 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 3 (statement_list -> statement_list statement .)
    RESULT          reduce using rule 3 (statement_list -> statement_list statement .)
    NUM             reduce using rule 3 (statement_list -> statement_list statement .)
    PRED            reduce using rule 3 (statement_list -> statement_list statement .)
    SUCC            reduce using rule 3 (statement_list -> statement_list statement .)
    UPPER           reduce using rule 3 (statement_list -> statement_list statement .)
    LOWER           reduce using rule 3 (statement_list -> statement_list statement .)
    LENGTH          reduce using rule 3 (statement_list -> statement_list statement .)
    READ            reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)


state 88

    (172) result_action -> RESULT expression .

    SEMI            reduce using rule 172 (result_action -> RESULT expression .)


state 89

    (135) if_action -> IF boolean_expression . then_clause else_clause FI
    (136) if_action -> IF boolean_expression . then_clause FI
    (137) then_clause -> . THEN action_statement
    (138) then_clause -> . THEN

    THEN            shift and go to state 175

    then_clause                    shift and go to state 176

state 90

    (87) boolean_expression -> expression .

    THEN            reduce using rule 87 (boolean_expression -> expression .)
    SEMI            reduce using rule 87 (boolean_expression -> expression .)


state 91

    (25) newmode_list -> mode_definition .

    COMMA           reduce using rule 25 (newmode_list -> mode_definition .)
    DCL             reduce using rule 25 (newmode_list -> mode_definition .)
    SYN             reduce using rule 25 (newmode_list -> mode_definition .)
    TYPE            reduce using rule 25 (newmode_list -> mode_definition .)
    ID              reduce using rule 25 (newmode_list -> mode_definition .)
    IF              reduce using rule 25 (newmode_list -> mode_definition .)
    DO              reduce using rule 25 (newmode_list -> mode_definition .)
    EXIT            reduce using rule 25 (newmode_list -> mode_definition .)
    RETURN          reduce using rule 25 (newmode_list -> mode_definition .)
    RESULT          reduce using rule 25 (newmode_list -> mode_definition .)
    NUM             reduce using rule 25 (newmode_list -> mode_definition .)
    PRED            reduce using rule 25 (newmode_list -> mode_definition .)
    SUCC            reduce using rule 25 (newmode_list -> mode_definition .)
    UPPER           reduce using rule 25 (newmode_list -> mode_definition .)
    LOWER           reduce using rule 25 (newmode_list -> mode_definition .)
    LENGTH          reduce using rule 25 (newmode_list -> mode_definition .)
    READ            reduce using rule 25 (newmode_list -> mode_definition .)
    PRINT           reduce using rule 25 (newmode_list -> mode_definition .)
    $end            reduce using rule 25 (newmode_list -> mode_definition .)
    END             reduce using rule 25 (newmode_list -> mode_definition .)


state 92

    (24) newmode_statement -> TYPE newmode_list .
    (26) newmode_list -> newmode_list . COMMA mode_definition

    DCL             reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    SYN             reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    TYPE            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    ID              reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    IF              reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    DO              reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    EXIT            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    RETURN          reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    RESULT          reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    NUM             reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    PRED            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    SUCC            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    UPPER           reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    LOWER           reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    LENGTH          reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    READ            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    PRINT           reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    $end            reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    END             reduce using rule 24 (newmode_statement -> TYPE newmode_list .)
    COMMA           shift and go to state 177


state 93

    (27) mode_definition -> identifier_list . mode
    (16) identifier_list -> identifier_list . COMMA identifier
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    COMMA           shift and go to state 154
    REF             shift and go to state 150
    ID              shift and go to state 31
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    CHARS           shift and go to state 158
    ARRAY           shift and go to state 155

    string_mode                    shift and go to state 152
    identifier                     shift and go to state 164
    array_mode                     shift and go to state 151
    discrete_range_mode            shift and go to state 157
    discrete_mode_name             shift and go to state 148
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    reference_mode                 shift and go to state 147
    composite_mode                 shift and go to state 161
    integer_mode                   shift and go to state 156
    mode                           shift and go to state 178
    discrete_mode                  shift and go to state 149
    mode_name                      shift and go to state 153

state 94

    (19) synonym_list -> synonym_definition .

    SEMI            reduce using rule 19 (synonym_list -> synonym_definition .)
    COMMA           reduce using rule 19 (synonym_list -> synonym_definition .)


state 95

    (18) synonym_statement -> SYN synonym_list . SEMI
    (20) synonym_list -> synonym_list . COMMA synonym_definition

    SEMI            shift and go to state 180
    COMMA           shift and go to state 179


state 96

    (21) synonym_definition -> identifier_list . mode ASSIGN constant_expression
    (22) synonym_definition -> identifier_list . ASSIGN constant_expression
    (16) identifier_list -> identifier_list . COMMA identifier
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    ASSIGN          shift and go to state 181
    COMMA           shift and go to state 154
    REF             shift and go to state 150
    ID              shift and go to state 31
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    CHARS           shift and go to state 158
    ARRAY           shift and go to state 155

    string_mode                    shift and go to state 152
    array_mode                     shift and go to state 151
    discrete_range_mode            shift and go to state 157
    discrete_mode_name             shift and go to state 148
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    reference_mode                 shift and go to state 147
    composite_mode                 shift and go to state 161
    integer_mode                   shift and go to state 156
    mode                           shift and go to state 182
    discrete_mode                  shift and go to state 149
    identifier                     shift and go to state 164
    mode_name                      shift and go to state 153

state 97

    (169) exit_action -> EXIT identifier .

    SEMI            reduce using rule 169 (exit_action -> EXIT identifier .)


state 98

    (118) action_statement -> action SEMI .

    OD              reduce using rule 118 (action_statement -> action SEMI .)
    END             reduce using rule 118 (action_statement -> action SEMI .)
    DCL             reduce using rule 118 (action_statement -> action SEMI .)
    SYN             reduce using rule 118 (action_statement -> action SEMI .)
    TYPE            reduce using rule 118 (action_statement -> action SEMI .)
    ID              reduce using rule 118 (action_statement -> action SEMI .)
    IF              reduce using rule 118 (action_statement -> action SEMI .)
    DO              reduce using rule 118 (action_statement -> action SEMI .)
    EXIT            reduce using rule 118 (action_statement -> action SEMI .)
    RETURN          reduce using rule 118 (action_statement -> action SEMI .)
    RESULT          reduce using rule 118 (action_statement -> action SEMI .)
    NUM             reduce using rule 118 (action_statement -> action SEMI .)
    PRED            reduce using rule 118 (action_statement -> action SEMI .)
    SUCC            reduce using rule 118 (action_statement -> action SEMI .)
    UPPER           reduce using rule 118 (action_statement -> action SEMI .)
    LOWER           reduce using rule 118 (action_statement -> action SEMI .)
    LENGTH          reduce using rule 118 (action_statement -> action SEMI .)
    READ            reduce using rule 118 (action_statement -> action SEMI .)
    PRINT           reduce using rule 118 (action_statement -> action SEMI .)
    FI              reduce using rule 118 (action_statement -> action SEMI .)
    ELSE            reduce using rule 118 (action_statement -> action SEMI .)
    ELSIF           reduce using rule 118 (action_statement -> action SEMI .)
    $end            reduce using rule 118 (action_statement -> action SEMI .)


state 99

    (127) assignment_action -> identifier assigning_operator . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 183
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 100

    (63) string_element -> identifier LBRACKET . ICONST RBRACKET
    (64) string_slice -> identifier LBRACKET . ICONST COLON ICONST RBRACKET

    ICONST          shift and go to state 184


state 101

    (183) procedure_statement -> identifier COLON . procedure_definition SEMI
    (117) action_statement -> identifier COLON . action SEMI
    (184) procedure_definition -> . PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END
    (185) procedure_definition -> . PROC LPAREN formal_parameter_list RPAREN SEMI statement_list END
    (186) procedure_definition -> . PROC LPAREN RPAREN SEMI statement_list END
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (17) identifier -> . ID
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    PROC            shift and go to state 188
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    action                         shift and go to state 185
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    procedure_definition           shift and go to state 186
    identifier                     shift and go to state 187

state 102

    (165) procedure_call -> identifier LPAREN . parameter_list RPAREN
    (166) procedure_call -> identifier LPAREN . RPAREN
    (167) parameter_list -> . expression
    (168) parameter_list -> . parameter_list COMMA expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    RPAREN          shift and go to state 189
    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parameter_list                 shift and go to state 190
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    parenthesized_expression       shift and go to state 44
    identifier                     shift and go to state 62
    expression                     shift and go to state 142
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 103

    (109) operand -> MINUS operand1 .

    AND             reduce using rule 109 (operand -> MINUS operand1 .)
    OR              reduce using rule 109 (operand -> MINUS operand1 .)
    EQ              reduce using rule 109 (operand -> MINUS operand1 .)
    NEQ             reduce using rule 109 (operand -> MINUS operand1 .)
    GT              reduce using rule 109 (operand -> MINUS operand1 .)
    GE              reduce using rule 109 (operand -> MINUS operand1 .)
    LT              reduce using rule 109 (operand -> MINUS operand1 .)
    LE              reduce using rule 109 (operand -> MINUS operand1 .)
    PLUS            reduce using rule 109 (operand -> MINUS operand1 .)
    MINUS           reduce using rule 109 (operand -> MINUS operand1 .)
    TIMES           reduce using rule 109 (operand -> MINUS operand1 .)
    DIVIDE          reduce using rule 109 (operand -> MINUS operand1 .)
    MOD             reduce using rule 109 (operand -> MINUS operand1 .)
    NOT             reduce using rule 109 (operand -> MINUS operand1 .)
    IN              reduce using rule 109 (operand -> MINUS operand1 .)
    CONCAT          reduce using rule 109 (operand -> MINUS operand1 .)
    RPAREN          reduce using rule 109 (operand -> MINUS operand1 .)
    COMMA           reduce using rule 109 (operand -> MINUS operand1 .)
    RBRACKET        reduce using rule 109 (operand -> MINUS operand1 .)
    THEN            reduce using rule 109 (operand -> MINUS operand1 .)
    SEMI            reduce using rule 109 (operand -> MINUS operand1 .)
    COLON           reduce using rule 109 (operand -> MINUS operand1 .)
    ELSE            reduce using rule 109 (operand -> MINUS operand1 .)
    ELSIF           reduce using rule 109 (operand -> MINUS operand1 .)
    DOWN            reduce using rule 109 (operand -> MINUS operand1 .)
    BY              reduce using rule 109 (operand -> MINUS operand1 .)
    TO              reduce using rule 109 (operand -> MINUS operand1 .)
    FI              reduce using rule 109 (operand -> MINUS operand1 .)
    WHILE           reduce using rule 109 (operand -> MINUS operand1 .)


state 104

    (113) operand1 -> location .
    (62) dereferenced_reference -> location . ARROW
    (65) array_element -> location . LBRACKET expression_list RBRACKET
    (68) array_slice -> location . LBRACKET ICONST COLON ICONST RBRACKET

    AND             reduce using rule 113 (operand1 -> location .)
    OR              reduce using rule 113 (operand1 -> location .)
    EQ              reduce using rule 113 (operand1 -> location .)
    NEQ             reduce using rule 113 (operand1 -> location .)
    GT              reduce using rule 113 (operand1 -> location .)
    GE              reduce using rule 113 (operand1 -> location .)
    LT              reduce using rule 113 (operand1 -> location .)
    LE              reduce using rule 113 (operand1 -> location .)
    PLUS            reduce using rule 113 (operand1 -> location .)
    MINUS           reduce using rule 113 (operand1 -> location .)
    TIMES           reduce using rule 113 (operand1 -> location .)
    DIVIDE          reduce using rule 113 (operand1 -> location .)
    MOD             reduce using rule 113 (operand1 -> location .)
    NOT             reduce using rule 113 (operand1 -> location .)
    IN              reduce using rule 113 (operand1 -> location .)
    CONCAT          reduce using rule 113 (operand1 -> location .)
    SEMI            reduce using rule 113 (operand1 -> location .)
    THEN            reduce using rule 113 (operand1 -> location .)
    RPAREN          reduce using rule 113 (operand1 -> location .)
    COMMA           reduce using rule 113 (operand1 -> location .)
    RBRACKET        reduce using rule 113 (operand1 -> location .)
    COLON           reduce using rule 113 (operand1 -> location .)
    ELSE            reduce using rule 113 (operand1 -> location .)
    ELSIF           reduce using rule 113 (operand1 -> location .)
    DOWN            reduce using rule 113 (operand1 -> location .)
    BY              reduce using rule 113 (operand1 -> location .)
    TO              reduce using rule 113 (operand1 -> location .)
    FI              reduce using rule 113 (operand1 -> location .)
    WHILE           reduce using rule 113 (operand1 -> location .)
    ARROW           shift and go to state 82
    LBRACKET        shift and go to state 81


state 105

    (61) location -> call_action .

    ARROW           reduce using rule 61 (location -> call_action .)
    LBRACKET        reduce using rule 61 (location -> call_action .)
    AND             reduce using rule 61 (location -> call_action .)
    OR              reduce using rule 61 (location -> call_action .)
    EQ              reduce using rule 61 (location -> call_action .)
    NEQ             reduce using rule 61 (location -> call_action .)
    GT              reduce using rule 61 (location -> call_action .)
    GE              reduce using rule 61 (location -> call_action .)
    LT              reduce using rule 61 (location -> call_action .)
    LE              reduce using rule 61 (location -> call_action .)
    PLUS            reduce using rule 61 (location -> call_action .)
    MINUS           reduce using rule 61 (location -> call_action .)
    TIMES           reduce using rule 61 (location -> call_action .)
    DIVIDE          reduce using rule 61 (location -> call_action .)
    MOD             reduce using rule 61 (location -> call_action .)
    NOT             reduce using rule 61 (location -> call_action .)
    IN              reduce using rule 61 (location -> call_action .)
    CONCAT          reduce using rule 61 (location -> call_action .)
    SEMI            reduce using rule 61 (location -> call_action .)
    THEN            reduce using rule 61 (location -> call_action .)
    RPAREN          reduce using rule 61 (location -> call_action .)
    COMMA           reduce using rule 61 (location -> call_action .)
    RBRACKET        reduce using rule 61 (location -> call_action .)
    COLON           reduce using rule 61 (location -> call_action .)
    ELSE            reduce using rule 61 (location -> call_action .)
    ELSIF           reduce using rule 61 (location -> call_action .)
    DOWN            reduce using rule 61 (location -> call_action .)
    BY              reduce using rule 61 (location -> call_action .)
    TO              reduce using rule 61 (location -> call_action .)
    FI              reduce using rule 61 (location -> call_action .)
    WHILE           reduce using rule 61 (location -> call_action .)


state 106

    (114) operand1 -> referenced_location .

    AND             reduce using rule 114 (operand1 -> referenced_location .)
    OR              reduce using rule 114 (operand1 -> referenced_location .)
    EQ              reduce using rule 114 (operand1 -> referenced_location .)
    NEQ             reduce using rule 114 (operand1 -> referenced_location .)
    GT              reduce using rule 114 (operand1 -> referenced_location .)
    GE              reduce using rule 114 (operand1 -> referenced_location .)
    LT              reduce using rule 114 (operand1 -> referenced_location .)
    LE              reduce using rule 114 (operand1 -> referenced_location .)
    PLUS            reduce using rule 114 (operand1 -> referenced_location .)
    MINUS           reduce using rule 114 (operand1 -> referenced_location .)
    TIMES           reduce using rule 114 (operand1 -> referenced_location .)
    DIVIDE          reduce using rule 114 (operand1 -> referenced_location .)
    MOD             reduce using rule 114 (operand1 -> referenced_location .)
    NOT             reduce using rule 114 (operand1 -> referenced_location .)
    IN              reduce using rule 114 (operand1 -> referenced_location .)
    CONCAT          reduce using rule 114 (operand1 -> referenced_location .)
    SEMI            reduce using rule 114 (operand1 -> referenced_location .)
    THEN            reduce using rule 114 (operand1 -> referenced_location .)
    RPAREN          reduce using rule 114 (operand1 -> referenced_location .)
    COMMA           reduce using rule 114 (operand1 -> referenced_location .)
    RBRACKET        reduce using rule 114 (operand1 -> referenced_location .)
    COLON           reduce using rule 114 (operand1 -> referenced_location .)
    ELSE            reduce using rule 114 (operand1 -> referenced_location .)
    ELSIF           reduce using rule 114 (operand1 -> referenced_location .)
    DOWN            reduce using rule 114 (operand1 -> referenced_location .)
    BY              reduce using rule 114 (operand1 -> referenced_location .)
    TO              reduce using rule 114 (operand1 -> referenced_location .)
    FI              reduce using rule 114 (operand1 -> referenced_location .)
    WHILE           reduce using rule 114 (operand1 -> referenced_location .)


state 107

    (116) referenced_location -> ARROW . location
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (17) identifier -> . ID
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    string_element                 shift and go to state 15
    dereferenced_reference         shift and go to state 34
    array_element                  shift and go to state 6
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    location                       shift and go to state 191
    call_action                    shift and go to state 105
    array_slice                    shift and go to state 39
    procedure_call                 shift and go to state 12
    identifier                     shift and go to state 108
    builtin_call                   shift and go to state 24

state 108

    (63) string_element -> identifier . LBRACKET ICONST RBRACKET
    (64) string_slice -> identifier . LBRACKET ICONST COLON ICONST RBRACKET
    (165) procedure_call -> identifier . LPAREN parameter_list RPAREN
    (166) procedure_call -> identifier . LPAREN RPAREN

    LBRACKET        shift and go to state 100
    LPAREN          shift and go to state 102


state 109

    (115) operand1 -> primitive_value .
    (81) array_primitive_value -> primitive_value .

    AND             reduce using rule 115 (operand1 -> primitive_value .)
    OR              reduce using rule 115 (operand1 -> primitive_value .)
    EQ              reduce using rule 115 (operand1 -> primitive_value .)
    NEQ             reduce using rule 115 (operand1 -> primitive_value .)
    GT              reduce using rule 115 (operand1 -> primitive_value .)
    GE              reduce using rule 115 (operand1 -> primitive_value .)
    LT              reduce using rule 115 (operand1 -> primitive_value .)
    LE              reduce using rule 115 (operand1 -> primitive_value .)
    PLUS            reduce using rule 115 (operand1 -> primitive_value .)
    MINUS           reduce using rule 115 (operand1 -> primitive_value .)
    TIMES           reduce using rule 115 (operand1 -> primitive_value .)
    DIVIDE          reduce using rule 115 (operand1 -> primitive_value .)
    MOD             reduce using rule 115 (operand1 -> primitive_value .)
    NOT             reduce using rule 115 (operand1 -> primitive_value .)
    IN              reduce using rule 115 (operand1 -> primitive_value .)
    CONCAT          reduce using rule 115 (operand1 -> primitive_value .)
    SEMI            reduce using rule 115 (operand1 -> primitive_value .)
    THEN            reduce using rule 115 (operand1 -> primitive_value .)
    RPAREN          reduce using rule 115 (operand1 -> primitive_value .)
    COMMA           reduce using rule 115 (operand1 -> primitive_value .)
    RBRACKET        reduce using rule 115 (operand1 -> primitive_value .)
    COLON           reduce using rule 115 (operand1 -> primitive_value .)
    ELSE            reduce using rule 115 (operand1 -> primitive_value .)
    ELSIF           reduce using rule 115 (operand1 -> primitive_value .)
    DOWN            reduce using rule 115 (operand1 -> primitive_value .)
    BY              reduce using rule 115 (operand1 -> primitive_value .)
    TO              reduce using rule 115 (operand1 -> primitive_value .)
    FI              reduce using rule 115 (operand1 -> primitive_value .)
    WHILE           reduce using rule 115 (operand1 -> primitive_value .)
    LBRACKET        reduce using rule 81 (array_primitive_value -> primitive_value .)


state 110

    (93) binop -> binop AND . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 192
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 111

    (97) binop -> binop GT . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 193
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 112

    (104) binop -> binop DIVIDE . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 194
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 113

    (99) binop -> binop LT . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 195
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 114

    (102) binop -> binop MINUS . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 196
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 115

    (98) binop -> binop GE . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 197
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 116

    (100) binop -> binop LE . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 198
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 117

    (101) binop -> binop PLUS . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 199
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 118

    (105) binop -> binop MOD . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 200
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 119

    (107) binop -> binop IN . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 201
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 120

    (106) binop -> binop NOT . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 202
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 121

    (103) binop -> binop TIMES . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 203
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 122

    (95) binop -> binop EQ . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 204
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 123

    (94) binop -> binop OR . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 205
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 124

    (108) binop -> binop CONCAT . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 206
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 125

    (96) binop -> binop NEQ . binop
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 207
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 126

    (82) parenthesized_expression -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 208


state 127

    (85) conditional_expression -> IF boolean_expression . then_expression else_expression FI
    (86) conditional_expression -> IF boolean_expression . then_expression elsif_expression else_expression FI
    (88) then_expression -> . THEN expression

    THEN            shift and go to state 209

    then_expression                shift and go to state 210

state 128

    (79) value_array_element -> array_primitive_value LBRACKET . expression_list RBRACKET
    (80) value_array_slice -> array_primitive_value LBRACKET . expression COLON expression RBRACKET
    (66) expression_list -> . expression
    (67) expression_list -> . expression_list COMMA expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    expression_list                shift and go to state 211
    literal                        shift and go to state 49
    array_primitive_value          shift and go to state 58
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 212
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 129

    (110) operand -> NOT operand1 .

    AND             reduce using rule 110 (operand -> NOT operand1 .)
    OR              reduce using rule 110 (operand -> NOT operand1 .)
    EQ              reduce using rule 110 (operand -> NOT operand1 .)
    NEQ             reduce using rule 110 (operand -> NOT operand1 .)
    GT              reduce using rule 110 (operand -> NOT operand1 .)
    GE              reduce using rule 110 (operand -> NOT operand1 .)
    LT              reduce using rule 110 (operand -> NOT operand1 .)
    LE              reduce using rule 110 (operand -> NOT operand1 .)
    PLUS            reduce using rule 110 (operand -> NOT operand1 .)
    MINUS           reduce using rule 110 (operand -> NOT operand1 .)
    TIMES           reduce using rule 110 (operand -> NOT operand1 .)
    DIVIDE          reduce using rule 110 (operand -> NOT operand1 .)
    MOD             reduce using rule 110 (operand -> NOT operand1 .)
    NOT             reduce using rule 110 (operand -> NOT operand1 .)
    IN              reduce using rule 110 (operand -> NOT operand1 .)
    CONCAT          reduce using rule 110 (operand -> NOT operand1 .)
    RPAREN          reduce using rule 110 (operand -> NOT operand1 .)
    COMMA           reduce using rule 110 (operand -> NOT operand1 .)
    RBRACKET        reduce using rule 110 (operand -> NOT operand1 .)
    THEN            reduce using rule 110 (operand -> NOT operand1 .)
    SEMI            reduce using rule 110 (operand -> NOT operand1 .)
    COLON           reduce using rule 110 (operand -> NOT operand1 .)
    ELSE            reduce using rule 110 (operand -> NOT operand1 .)
    ELSIF           reduce using rule 110 (operand -> NOT operand1 .)
    DOWN            reduce using rule 110 (operand -> NOT operand1 .)
    BY              reduce using rule 110 (operand -> NOT operand1 .)
    TO              reduce using rule 110 (operand -> NOT operand1 .)
    FI              reduce using rule 110 (operand -> NOT operand1 .)
    WHILE           reduce using rule 110 (operand -> NOT operand1 .)


state 130

    (162) while_control -> WHILE boolean_expression .

    SEMI            reduce using rule 162 (while_control -> WHILE boolean_expression .)


state 131

    (143) do_action -> DO control_part SEMI . action_statement OD
    (144) do_action -> DO control_part SEMI . OD
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    OD              shift and go to state 213
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 214
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 70

state 132

    (146) control_part -> for_control while_control .

    SEMI            reduce using rule 146 (control_part -> for_control while_control .)


state 133

    (150) iteration -> range_enumeration .

    WHILE           reduce using rule 150 (iteration -> range_enumeration .)


state 134

    (151) step_enumeration -> loop_counter . ASSIGN start_value step_value DOWN end_value
    (152) step_enumeration -> loop_counter . ASSIGN start_value DOWN end_value
    (153) step_enumeration -> loop_counter . ASSIGN start_value step_value end_value
    (154) step_enumeration -> loop_counter . ASSIGN start_value end_value
    (160) range_enumeration -> loop_counter . DOWN IN discrete_mode_name
    (161) range_enumeration -> loop_counter . IN discrete_mode_name

    ASSIGN          shift and go to state 217
    DOWN            shift and go to state 215
    IN              shift and go to state 216


state 135

    (148) for_control -> FOR iteration .

    WHILE           reduce using rule 148 (for_control -> FOR iteration .)


state 136

    (149) iteration -> step_enumeration .

    WHILE           reduce using rule 149 (iteration -> step_enumeration .)


state 137

    (155) loop_counter -> identifier .

    ASSIGN          reduce using rule 155 (loop_counter -> identifier .)
    DOWN            reduce using rule 155 (loop_counter -> identifier .)
    IN              reduce using rule 155 (loop_counter -> identifier .)


state 138

    (117) action_statement -> identifier COLON . action SEMI
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (17) identifier -> . ID
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    ID              shift and go to state 31
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 185
    identifier                     shift and go to state 187

state 139

    (145) do_action -> DO action_statement OD .

    SEMI            reduce using rule 145 (do_action -> DO action_statement OD .)


state 140

    (174) builtin_call -> builtin_name LPAREN RPAREN .

    SEMI            reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    ARROW           reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    LBRACKET        reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    PLUS            reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    MINUS           reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    TIMES           reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    DIVIDE          reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    MOD             reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    CONCAT          reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    ASSIGN          reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    AND             reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    OR              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    EQ              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    NEQ             reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    GT              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    GE              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    LT              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    LE              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    NOT             reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    IN              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    THEN            reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    RPAREN          reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    COMMA           reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    RBRACKET        reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    COLON           reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    ELSE            reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    ELSIF           reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    DOWN            reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    BY              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    TO              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    FI              reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)
    WHILE           reduce using rule 174 (builtin_call -> builtin_name LPAREN RPAREN .)


state 141

    (173) builtin_call -> builtin_name LPAREN parameter_list . RPAREN
    (168) parameter_list -> parameter_list . COMMA expression

    RPAREN          shift and go to state 218
    COMMA           shift and go to state 219


state 142

    (167) parameter_list -> expression .

    RPAREN          reduce using rule 167 (parameter_list -> expression .)
    COMMA           reduce using rule 167 (parameter_list -> expression .)


state 143

    (11) declaration_list -> declaration_list COMMA . declaration
    (12) declaration -> . identifier_list mode initialization
    (13) declaration -> . identifier_list mode
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier_list                shift and go to state 76
    declaration                    shift and go to state 220
    identifier                     shift and go to state 73

state 144

    (9) declaration_statement -> DCL declaration_list SEMI .

    END             reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    DCL             reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    SYN             reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    TYPE            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    ID              reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    IF              reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    DO              reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    EXIT            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    RETURN          reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    RESULT          reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    NUM             reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    PRED            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    SUCC            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    UPPER           reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    LOWER           reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    LENGTH          reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    READ            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    PRINT           reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)
    $end            reduce using rule 9 (declaration_statement -> DCL declaration_list SEMI .)


state 145

    (33) discrete_mode -> boolean_mode .

    LPAREN          reduce using rule 33 (discrete_mode -> boolean_mode .)
    ASSIGN          reduce using rule 33 (discrete_mode -> boolean_mode .)
    SEMI            reduce using rule 33 (discrete_mode -> boolean_mode .)
    COMMA           reduce using rule 33 (discrete_mode -> boolean_mode .)
    DCL             reduce using rule 33 (discrete_mode -> boolean_mode .)
    SYN             reduce using rule 33 (discrete_mode -> boolean_mode .)
    TYPE            reduce using rule 33 (discrete_mode -> boolean_mode .)
    ID              reduce using rule 33 (discrete_mode -> boolean_mode .)
    IF              reduce using rule 33 (discrete_mode -> boolean_mode .)
    DO              reduce using rule 33 (discrete_mode -> boolean_mode .)
    EXIT            reduce using rule 33 (discrete_mode -> boolean_mode .)
    RETURN          reduce using rule 33 (discrete_mode -> boolean_mode .)
    RESULT          reduce using rule 33 (discrete_mode -> boolean_mode .)
    NUM             reduce using rule 33 (discrete_mode -> boolean_mode .)
    PRED            reduce using rule 33 (discrete_mode -> boolean_mode .)
    SUCC            reduce using rule 33 (discrete_mode -> boolean_mode .)
    UPPER           reduce using rule 33 (discrete_mode -> boolean_mode .)
    LOWER           reduce using rule 33 (discrete_mode -> boolean_mode .)
    LENGTH          reduce using rule 33 (discrete_mode -> boolean_mode .)
    READ            reduce using rule 33 (discrete_mode -> boolean_mode .)
    PRINT           reduce using rule 33 (discrete_mode -> boolean_mode .)
    $end            reduce using rule 33 (discrete_mode -> boolean_mode .)
    END             reduce using rule 33 (discrete_mode -> boolean_mode .)
    LOC             reduce using rule 33 (discrete_mode -> boolean_mode .)
    RPAREN          reduce using rule 33 (discrete_mode -> boolean_mode .)
    RBRACKET        reduce using rule 33 (discrete_mode -> boolean_mode .)


state 146

    (38) character_mode -> CHAR .

    LPAREN          reduce using rule 38 (character_mode -> CHAR .)
    RBRACKET        reduce using rule 38 (character_mode -> CHAR .)
    COMMA           reduce using rule 38 (character_mode -> CHAR .)
    LOC             reduce using rule 38 (character_mode -> CHAR .)
    RPAREN          reduce using rule 38 (character_mode -> CHAR .)
    ASSIGN          reduce using rule 38 (character_mode -> CHAR .)
    SEMI            reduce using rule 38 (character_mode -> CHAR .)
    DCL             reduce using rule 38 (character_mode -> CHAR .)
    SYN             reduce using rule 38 (character_mode -> CHAR .)
    TYPE            reduce using rule 38 (character_mode -> CHAR .)
    ID              reduce using rule 38 (character_mode -> CHAR .)
    IF              reduce using rule 38 (character_mode -> CHAR .)
    DO              reduce using rule 38 (character_mode -> CHAR .)
    EXIT            reduce using rule 38 (character_mode -> CHAR .)
    RETURN          reduce using rule 38 (character_mode -> CHAR .)
    RESULT          reduce using rule 38 (character_mode -> CHAR .)
    NUM             reduce using rule 38 (character_mode -> CHAR .)
    PRED            reduce using rule 38 (character_mode -> CHAR .)
    SUCC            reduce using rule 38 (character_mode -> CHAR .)
    UPPER           reduce using rule 38 (character_mode -> CHAR .)
    LOWER           reduce using rule 38 (character_mode -> CHAR .)
    LENGTH          reduce using rule 38 (character_mode -> CHAR .)
    READ            reduce using rule 38 (character_mode -> CHAR .)
    PRINT           reduce using rule 38 (character_mode -> CHAR .)
    $end            reduce using rule 38 (character_mode -> CHAR .)
    END             reduce using rule 38 (character_mode -> CHAR .)


state 147

    (30) mode -> reference_mode .

    ASSIGN          reduce using rule 30 (mode -> reference_mode .)
    SEMI            reduce using rule 30 (mode -> reference_mode .)
    COMMA           reduce using rule 30 (mode -> reference_mode .)
    DCL             reduce using rule 30 (mode -> reference_mode .)
    SYN             reduce using rule 30 (mode -> reference_mode .)
    TYPE            reduce using rule 30 (mode -> reference_mode .)
    ID              reduce using rule 30 (mode -> reference_mode .)
    IF              reduce using rule 30 (mode -> reference_mode .)
    DO              reduce using rule 30 (mode -> reference_mode .)
    EXIT            reduce using rule 30 (mode -> reference_mode .)
    RETURN          reduce using rule 30 (mode -> reference_mode .)
    RESULT          reduce using rule 30 (mode -> reference_mode .)
    NUM             reduce using rule 30 (mode -> reference_mode .)
    PRED            reduce using rule 30 (mode -> reference_mode .)
    SUCC            reduce using rule 30 (mode -> reference_mode .)
    UPPER           reduce using rule 30 (mode -> reference_mode .)
    LOWER           reduce using rule 30 (mode -> reference_mode .)
    LENGTH          reduce using rule 30 (mode -> reference_mode .)
    READ            reduce using rule 30 (mode -> reference_mode .)
    PRINT           reduce using rule 30 (mode -> reference_mode .)
    $end            reduce using rule 30 (mode -> reference_mode .)
    END             reduce using rule 30 (mode -> reference_mode .)
    LOC             reduce using rule 30 (mode -> reference_mode .)
    RPAREN          reduce using rule 30 (mode -> reference_mode .)


state 148

    (39) discrete_range_mode -> discrete_mode_name . LPAREN literal_range RPAREN

    LPAREN          shift and go to state 221


state 149

    (29) mode -> discrete_mode .
    (40) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    ASSIGN          reduce using rule 29 (mode -> discrete_mode .)
    SEMI            reduce using rule 29 (mode -> discrete_mode .)
    COMMA           reduce using rule 29 (mode -> discrete_mode .)
    DCL             reduce using rule 29 (mode -> discrete_mode .)
    SYN             reduce using rule 29 (mode -> discrete_mode .)
    TYPE            reduce using rule 29 (mode -> discrete_mode .)
    ID              reduce using rule 29 (mode -> discrete_mode .)
    IF              reduce using rule 29 (mode -> discrete_mode .)
    DO              reduce using rule 29 (mode -> discrete_mode .)
    EXIT            reduce using rule 29 (mode -> discrete_mode .)
    RETURN          reduce using rule 29 (mode -> discrete_mode .)
    RESULT          reduce using rule 29 (mode -> discrete_mode .)
    NUM             reduce using rule 29 (mode -> discrete_mode .)
    PRED            reduce using rule 29 (mode -> discrete_mode .)
    SUCC            reduce using rule 29 (mode -> discrete_mode .)
    UPPER           reduce using rule 29 (mode -> discrete_mode .)
    LOWER           reduce using rule 29 (mode -> discrete_mode .)
    LENGTH          reduce using rule 29 (mode -> discrete_mode .)
    READ            reduce using rule 29 (mode -> discrete_mode .)
    PRINT           reduce using rule 29 (mode -> discrete_mode .)
    $end            reduce using rule 29 (mode -> discrete_mode .)
    END             reduce using rule 29 (mode -> discrete_mode .)
    LOC             reduce using rule 29 (mode -> discrete_mode .)
    RPAREN          reduce using rule 29 (mode -> discrete_mode .)
    LPAREN          shift and go to state 222


state 150

    (44) reference_mode -> REF . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    REF             shift and go to state 150
    ID              shift and go to state 31
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    CHARS           shift and go to state 158
    ARRAY           shift and go to state 155

    string_mode                    shift and go to state 152
    array_mode                     shift and go to state 151
    discrete_range_mode            shift and go to state 157
    discrete_mode_name             shift and go to state 148
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    reference_mode                 shift and go to state 147
    composite_mode                 shift and go to state 161
    integer_mode                   shift and go to state 156
    mode                           shift and go to state 223
    discrete_mode                  shift and go to state 149
    identifier                     shift and go to state 164
    mode_name                      shift and go to state 153

state 151

    (46) composite_mode -> array_mode .

    ASSIGN          reduce using rule 46 (composite_mode -> array_mode .)
    SEMI            reduce using rule 46 (composite_mode -> array_mode .)
    COMMA           reduce using rule 46 (composite_mode -> array_mode .)
    DCL             reduce using rule 46 (composite_mode -> array_mode .)
    SYN             reduce using rule 46 (composite_mode -> array_mode .)
    TYPE            reduce using rule 46 (composite_mode -> array_mode .)
    ID              reduce using rule 46 (composite_mode -> array_mode .)
    IF              reduce using rule 46 (composite_mode -> array_mode .)
    DO              reduce using rule 46 (composite_mode -> array_mode .)
    EXIT            reduce using rule 46 (composite_mode -> array_mode .)
    RETURN          reduce using rule 46 (composite_mode -> array_mode .)
    RESULT          reduce using rule 46 (composite_mode -> array_mode .)
    NUM             reduce using rule 46 (composite_mode -> array_mode .)
    PRED            reduce using rule 46 (composite_mode -> array_mode .)
    SUCC            reduce using rule 46 (composite_mode -> array_mode .)
    UPPER           reduce using rule 46 (composite_mode -> array_mode .)
    LOWER           reduce using rule 46 (composite_mode -> array_mode .)
    LENGTH          reduce using rule 46 (composite_mode -> array_mode .)
    READ            reduce using rule 46 (composite_mode -> array_mode .)
    PRINT           reduce using rule 46 (composite_mode -> array_mode .)
    $end            reduce using rule 46 (composite_mode -> array_mode .)
    END             reduce using rule 46 (composite_mode -> array_mode .)
    LOC             reduce using rule 46 (composite_mode -> array_mode .)
    RPAREN          reduce using rule 46 (composite_mode -> array_mode .)


state 152

    (45) composite_mode -> string_mode .

    ASSIGN          reduce using rule 45 (composite_mode -> string_mode .)
    SEMI            reduce using rule 45 (composite_mode -> string_mode .)
    COMMA           reduce using rule 45 (composite_mode -> string_mode .)
    DCL             reduce using rule 45 (composite_mode -> string_mode .)
    SYN             reduce using rule 45 (composite_mode -> string_mode .)
    TYPE            reduce using rule 45 (composite_mode -> string_mode .)
    ID              reduce using rule 45 (composite_mode -> string_mode .)
    IF              reduce using rule 45 (composite_mode -> string_mode .)
    DO              reduce using rule 45 (composite_mode -> string_mode .)
    EXIT            reduce using rule 45 (composite_mode -> string_mode .)
    RETURN          reduce using rule 45 (composite_mode -> string_mode .)
    RESULT          reduce using rule 45 (composite_mode -> string_mode .)
    NUM             reduce using rule 45 (composite_mode -> string_mode .)
    PRED            reduce using rule 45 (composite_mode -> string_mode .)
    SUCC            reduce using rule 45 (composite_mode -> string_mode .)
    UPPER           reduce using rule 45 (composite_mode -> string_mode .)
    LOWER           reduce using rule 45 (composite_mode -> string_mode .)
    LENGTH          reduce using rule 45 (composite_mode -> string_mode .)
    READ            reduce using rule 45 (composite_mode -> string_mode .)
    PRINT           reduce using rule 45 (composite_mode -> string_mode .)
    $end            reduce using rule 45 (composite_mode -> string_mode .)
    END             reduce using rule 45 (composite_mode -> string_mode .)
    LOC             reduce using rule 45 (composite_mode -> string_mode .)
    RPAREN          reduce using rule 45 (composite_mode -> string_mode .)


state 153

    (28) mode -> mode_name .

    ASSIGN          reduce using rule 28 (mode -> mode_name .)
    SEMI            reduce using rule 28 (mode -> mode_name .)
    COMMA           reduce using rule 28 (mode -> mode_name .)
    DCL             reduce using rule 28 (mode -> mode_name .)
    SYN             reduce using rule 28 (mode -> mode_name .)
    TYPE            reduce using rule 28 (mode -> mode_name .)
    ID              reduce using rule 28 (mode -> mode_name .)
    IF              reduce using rule 28 (mode -> mode_name .)
    DO              reduce using rule 28 (mode -> mode_name .)
    EXIT            reduce using rule 28 (mode -> mode_name .)
    RETURN          reduce using rule 28 (mode -> mode_name .)
    RESULT          reduce using rule 28 (mode -> mode_name .)
    NUM             reduce using rule 28 (mode -> mode_name .)
    PRED            reduce using rule 28 (mode -> mode_name .)
    SUCC            reduce using rule 28 (mode -> mode_name .)
    UPPER           reduce using rule 28 (mode -> mode_name .)
    LOWER           reduce using rule 28 (mode -> mode_name .)
    LENGTH          reduce using rule 28 (mode -> mode_name .)
    READ            reduce using rule 28 (mode -> mode_name .)
    PRINT           reduce using rule 28 (mode -> mode_name .)
    $end            reduce using rule 28 (mode -> mode_name .)
    END             reduce using rule 28 (mode -> mode_name .)
    LOC             reduce using rule 28 (mode -> mode_name .)
    RPAREN          reduce using rule 28 (mode -> mode_name .)


state 154

    (16) identifier_list -> identifier_list COMMA . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier                     shift and go to state 224

state 155

    (49) array_mode -> ARRAY . LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> ARRAY . LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode

    LBRACKET        shift and go to state 225


state 156

    (32) discrete_mode -> integer_mode .

    LPAREN          reduce using rule 32 (discrete_mode -> integer_mode .)
    ASSIGN          reduce using rule 32 (discrete_mode -> integer_mode .)
    SEMI            reduce using rule 32 (discrete_mode -> integer_mode .)
    COMMA           reduce using rule 32 (discrete_mode -> integer_mode .)
    DCL             reduce using rule 32 (discrete_mode -> integer_mode .)
    SYN             reduce using rule 32 (discrete_mode -> integer_mode .)
    TYPE            reduce using rule 32 (discrete_mode -> integer_mode .)
    ID              reduce using rule 32 (discrete_mode -> integer_mode .)
    IF              reduce using rule 32 (discrete_mode -> integer_mode .)
    DO              reduce using rule 32 (discrete_mode -> integer_mode .)
    EXIT            reduce using rule 32 (discrete_mode -> integer_mode .)
    RETURN          reduce using rule 32 (discrete_mode -> integer_mode .)
    RESULT          reduce using rule 32 (discrete_mode -> integer_mode .)
    NUM             reduce using rule 32 (discrete_mode -> integer_mode .)
    PRED            reduce using rule 32 (discrete_mode -> integer_mode .)
    SUCC            reduce using rule 32 (discrete_mode -> integer_mode .)
    UPPER           reduce using rule 32 (discrete_mode -> integer_mode .)
    LOWER           reduce using rule 32 (discrete_mode -> integer_mode .)
    LENGTH          reduce using rule 32 (discrete_mode -> integer_mode .)
    READ            reduce using rule 32 (discrete_mode -> integer_mode .)
    PRINT           reduce using rule 32 (discrete_mode -> integer_mode .)
    $end            reduce using rule 32 (discrete_mode -> integer_mode .)
    END             reduce using rule 32 (discrete_mode -> integer_mode .)
    LOC             reduce using rule 32 (discrete_mode -> integer_mode .)
    RPAREN          reduce using rule 32 (discrete_mode -> integer_mode .)
    RBRACKET        reduce using rule 32 (discrete_mode -> integer_mode .)


state 157

    (35) discrete_mode -> discrete_range_mode .

    LPAREN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    ASSIGN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    SEMI            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    COMMA           reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    DCL             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    SYN             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    TYPE            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    ID              reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    IF              reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    DO              reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    EXIT            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    RETURN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    RESULT          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    NUM             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    PRED            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    SUCC            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    UPPER           reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    LOWER           reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    LENGTH          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    READ            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    PRINT           reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    $end            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    END             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    LOC             reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    RPAREN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    RBRACKET        reduce using rule 35 (discrete_mode -> discrete_range_mode .)


state 158

    (47) string_mode -> CHARS . LBRACKET string_length RBRACKET

    LBRACKET        shift and go to state 226


state 159

    (34) discrete_mode -> character_mode .

    LPAREN          reduce using rule 34 (discrete_mode -> character_mode .)
    ASSIGN          reduce using rule 34 (discrete_mode -> character_mode .)
    SEMI            reduce using rule 34 (discrete_mode -> character_mode .)
    COMMA           reduce using rule 34 (discrete_mode -> character_mode .)
    DCL             reduce using rule 34 (discrete_mode -> character_mode .)
    SYN             reduce using rule 34 (discrete_mode -> character_mode .)
    TYPE            reduce using rule 34 (discrete_mode -> character_mode .)
    ID              reduce using rule 34 (discrete_mode -> character_mode .)
    IF              reduce using rule 34 (discrete_mode -> character_mode .)
    DO              reduce using rule 34 (discrete_mode -> character_mode .)
    EXIT            reduce using rule 34 (discrete_mode -> character_mode .)
    RETURN          reduce using rule 34 (discrete_mode -> character_mode .)
    RESULT          reduce using rule 34 (discrete_mode -> character_mode .)
    NUM             reduce using rule 34 (discrete_mode -> character_mode .)
    PRED            reduce using rule 34 (discrete_mode -> character_mode .)
    SUCC            reduce using rule 34 (discrete_mode -> character_mode .)
    UPPER           reduce using rule 34 (discrete_mode -> character_mode .)
    LOWER           reduce using rule 34 (discrete_mode -> character_mode .)
    LENGTH          reduce using rule 34 (discrete_mode -> character_mode .)
    READ            reduce using rule 34 (discrete_mode -> character_mode .)
    PRINT           reduce using rule 34 (discrete_mode -> character_mode .)
    $end            reduce using rule 34 (discrete_mode -> character_mode .)
    END             reduce using rule 34 (discrete_mode -> character_mode .)
    LOC             reduce using rule 34 (discrete_mode -> character_mode .)
    RPAREN          reduce using rule 34 (discrete_mode -> character_mode .)
    RBRACKET        reduce using rule 34 (discrete_mode -> character_mode .)


state 160

    (36) integer_mode -> INT .

    LPAREN          reduce using rule 36 (integer_mode -> INT .)
    ASSIGN          reduce using rule 36 (integer_mode -> INT .)
    SEMI            reduce using rule 36 (integer_mode -> INT .)
    COMMA           reduce using rule 36 (integer_mode -> INT .)
    RBRACKET        reduce using rule 36 (integer_mode -> INT .)
    LOC             reduce using rule 36 (integer_mode -> INT .)
    RPAREN          reduce using rule 36 (integer_mode -> INT .)
    DCL             reduce using rule 36 (integer_mode -> INT .)
    SYN             reduce using rule 36 (integer_mode -> INT .)
    TYPE            reduce using rule 36 (integer_mode -> INT .)
    ID              reduce using rule 36 (integer_mode -> INT .)
    IF              reduce using rule 36 (integer_mode -> INT .)
    DO              reduce using rule 36 (integer_mode -> INT .)
    EXIT            reduce using rule 36 (integer_mode -> INT .)
    RETURN          reduce using rule 36 (integer_mode -> INT .)
    RESULT          reduce using rule 36 (integer_mode -> INT .)
    NUM             reduce using rule 36 (integer_mode -> INT .)
    PRED            reduce using rule 36 (integer_mode -> INT .)
    SUCC            reduce using rule 36 (integer_mode -> INT .)
    UPPER           reduce using rule 36 (integer_mode -> INT .)
    LOWER           reduce using rule 36 (integer_mode -> INT .)
    LENGTH          reduce using rule 36 (integer_mode -> INT .)
    READ            reduce using rule 36 (integer_mode -> INT .)
    PRINT           reduce using rule 36 (integer_mode -> INT .)
    $end            reduce using rule 36 (integer_mode -> INT .)
    END             reduce using rule 36 (integer_mode -> INT .)


state 161

    (31) mode -> composite_mode .

    ASSIGN          reduce using rule 31 (mode -> composite_mode .)
    SEMI            reduce using rule 31 (mode -> composite_mode .)
    COMMA           reduce using rule 31 (mode -> composite_mode .)
    DCL             reduce using rule 31 (mode -> composite_mode .)
    SYN             reduce using rule 31 (mode -> composite_mode .)
    TYPE            reduce using rule 31 (mode -> composite_mode .)
    ID              reduce using rule 31 (mode -> composite_mode .)
    IF              reduce using rule 31 (mode -> composite_mode .)
    DO              reduce using rule 31 (mode -> composite_mode .)
    EXIT            reduce using rule 31 (mode -> composite_mode .)
    RETURN          reduce using rule 31 (mode -> composite_mode .)
    RESULT          reduce using rule 31 (mode -> composite_mode .)
    NUM             reduce using rule 31 (mode -> composite_mode .)
    PRED            reduce using rule 31 (mode -> composite_mode .)
    SUCC            reduce using rule 31 (mode -> composite_mode .)
    UPPER           reduce using rule 31 (mode -> composite_mode .)
    LOWER           reduce using rule 31 (mode -> composite_mode .)
    LENGTH          reduce using rule 31 (mode -> composite_mode .)
    READ            reduce using rule 31 (mode -> composite_mode .)
    PRINT           reduce using rule 31 (mode -> composite_mode .)
    $end            reduce using rule 31 (mode -> composite_mode .)
    END             reduce using rule 31 (mode -> composite_mode .)
    LOC             reduce using rule 31 (mode -> composite_mode .)
    RPAREN          reduce using rule 31 (mode -> composite_mode .)


state 162

    (37) boolean_mode -> BOOL .

    LPAREN          reduce using rule 37 (boolean_mode -> BOOL .)
    ASSIGN          reduce using rule 37 (boolean_mode -> BOOL .)
    SEMI            reduce using rule 37 (boolean_mode -> BOOL .)
    COMMA           reduce using rule 37 (boolean_mode -> BOOL .)
    DCL             reduce using rule 37 (boolean_mode -> BOOL .)
    SYN             reduce using rule 37 (boolean_mode -> BOOL .)
    TYPE            reduce using rule 37 (boolean_mode -> BOOL .)
    ID              reduce using rule 37 (boolean_mode -> BOOL .)
    IF              reduce using rule 37 (boolean_mode -> BOOL .)
    DO              reduce using rule 37 (boolean_mode -> BOOL .)
    EXIT            reduce using rule 37 (boolean_mode -> BOOL .)
    RETURN          reduce using rule 37 (boolean_mode -> BOOL .)
    RESULT          reduce using rule 37 (boolean_mode -> BOOL .)
    NUM             reduce using rule 37 (boolean_mode -> BOOL .)
    PRED            reduce using rule 37 (boolean_mode -> BOOL .)
    SUCC            reduce using rule 37 (boolean_mode -> BOOL .)
    UPPER           reduce using rule 37 (boolean_mode -> BOOL .)
    LOWER           reduce using rule 37 (boolean_mode -> BOOL .)
    LENGTH          reduce using rule 37 (boolean_mode -> BOOL .)
    READ            reduce using rule 37 (boolean_mode -> BOOL .)
    PRINT           reduce using rule 37 (boolean_mode -> BOOL .)
    $end            reduce using rule 37 (boolean_mode -> BOOL .)
    END             reduce using rule 37 (boolean_mode -> BOOL .)
    LOC             reduce using rule 37 (boolean_mode -> BOOL .)
    RPAREN          reduce using rule 37 (boolean_mode -> BOOL .)
    RBRACKET        reduce using rule 37 (boolean_mode -> BOOL .)


state 163

    (12) declaration -> identifier_list mode . initialization
    (13) declaration -> identifier_list mode .
    (14) initialization -> . ASSIGN expression

    SEMI            reduce using rule 13 (declaration -> identifier_list mode .)
    COMMA           reduce using rule 13 (declaration -> identifier_list mode .)
    ASSIGN          shift and go to state 228

    initialization                 shift and go to state 227

state 164

    (41) mode_name -> identifier .
    (42) discrete_mode_name -> identifier .

    LOC             reduce using rule 41 (mode_name -> identifier .)
    RPAREN          reduce using rule 41 (mode_name -> identifier .)
    ASSIGN          reduce using rule 41 (mode_name -> identifier .)
    COMMA           reduce using rule 41 (mode_name -> identifier .)
    SEMI            reduce using rule 41 (mode_name -> identifier .)
    DCL             reduce using rule 41 (mode_name -> identifier .)
    SYN             reduce using rule 41 (mode_name -> identifier .)
    TYPE            reduce using rule 41 (mode_name -> identifier .)
    ID              reduce using rule 41 (mode_name -> identifier .)
    IF              reduce using rule 41 (mode_name -> identifier .)
    DO              reduce using rule 41 (mode_name -> identifier .)
    EXIT            reduce using rule 41 (mode_name -> identifier .)
    RETURN          reduce using rule 41 (mode_name -> identifier .)
    RESULT          reduce using rule 41 (mode_name -> identifier .)
    NUM             reduce using rule 41 (mode_name -> identifier .)
    PRED            reduce using rule 41 (mode_name -> identifier .)
    SUCC            reduce using rule 41 (mode_name -> identifier .)
    UPPER           reduce using rule 41 (mode_name -> identifier .)
    LOWER           reduce using rule 41 (mode_name -> identifier .)
    LENGTH          reduce using rule 41 (mode_name -> identifier .)
    READ            reduce using rule 41 (mode_name -> identifier .)
    PRINT           reduce using rule 41 (mode_name -> identifier .)
    $end            reduce using rule 41 (mode_name -> identifier .)
    END             reduce using rule 41 (mode_name -> identifier .)
    LPAREN          reduce using rule 42 (discrete_mode_name -> identifier .)


state 165

    (126) assignment_action -> location assigning_operator expression .

    SEMI            reduce using rule 126 (assignment_action -> location assigning_operator expression .)


state 166

    (131) assigning_operator -> DIVIDE ASSIGN .

    IF              reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    MINUS           reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    NOT             reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    ID              reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    ICONST          reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    FALSE           reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    TRUE            reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    CCONST          reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    NULL            reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    SCONST          reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)
    LPAREN          reduce using rule 131 (assigning_operator -> DIVIDE ASSIGN .)


state 167

    (129) assigning_operator -> MINUS ASSIGN .

    IF              reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    MINUS           reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    NOT             reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    ID              reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    ICONST          reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    FALSE           reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    TRUE            reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    CCONST          reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    NULL            reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    SCONST          reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)
    LPAREN          reduce using rule 129 (assigning_operator -> MINUS ASSIGN .)


state 168

    (128) assigning_operator -> PLUS ASSIGN .

    IF              reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    MINUS           reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    NOT             reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    ID              reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    ICONST          reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    FALSE           reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    TRUE            reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    CCONST          reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    NULL            reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    SCONST          reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)
    LPAREN          reduce using rule 128 (assigning_operator -> PLUS ASSIGN .)


state 169

    (68) array_slice -> location LBRACKET ICONST . COLON ICONST RBRACKET
    (73) literal -> ICONST .

    COLON           shift and go to state 229
    AND             reduce using rule 73 (literal -> ICONST .)
    OR              reduce using rule 73 (literal -> ICONST .)
    EQ              reduce using rule 73 (literal -> ICONST .)
    NEQ             reduce using rule 73 (literal -> ICONST .)
    GT              reduce using rule 73 (literal -> ICONST .)
    GE              reduce using rule 73 (literal -> ICONST .)
    LT              reduce using rule 73 (literal -> ICONST .)
    LE              reduce using rule 73 (literal -> ICONST .)
    PLUS            reduce using rule 73 (literal -> ICONST .)
    MINUS           reduce using rule 73 (literal -> ICONST .)
    TIMES           reduce using rule 73 (literal -> ICONST .)
    DIVIDE          reduce using rule 73 (literal -> ICONST .)
    MOD             reduce using rule 73 (literal -> ICONST .)
    NOT             reduce using rule 73 (literal -> ICONST .)
    IN              reduce using rule 73 (literal -> ICONST .)
    CONCAT          reduce using rule 73 (literal -> ICONST .)
    RBRACKET        reduce using rule 73 (literal -> ICONST .)
    COMMA           reduce using rule 73 (literal -> ICONST .)
    LBRACKET        reduce using rule 73 (literal -> ICONST .)


state 170

    (65) array_element -> location LBRACKET expression_list . RBRACKET
    (67) expression_list -> expression_list . COMMA expression

    RBRACKET        shift and go to state 231
    COMMA           shift and go to state 230


state 171

    (66) expression_list -> expression .

    RBRACKET        reduce using rule 66 (expression_list -> expression .)
    COMMA           reduce using rule 66 (expression_list -> expression .)


state 172

    (130) assigning_operator -> TIMES ASSIGN .

    IF              reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    MINUS           reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    NOT             reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    ID              reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    ICONST          reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    FALSE           reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    TRUE            reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    CCONST          reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    NULL            reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    SCONST          reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)
    LPAREN          reduce using rule 130 (assigning_operator -> TIMES ASSIGN .)


state 173

    (133) assigning_operator -> CONCAT ASSIGN .

    IF              reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    MINUS           reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    NOT             reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    ID              reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    ICONST          reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    FALSE           reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    TRUE            reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    CCONST          reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    NULL            reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    SCONST          reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)
    LPAREN          reduce using rule 133 (assigning_operator -> CONCAT ASSIGN .)


state 174

    (132) assigning_operator -> MOD ASSIGN .

    IF              reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    MINUS           reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    NOT             reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    ID              reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    ICONST          reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    FALSE           reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    TRUE            reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    CCONST          reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    NULL            reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    SCONST          reduce using rule 132 (assigning_operator -> MOD ASSIGN .)
    LPAREN          reduce using rule 132 (assigning_operator -> MOD ASSIGN .)


state 175

    (137) then_clause -> THEN . action_statement
    (138) then_clause -> THEN .
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    ELSE            reduce using rule 138 (then_clause -> THEN .)
    ELSIF           reduce using rule 138 (then_clause -> THEN .)
    FI              reduce using rule 138 (then_clause -> THEN .)
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 232
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 70

state 176

    (135) if_action -> IF boolean_expression then_clause . else_clause FI
    (136) if_action -> IF boolean_expression then_clause . FI
    (139) else_clause -> . ELSE action_statement
    (140) else_clause -> . ELSE
    (141) else_clause -> . ELSIF boolean_expression then_clause else_clause
    (142) else_clause -> . ELSIF boolean_expression then_clause

    FI              shift and go to state 236
    ELSE            shift and go to state 234
    ELSIF           shift and go to state 233

    else_clause                    shift and go to state 235

state 177

    (26) newmode_list -> newmode_list COMMA . mode_definition
    (27) mode_definition -> . identifier_list mode
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    mode_definition                shift and go to state 237
    identifier_list                shift and go to state 93
    identifier                     shift and go to state 73

state 178

    (27) mode_definition -> identifier_list mode .

    COMMA           reduce using rule 27 (mode_definition -> identifier_list mode .)
    DCL             reduce using rule 27 (mode_definition -> identifier_list mode .)
    SYN             reduce using rule 27 (mode_definition -> identifier_list mode .)
    TYPE            reduce using rule 27 (mode_definition -> identifier_list mode .)
    ID              reduce using rule 27 (mode_definition -> identifier_list mode .)
    IF              reduce using rule 27 (mode_definition -> identifier_list mode .)
    DO              reduce using rule 27 (mode_definition -> identifier_list mode .)
    EXIT            reduce using rule 27 (mode_definition -> identifier_list mode .)
    RETURN          reduce using rule 27 (mode_definition -> identifier_list mode .)
    RESULT          reduce using rule 27 (mode_definition -> identifier_list mode .)
    NUM             reduce using rule 27 (mode_definition -> identifier_list mode .)
    PRED            reduce using rule 27 (mode_definition -> identifier_list mode .)
    SUCC            reduce using rule 27 (mode_definition -> identifier_list mode .)
    UPPER           reduce using rule 27 (mode_definition -> identifier_list mode .)
    LOWER           reduce using rule 27 (mode_definition -> identifier_list mode .)
    LENGTH          reduce using rule 27 (mode_definition -> identifier_list mode .)
    READ            reduce using rule 27 (mode_definition -> identifier_list mode .)
    PRINT           reduce using rule 27 (mode_definition -> identifier_list mode .)
    $end            reduce using rule 27 (mode_definition -> identifier_list mode .)
    END             reduce using rule 27 (mode_definition -> identifier_list mode .)


state 179

    (20) synonym_list -> synonym_list COMMA . synonym_definition
    (21) synonym_definition -> . identifier_list mode ASSIGN constant_expression
    (22) synonym_definition -> . identifier_list ASSIGN constant_expression
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    synonym_definition             shift and go to state 238
    identifier_list                shift and go to state 96
    identifier                     shift and go to state 73

state 180

    (18) synonym_statement -> SYN synonym_list SEMI .

    END             reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    DCL             reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    SYN             reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    TYPE            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    ID              reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    IF              reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    DO              reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    EXIT            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    RETURN          reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    RESULT          reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    NUM             reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    PRED            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    SUCC            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    UPPER           reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    LOWER           reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    LENGTH          reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    READ            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    PRINT           reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)
    $end            reduce using rule 18 (synonym_statement -> SYN synonym_list SEMI .)


state 181

    (22) synonym_definition -> identifier_list ASSIGN . constant_expression
    (23) constant_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    identifier                     shift and go to state 62
    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    primitive_value                shift and go to state 64
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    expression                     shift and go to state 240
    constant_expression            shift and go to state 239
    value_array_element            shift and go to state 51

state 182

    (21) synonym_definition -> identifier_list mode . ASSIGN constant_expression

    ASSIGN          shift and go to state 241


state 183

    (127) assignment_action -> identifier assigning_operator expression .

    SEMI            reduce using rule 127 (assignment_action -> identifier assigning_operator expression .)


state 184

    (63) string_element -> identifier LBRACKET ICONST . RBRACKET
    (64) string_slice -> identifier LBRACKET ICONST . COLON ICONST RBRACKET

    RBRACKET        shift and go to state 243
    COLON           shift and go to state 242


state 185

    (117) action_statement -> identifier COLON action . SEMI

    SEMI            shift and go to state 244


state 186

    (183) procedure_statement -> identifier COLON procedure_definition . SEMI

    SEMI            shift and go to state 245


state 187

    (127) assignment_action -> identifier . assigning_operator expression
    (165) procedure_call -> identifier . LPAREN parameter_list RPAREN
    (166) procedure_call -> identifier . LPAREN RPAREN
    (63) string_element -> identifier . LBRACKET ICONST RBRACKET
    (64) string_slice -> identifier . LBRACKET ICONST COLON ICONST RBRACKET
    (128) assigning_operator -> . PLUS ASSIGN
    (129) assigning_operator -> . MINUS ASSIGN
    (130) assigning_operator -> . TIMES ASSIGN
    (131) assigning_operator -> . DIVIDE ASSIGN
    (132) assigning_operator -> . MOD ASSIGN
    (133) assigning_operator -> . CONCAT ASSIGN
    (134) assigning_operator -> . ASSIGN

    LPAREN          shift and go to state 102
    LBRACKET        shift and go to state 100
    PLUS            shift and go to state 80
    MINUS           shift and go to state 79
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 78
    MOD             shift and go to state 86
    CONCAT          shift and go to state 85
    ASSIGN          shift and go to state 84

    assigning_operator             shift and go to state 99

state 188

    (184) procedure_definition -> PROC . LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END
    (185) procedure_definition -> PROC . LPAREN formal_parameter_list RPAREN SEMI statement_list END
    (186) procedure_definition -> PROC . LPAREN RPAREN SEMI statement_list END

    LPAREN          shift and go to state 246


state 189

    (166) procedure_call -> identifier LPAREN RPAREN .

    SEMI            reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    ARROW           reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    LBRACKET        reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    PLUS            reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    MINUS           reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    TIMES           reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    DIVIDE          reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    MOD             reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    CONCAT          reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    ASSIGN          reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    AND             reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    OR              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    EQ              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    NEQ             reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    GT              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    GE              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    LT              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    LE              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    NOT             reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    IN              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    THEN            reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    RPAREN          reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    COMMA           reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    RBRACKET        reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    COLON           reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    ELSE            reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    ELSIF           reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    DOWN            reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    BY              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    TO              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    FI              reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)
    WHILE           reduce using rule 166 (procedure_call -> identifier LPAREN RPAREN .)


state 190

    (165) procedure_call -> identifier LPAREN parameter_list . RPAREN
    (168) parameter_list -> parameter_list . COMMA expression

    RPAREN          shift and go to state 247
    COMMA           shift and go to state 219


state 191

    (116) referenced_location -> ARROW location .
    (62) dereferenced_reference -> location . ARROW
    (65) array_element -> location . LBRACKET expression_list RBRACKET
    (68) array_slice -> location . LBRACKET ICONST COLON ICONST RBRACKET

    AND             reduce using rule 116 (referenced_location -> ARROW location .)
    OR              reduce using rule 116 (referenced_location -> ARROW location .)
    EQ              reduce using rule 116 (referenced_location -> ARROW location .)
    NEQ             reduce using rule 116 (referenced_location -> ARROW location .)
    GT              reduce using rule 116 (referenced_location -> ARROW location .)
    GE              reduce using rule 116 (referenced_location -> ARROW location .)
    LT              reduce using rule 116 (referenced_location -> ARROW location .)
    LE              reduce using rule 116 (referenced_location -> ARROW location .)
    PLUS            reduce using rule 116 (referenced_location -> ARROW location .)
    MINUS           reduce using rule 116 (referenced_location -> ARROW location .)
    TIMES           reduce using rule 116 (referenced_location -> ARROW location .)
    DIVIDE          reduce using rule 116 (referenced_location -> ARROW location .)
    MOD             reduce using rule 116 (referenced_location -> ARROW location .)
    NOT             reduce using rule 116 (referenced_location -> ARROW location .)
    IN              reduce using rule 116 (referenced_location -> ARROW location .)
    CONCAT          reduce using rule 116 (referenced_location -> ARROW location .)
    SEMI            reduce using rule 116 (referenced_location -> ARROW location .)
    THEN            reduce using rule 116 (referenced_location -> ARROW location .)
    RPAREN          reduce using rule 116 (referenced_location -> ARROW location .)
    COMMA           reduce using rule 116 (referenced_location -> ARROW location .)
    RBRACKET        reduce using rule 116 (referenced_location -> ARROW location .)
    COLON           reduce using rule 116 (referenced_location -> ARROW location .)
    ELSE            reduce using rule 116 (referenced_location -> ARROW location .)
    ELSIF           reduce using rule 116 (referenced_location -> ARROW location .)
    DOWN            reduce using rule 116 (referenced_location -> ARROW location .)
    BY              reduce using rule 116 (referenced_location -> ARROW location .)
    TO              reduce using rule 116 (referenced_location -> ARROW location .)
    FI              reduce using rule 116 (referenced_location -> ARROW location .)
    WHILE           reduce using rule 116 (referenced_location -> ARROW location .)
    ARROW           shift and go to state 82
    LBRACKET        shift and go to state 81


state 192

    (93) binop -> binop AND binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 93 (binop -> binop AND binop .)
    OR              reduce using rule 93 (binop -> binop AND binop .)
    NOT             reduce using rule 93 (binop -> binop AND binop .)
    IN              reduce using rule 93 (binop -> binop AND binop .)
    CONCAT          reduce using rule 93 (binop -> binop AND binop .)
    ELSE            reduce using rule 93 (binop -> binop AND binop .)
    ELSIF           reduce using rule 93 (binop -> binop AND binop .)
    SEMI            reduce using rule 93 (binop -> binop AND binop .)
    THEN            reduce using rule 93 (binop -> binop AND binop .)
    RPAREN          reduce using rule 93 (binop -> binop AND binop .)
    COMMA           reduce using rule 93 (binop -> binop AND binop .)
    RBRACKET        reduce using rule 93 (binop -> binop AND binop .)
    COLON           reduce using rule 93 (binop -> binop AND binop .)
    DOWN            reduce using rule 93 (binop -> binop AND binop .)
    BY              reduce using rule 93 (binop -> binop AND binop .)
    TO              reduce using rule 93 (binop -> binop AND binop .)
    FI              reduce using rule 93 (binop -> binop AND binop .)
    WHILE           reduce using rule 93 (binop -> binop AND binop .)
    EQ              shift and go to state 122
    NEQ             shift and go to state 125
    GT              shift and go to state 111
    GE              shift and go to state 115
    LT              shift and go to state 113
    LE              shift and go to state 116
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! EQ              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! NEQ             [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! GT              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! GE              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! LT              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! LE              [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! PLUS            [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! MINUS           [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! TIMES           [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! DIVIDE          [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! MOD             [ reduce using rule 93 (binop -> binop AND binop .) ]
  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 193

    (97) binop -> binop GT binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 97 (binop -> binop GT binop .)
    OR              reduce using rule 97 (binop -> binop GT binop .)
    EQ              reduce using rule 97 (binop -> binop GT binop .)
    NEQ             reduce using rule 97 (binop -> binop GT binop .)
    GT              reduce using rule 97 (binop -> binop GT binop .)
    GE              reduce using rule 97 (binop -> binop GT binop .)
    LT              reduce using rule 97 (binop -> binop GT binop .)
    LE              reduce using rule 97 (binop -> binop GT binop .)
    NOT             reduce using rule 97 (binop -> binop GT binop .)
    IN              reduce using rule 97 (binop -> binop GT binop .)
    CONCAT          reduce using rule 97 (binop -> binop GT binop .)
    ELSE            reduce using rule 97 (binop -> binop GT binop .)
    ELSIF           reduce using rule 97 (binop -> binop GT binop .)
    SEMI            reduce using rule 97 (binop -> binop GT binop .)
    THEN            reduce using rule 97 (binop -> binop GT binop .)
    RPAREN          reduce using rule 97 (binop -> binop GT binop .)
    COMMA           reduce using rule 97 (binop -> binop GT binop .)
    RBRACKET        reduce using rule 97 (binop -> binop GT binop .)
    COLON           reduce using rule 97 (binop -> binop GT binop .)
    DOWN            reduce using rule 97 (binop -> binop GT binop .)
    BY              reduce using rule 97 (binop -> binop GT binop .)
    TO              reduce using rule 97 (binop -> binop GT binop .)
    FI              reduce using rule 97 (binop -> binop GT binop .)
    WHILE           reduce using rule 97 (binop -> binop GT binop .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! PLUS            [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! MINUS           [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! TIMES           [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! DIVIDE          [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! MOD             [ reduce using rule 97 (binop -> binop GT binop .) ]
  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! GT              [ shift and go to state 111 ]
  ! GE              [ shift and go to state 115 ]
  ! LT              [ shift and go to state 113 ]
  ! LE              [ shift and go to state 116 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 194

    (104) binop -> binop DIVIDE binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 104 (binop -> binop DIVIDE binop .)
    OR              reduce using rule 104 (binop -> binop DIVIDE binop .)
    EQ              reduce using rule 104 (binop -> binop DIVIDE binop .)
    NEQ             reduce using rule 104 (binop -> binop DIVIDE binop .)
    GT              reduce using rule 104 (binop -> binop DIVIDE binop .)
    GE              reduce using rule 104 (binop -> binop DIVIDE binop .)
    LT              reduce using rule 104 (binop -> binop DIVIDE binop .)
    LE              reduce using rule 104 (binop -> binop DIVIDE binop .)
    PLUS            reduce using rule 104 (binop -> binop DIVIDE binop .)
    MINUS           reduce using rule 104 (binop -> binop DIVIDE binop .)
    TIMES           reduce using rule 104 (binop -> binop DIVIDE binop .)
    DIVIDE          reduce using rule 104 (binop -> binop DIVIDE binop .)
    MOD             reduce using rule 104 (binop -> binop DIVIDE binop .)
    NOT             reduce using rule 104 (binop -> binop DIVIDE binop .)
    IN              reduce using rule 104 (binop -> binop DIVIDE binop .)
    CONCAT          reduce using rule 104 (binop -> binop DIVIDE binop .)
    ELSE            reduce using rule 104 (binop -> binop DIVIDE binop .)
    ELSIF           reduce using rule 104 (binop -> binop DIVIDE binop .)
    SEMI            reduce using rule 104 (binop -> binop DIVIDE binop .)
    THEN            reduce using rule 104 (binop -> binop DIVIDE binop .)
    RPAREN          reduce using rule 104 (binop -> binop DIVIDE binop .)
    COMMA           reduce using rule 104 (binop -> binop DIVIDE binop .)
    RBRACKET        reduce using rule 104 (binop -> binop DIVIDE binop .)
    COLON           reduce using rule 104 (binop -> binop DIVIDE binop .)
    DOWN            reduce using rule 104 (binop -> binop DIVIDE binop .)
    BY              reduce using rule 104 (binop -> binop DIVIDE binop .)
    TO              reduce using rule 104 (binop -> binop DIVIDE binop .)
    FI              reduce using rule 104 (binop -> binop DIVIDE binop .)
    WHILE           reduce using rule 104 (binop -> binop DIVIDE binop .)

  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! GT              [ shift and go to state 111 ]
  ! GE              [ shift and go to state 115 ]
  ! LT              [ shift and go to state 113 ]
  ! LE              [ shift and go to state 116 ]
  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 114 ]
  ! TIMES           [ shift and go to state 121 ]
  ! DIVIDE          [ shift and go to state 112 ]
  ! MOD             [ shift and go to state 118 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 195

    (99) binop -> binop LT binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 99 (binop -> binop LT binop .)
    OR              reduce using rule 99 (binop -> binop LT binop .)
    EQ              reduce using rule 99 (binop -> binop LT binop .)
    NEQ             reduce using rule 99 (binop -> binop LT binop .)
    GT              reduce using rule 99 (binop -> binop LT binop .)
    GE              reduce using rule 99 (binop -> binop LT binop .)
    LT              reduce using rule 99 (binop -> binop LT binop .)
    LE              reduce using rule 99 (binop -> binop LT binop .)
    NOT             reduce using rule 99 (binop -> binop LT binop .)
    IN              reduce using rule 99 (binop -> binop LT binop .)
    CONCAT          reduce using rule 99 (binop -> binop LT binop .)
    ELSE            reduce using rule 99 (binop -> binop LT binop .)
    ELSIF           reduce using rule 99 (binop -> binop LT binop .)
    SEMI            reduce using rule 99 (binop -> binop LT binop .)
    THEN            reduce using rule 99 (binop -> binop LT binop .)
    RPAREN          reduce using rule 99 (binop -> binop LT binop .)
    COMMA           reduce using rule 99 (binop -> binop LT binop .)
    RBRACKET        reduce using rule 99 (binop -> binop LT binop .)
    COLON           reduce using rule 99 (binop -> binop LT binop .)
    DOWN            reduce using rule 99 (binop -> binop LT binop .)
    BY              reduce using rule 99 (binop -> binop LT binop .)
    TO              reduce using rule 99 (binop -> binop LT binop .)
    FI              reduce using rule 99 (binop -> binop LT binop .)
    WHILE           reduce using rule 99 (binop -> binop LT binop .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! PLUS            [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! MINUS           [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! TIMES           [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! DIVIDE          [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! MOD             [ reduce using rule 99 (binop -> binop LT binop .) ]
  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! GT              [ shift and go to state 111 ]
  ! GE              [ shift and go to state 115 ]
  ! LT              [ shift and go to state 113 ]
  ! LE              [ shift and go to state 116 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 196

    (102) binop -> binop MINUS binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 102 (binop -> binop MINUS binop .)
    OR              reduce using rule 102 (binop -> binop MINUS binop .)
    EQ              reduce using rule 102 (binop -> binop MINUS binop .)
    NEQ             reduce using rule 102 (binop -> binop MINUS binop .)
    GT              reduce using rule 102 (binop -> binop MINUS binop .)
    GE              reduce using rule 102 (binop -> binop MINUS binop .)
    LT              reduce using rule 102 (binop -> binop MINUS binop .)
    LE              reduce using rule 102 (binop -> binop MINUS binop .)
    PLUS            reduce using rule 102 (binop -> binop MINUS binop .)
    MINUS           reduce using rule 102 (binop -> binop MINUS binop .)
    NOT             reduce using rule 102 (binop -> binop MINUS binop .)
    IN              reduce using rule 102 (binop -> binop MINUS binop .)
    CONCAT          reduce using rule 102 (binop -> binop MINUS binop .)
    ELSE            reduce using rule 102 (binop -> binop MINUS binop .)
    ELSIF           reduce using rule 102 (binop -> binop MINUS binop .)
    SEMI            reduce using rule 102 (binop -> binop MINUS binop .)
    THEN            reduce using rule 102 (binop -> binop MINUS binop .)
    RPAREN          reduce using rule 102 (binop -> binop MINUS binop .)
    COMMA           reduce using rule 102 (binop -> binop MINUS binop .)
    RBRACKET        reduce using rule 102 (binop -> binop MINUS binop .)
    COLON           reduce using rule 102 (binop -> binop MINUS binop .)
    DOWN            reduce using rule 102 (binop -> binop MINUS binop .)
    BY              reduce using rule 102 (binop -> binop MINUS binop .)
    TO              reduce using rule 102 (binop -> binop MINUS binop .)
    FI              reduce using rule 102 (binop -> binop MINUS binop .)
    WHILE           reduce using rule 102 (binop -> binop MINUS binop .)
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! TIMES           [ reduce using rule 102 (binop -> binop MINUS binop .) ]
  ! DIVIDE          [ reduce using rule 102 (binop -> binop MINUS binop .) ]
  ! MOD             [ reduce using rule 102 (binop -> binop MINUS binop .) ]
  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! GT              [ shift and go to state 111 ]
  ! GE              [ shift and go to state 115 ]
  ! LT              [ shift and go to state 113 ]
  ! LE              [ shift and go to state 116 ]
  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 114 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 197

    (98) binop -> binop GE binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 98 (binop -> binop GE binop .)
    OR              reduce using rule 98 (binop -> binop GE binop .)
    EQ              reduce using rule 98 (binop -> binop GE binop .)
    NEQ             reduce using rule 98 (binop -> binop GE binop .)
    GT              reduce using rule 98 (binop -> binop GE binop .)
    GE              reduce using rule 98 (binop -> binop GE binop .)
    LT              reduce using rule 98 (binop -> binop GE binop .)
    LE              reduce using rule 98 (binop -> binop GE binop .)
    NOT             reduce using rule 98 (binop -> binop GE binop .)
    IN              reduce using rule 98 (binop -> binop GE binop .)
    CONCAT          reduce using rule 98 (binop -> binop GE binop .)
    ELSE            reduce using rule 98 (binop -> binop GE binop .)
    ELSIF           reduce using rule 98 (binop -> binop GE binop .)
    SEMI            reduce using rule 98 (binop -> binop GE binop .)
    THEN            reduce using rule 98 (binop -> binop GE binop .)
    RPAREN          reduce using rule 98 (binop -> binop GE binop .)
    COMMA           reduce using rule 98 (binop -> binop GE binop .)
    RBRACKET        reduce using rule 98 (binop -> binop GE binop .)
    COLON           reduce using rule 98 (binop -> binop GE binop .)
    DOWN            reduce using rule 98 (binop -> binop GE binop .)
    BY              reduce using rule 98 (binop -> binop GE binop .)
    TO              reduce using rule 98 (binop -> binop GE binop .)
    FI              reduce using rule 98 (binop -> binop GE binop .)
    WHILE           reduce using rule 98 (binop -> binop GE binop .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! PLUS            [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! MINUS           [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! TIMES           [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! DIVIDE          [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! MOD             [ reduce using rule 98 (binop -> binop GE binop .) ]
  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! GT              [ shift and go to state 111 ]
  ! GE              [ shift and go to state 115 ]
  ! LT              [ shift and go to state 113 ]
  ! LE              [ shift and go to state 116 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 198

    (100) binop -> binop LE binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 100 (binop -> binop LE binop .)
    OR              reduce using rule 100 (binop -> binop LE binop .)
    EQ              reduce using rule 100 (binop -> binop LE binop .)
    NEQ             reduce using rule 100 (binop -> binop LE binop .)
    GT              reduce using rule 100 (binop -> binop LE binop .)
    GE              reduce using rule 100 (binop -> binop LE binop .)
    LT              reduce using rule 100 (binop -> binop LE binop .)
    LE              reduce using rule 100 (binop -> binop LE binop .)
    NOT             reduce using rule 100 (binop -> binop LE binop .)
    IN              reduce using rule 100 (binop -> binop LE binop .)
    CONCAT          reduce using rule 100 (binop -> binop LE binop .)
    ELSE            reduce using rule 100 (binop -> binop LE binop .)
    ELSIF           reduce using rule 100 (binop -> binop LE binop .)
    SEMI            reduce using rule 100 (binop -> binop LE binop .)
    THEN            reduce using rule 100 (binop -> binop LE binop .)
    RPAREN          reduce using rule 100 (binop -> binop LE binop .)
    COMMA           reduce using rule 100 (binop -> binop LE binop .)
    RBRACKET        reduce using rule 100 (binop -> binop LE binop .)
    COLON           reduce using rule 100 (binop -> binop LE binop .)
    DOWN            reduce using rule 100 (binop -> binop LE binop .)
    BY              reduce using rule 100 (binop -> binop LE binop .)
    TO              reduce using rule 100 (binop -> binop LE binop .)
    FI              reduce using rule 100 (binop -> binop LE binop .)
    WHILE           reduce using rule 100 (binop -> binop LE binop .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! PLUS            [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! MINUS           [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! TIMES           [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! DIVIDE          [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! MOD             [ reduce using rule 100 (binop -> binop LE binop .) ]
  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! GT              [ shift and go to state 111 ]
  ! GE              [ shift and go to state 115 ]
  ! LT              [ shift and go to state 113 ]
  ! LE              [ shift and go to state 116 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 199

    (101) binop -> binop PLUS binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 101 (binop -> binop PLUS binop .)
    OR              reduce using rule 101 (binop -> binop PLUS binop .)
    EQ              reduce using rule 101 (binop -> binop PLUS binop .)
    NEQ             reduce using rule 101 (binop -> binop PLUS binop .)
    GT              reduce using rule 101 (binop -> binop PLUS binop .)
    GE              reduce using rule 101 (binop -> binop PLUS binop .)
    LT              reduce using rule 101 (binop -> binop PLUS binop .)
    LE              reduce using rule 101 (binop -> binop PLUS binop .)
    PLUS            reduce using rule 101 (binop -> binop PLUS binop .)
    MINUS           reduce using rule 101 (binop -> binop PLUS binop .)
    NOT             reduce using rule 101 (binop -> binop PLUS binop .)
    IN              reduce using rule 101 (binop -> binop PLUS binop .)
    CONCAT          reduce using rule 101 (binop -> binop PLUS binop .)
    ELSE            reduce using rule 101 (binop -> binop PLUS binop .)
    ELSIF           reduce using rule 101 (binop -> binop PLUS binop .)
    SEMI            reduce using rule 101 (binop -> binop PLUS binop .)
    THEN            reduce using rule 101 (binop -> binop PLUS binop .)
    RPAREN          reduce using rule 101 (binop -> binop PLUS binop .)
    COMMA           reduce using rule 101 (binop -> binop PLUS binop .)
    RBRACKET        reduce using rule 101 (binop -> binop PLUS binop .)
    COLON           reduce using rule 101 (binop -> binop PLUS binop .)
    DOWN            reduce using rule 101 (binop -> binop PLUS binop .)
    BY              reduce using rule 101 (binop -> binop PLUS binop .)
    TO              reduce using rule 101 (binop -> binop PLUS binop .)
    FI              reduce using rule 101 (binop -> binop PLUS binop .)
    WHILE           reduce using rule 101 (binop -> binop PLUS binop .)
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! TIMES           [ reduce using rule 101 (binop -> binop PLUS binop .) ]
  ! DIVIDE          [ reduce using rule 101 (binop -> binop PLUS binop .) ]
  ! MOD             [ reduce using rule 101 (binop -> binop PLUS binop .) ]
  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! GT              [ shift and go to state 111 ]
  ! GE              [ shift and go to state 115 ]
  ! LT              [ shift and go to state 113 ]
  ! LE              [ shift and go to state 116 ]
  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 114 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 200

    (105) binop -> binop MOD binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 105 (binop -> binop MOD binop .)
    OR              reduce using rule 105 (binop -> binop MOD binop .)
    EQ              reduce using rule 105 (binop -> binop MOD binop .)
    NEQ             reduce using rule 105 (binop -> binop MOD binop .)
    GT              reduce using rule 105 (binop -> binop MOD binop .)
    GE              reduce using rule 105 (binop -> binop MOD binop .)
    LT              reduce using rule 105 (binop -> binop MOD binop .)
    LE              reduce using rule 105 (binop -> binop MOD binop .)
    PLUS            reduce using rule 105 (binop -> binop MOD binop .)
    MINUS           reduce using rule 105 (binop -> binop MOD binop .)
    TIMES           reduce using rule 105 (binop -> binop MOD binop .)
    DIVIDE          reduce using rule 105 (binop -> binop MOD binop .)
    MOD             reduce using rule 105 (binop -> binop MOD binop .)
    NOT             reduce using rule 105 (binop -> binop MOD binop .)
    IN              reduce using rule 105 (binop -> binop MOD binop .)
    CONCAT          reduce using rule 105 (binop -> binop MOD binop .)
    ELSE            reduce using rule 105 (binop -> binop MOD binop .)
    ELSIF           reduce using rule 105 (binop -> binop MOD binop .)
    SEMI            reduce using rule 105 (binop -> binop MOD binop .)
    THEN            reduce using rule 105 (binop -> binop MOD binop .)
    RPAREN          reduce using rule 105 (binop -> binop MOD binop .)
    COMMA           reduce using rule 105 (binop -> binop MOD binop .)
    RBRACKET        reduce using rule 105 (binop -> binop MOD binop .)
    COLON           reduce using rule 105 (binop -> binop MOD binop .)
    DOWN            reduce using rule 105 (binop -> binop MOD binop .)
    BY              reduce using rule 105 (binop -> binop MOD binop .)
    TO              reduce using rule 105 (binop -> binop MOD binop .)
    FI              reduce using rule 105 (binop -> binop MOD binop .)
    WHILE           reduce using rule 105 (binop -> binop MOD binop .)

  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! GT              [ shift and go to state 111 ]
  ! GE              [ shift and go to state 115 ]
  ! LT              [ shift and go to state 113 ]
  ! LE              [ shift and go to state 116 ]
  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 114 ]
  ! TIMES           [ shift and go to state 121 ]
  ! DIVIDE          [ shift and go to state 112 ]
  ! MOD             [ shift and go to state 118 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 201

    (107) binop -> binop IN binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    NOT             reduce using rule 107 (binop -> binop IN binop .)
    IN              reduce using rule 107 (binop -> binop IN binop .)
    CONCAT          reduce using rule 107 (binop -> binop IN binop .)
    ELSE            reduce using rule 107 (binop -> binop IN binop .)
    ELSIF           reduce using rule 107 (binop -> binop IN binop .)
    SEMI            reduce using rule 107 (binop -> binop IN binop .)
    THEN            reduce using rule 107 (binop -> binop IN binop .)
    RPAREN          reduce using rule 107 (binop -> binop IN binop .)
    COMMA           reduce using rule 107 (binop -> binop IN binop .)
    RBRACKET        reduce using rule 107 (binop -> binop IN binop .)
    COLON           reduce using rule 107 (binop -> binop IN binop .)
    DOWN            reduce using rule 107 (binop -> binop IN binop .)
    BY              reduce using rule 107 (binop -> binop IN binop .)
    TO              reduce using rule 107 (binop -> binop IN binop .)
    FI              reduce using rule 107 (binop -> binop IN binop .)
    WHILE           reduce using rule 107 (binop -> binop IN binop .)
    AND             shift and go to state 110
    OR              shift and go to state 123
    EQ              shift and go to state 122
    NEQ             shift and go to state 125
    GT              shift and go to state 111
    GE              shift and go to state 115
    LT              shift and go to state 113
    LE              shift and go to state 116
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! AND             [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! OR              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! EQ              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! NEQ             [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! GT              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! GE              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! LT              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! LE              [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! PLUS            [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! MINUS           [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! TIMES           [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! DIVIDE          [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! MOD             [ reduce using rule 107 (binop -> binop IN binop .) ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 202

    (106) binop -> binop NOT binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    NOT             reduce using rule 106 (binop -> binop NOT binop .)
    CONCAT          reduce using rule 106 (binop -> binop NOT binop .)
    ELSE            reduce using rule 106 (binop -> binop NOT binop .)
    ELSIF           reduce using rule 106 (binop -> binop NOT binop .)
    SEMI            reduce using rule 106 (binop -> binop NOT binop .)
    THEN            reduce using rule 106 (binop -> binop NOT binop .)
    RPAREN          reduce using rule 106 (binop -> binop NOT binop .)
    COMMA           reduce using rule 106 (binop -> binop NOT binop .)
    RBRACKET        reduce using rule 106 (binop -> binop NOT binop .)
    COLON           reduce using rule 106 (binop -> binop NOT binop .)
    DOWN            reduce using rule 106 (binop -> binop NOT binop .)
    BY              reduce using rule 106 (binop -> binop NOT binop .)
    TO              reduce using rule 106 (binop -> binop NOT binop .)
    FI              reduce using rule 106 (binop -> binop NOT binop .)
    WHILE           reduce using rule 106 (binop -> binop NOT binop .)
    AND             shift and go to state 110
    OR              shift and go to state 123
    EQ              shift and go to state 122
    NEQ             shift and go to state 125
    GT              shift and go to state 111
    GE              shift and go to state 115
    LT              shift and go to state 113
    LE              shift and go to state 116
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118
    IN              shift and go to state 119

  ! AND             [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! OR              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! EQ              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! NEQ             [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! GT              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! GE              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! LT              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! LE              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! PLUS            [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! MINUS           [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! TIMES           [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! DIVIDE          [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! MOD             [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! IN              [ reduce using rule 106 (binop -> binop NOT binop .) ]
  ! NOT             [ shift and go to state 120 ]
  ! CONCAT          [ shift and go to state 124 ]


state 203

    (103) binop -> binop TIMES binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 103 (binop -> binop TIMES binop .)
    OR              reduce using rule 103 (binop -> binop TIMES binop .)
    EQ              reduce using rule 103 (binop -> binop TIMES binop .)
    NEQ             reduce using rule 103 (binop -> binop TIMES binop .)
    GT              reduce using rule 103 (binop -> binop TIMES binop .)
    GE              reduce using rule 103 (binop -> binop TIMES binop .)
    LT              reduce using rule 103 (binop -> binop TIMES binop .)
    LE              reduce using rule 103 (binop -> binop TIMES binop .)
    PLUS            reduce using rule 103 (binop -> binop TIMES binop .)
    MINUS           reduce using rule 103 (binop -> binop TIMES binop .)
    TIMES           reduce using rule 103 (binop -> binop TIMES binop .)
    DIVIDE          reduce using rule 103 (binop -> binop TIMES binop .)
    MOD             reduce using rule 103 (binop -> binop TIMES binop .)
    NOT             reduce using rule 103 (binop -> binop TIMES binop .)
    IN              reduce using rule 103 (binop -> binop TIMES binop .)
    CONCAT          reduce using rule 103 (binop -> binop TIMES binop .)
    ELSE            reduce using rule 103 (binop -> binop TIMES binop .)
    ELSIF           reduce using rule 103 (binop -> binop TIMES binop .)
    SEMI            reduce using rule 103 (binop -> binop TIMES binop .)
    THEN            reduce using rule 103 (binop -> binop TIMES binop .)
    RPAREN          reduce using rule 103 (binop -> binop TIMES binop .)
    COMMA           reduce using rule 103 (binop -> binop TIMES binop .)
    RBRACKET        reduce using rule 103 (binop -> binop TIMES binop .)
    COLON           reduce using rule 103 (binop -> binop TIMES binop .)
    DOWN            reduce using rule 103 (binop -> binop TIMES binop .)
    BY              reduce using rule 103 (binop -> binop TIMES binop .)
    TO              reduce using rule 103 (binop -> binop TIMES binop .)
    FI              reduce using rule 103 (binop -> binop TIMES binop .)
    WHILE           reduce using rule 103 (binop -> binop TIMES binop .)

  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! GT              [ shift and go to state 111 ]
  ! GE              [ shift and go to state 115 ]
  ! LT              [ shift and go to state 113 ]
  ! LE              [ shift and go to state 116 ]
  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 114 ]
  ! TIMES           [ shift and go to state 121 ]
  ! DIVIDE          [ shift and go to state 112 ]
  ! MOD             [ shift and go to state 118 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 204

    (95) binop -> binop EQ binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 95 (binop -> binop EQ binop .)
    OR              reduce using rule 95 (binop -> binop EQ binop .)
    EQ              reduce using rule 95 (binop -> binop EQ binop .)
    NEQ             reduce using rule 95 (binop -> binop EQ binop .)
    NOT             reduce using rule 95 (binop -> binop EQ binop .)
    IN              reduce using rule 95 (binop -> binop EQ binop .)
    CONCAT          reduce using rule 95 (binop -> binop EQ binop .)
    ELSE            reduce using rule 95 (binop -> binop EQ binop .)
    ELSIF           reduce using rule 95 (binop -> binop EQ binop .)
    SEMI            reduce using rule 95 (binop -> binop EQ binop .)
    THEN            reduce using rule 95 (binop -> binop EQ binop .)
    RPAREN          reduce using rule 95 (binop -> binop EQ binop .)
    COMMA           reduce using rule 95 (binop -> binop EQ binop .)
    RBRACKET        reduce using rule 95 (binop -> binop EQ binop .)
    COLON           reduce using rule 95 (binop -> binop EQ binop .)
    DOWN            reduce using rule 95 (binop -> binop EQ binop .)
    BY              reduce using rule 95 (binop -> binop EQ binop .)
    TO              reduce using rule 95 (binop -> binop EQ binop .)
    FI              reduce using rule 95 (binop -> binop EQ binop .)
    WHILE           reduce using rule 95 (binop -> binop EQ binop .)
    GT              shift and go to state 111
    GE              shift and go to state 115
    LT              shift and go to state 113
    LE              shift and go to state 116
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! GT              [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! GE              [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! LT              [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! LE              [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! PLUS            [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! MINUS           [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! TIMES           [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! DIVIDE          [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! MOD             [ reduce using rule 95 (binop -> binop EQ binop .) ]
  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 205

    (94) binop -> binop OR binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    OR              reduce using rule 94 (binop -> binop OR binop .)
    NOT             reduce using rule 94 (binop -> binop OR binop .)
    IN              reduce using rule 94 (binop -> binop OR binop .)
    CONCAT          reduce using rule 94 (binop -> binop OR binop .)
    ELSE            reduce using rule 94 (binop -> binop OR binop .)
    ELSIF           reduce using rule 94 (binop -> binop OR binop .)
    SEMI            reduce using rule 94 (binop -> binop OR binop .)
    THEN            reduce using rule 94 (binop -> binop OR binop .)
    RPAREN          reduce using rule 94 (binop -> binop OR binop .)
    COMMA           reduce using rule 94 (binop -> binop OR binop .)
    RBRACKET        reduce using rule 94 (binop -> binop OR binop .)
    COLON           reduce using rule 94 (binop -> binop OR binop .)
    DOWN            reduce using rule 94 (binop -> binop OR binop .)
    BY              reduce using rule 94 (binop -> binop OR binop .)
    TO              reduce using rule 94 (binop -> binop OR binop .)
    FI              reduce using rule 94 (binop -> binop OR binop .)
    WHILE           reduce using rule 94 (binop -> binop OR binop .)
    AND             shift and go to state 110
    EQ              shift and go to state 122
    NEQ             shift and go to state 125
    GT              shift and go to state 111
    GE              shift and go to state 115
    LT              shift and go to state 113
    LE              shift and go to state 116
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! AND             [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! EQ              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! NEQ             [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! GT              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! GE              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! LT              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! LE              [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! PLUS            [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! MINUS           [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! TIMES           [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! DIVIDE          [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! MOD             [ reduce using rule 94 (binop -> binop OR binop .) ]
  ! OR              [ shift and go to state 123 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 206

    (108) binop -> binop CONCAT binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    CONCAT          reduce using rule 108 (binop -> binop CONCAT binop .)
    ELSE            reduce using rule 108 (binop -> binop CONCAT binop .)
    ELSIF           reduce using rule 108 (binop -> binop CONCAT binop .)
    SEMI            reduce using rule 108 (binop -> binop CONCAT binop .)
    THEN            reduce using rule 108 (binop -> binop CONCAT binop .)
    RPAREN          reduce using rule 108 (binop -> binop CONCAT binop .)
    COMMA           reduce using rule 108 (binop -> binop CONCAT binop .)
    RBRACKET        reduce using rule 108 (binop -> binop CONCAT binop .)
    COLON           reduce using rule 108 (binop -> binop CONCAT binop .)
    DOWN            reduce using rule 108 (binop -> binop CONCAT binop .)
    BY              reduce using rule 108 (binop -> binop CONCAT binop .)
    TO              reduce using rule 108 (binop -> binop CONCAT binop .)
    FI              reduce using rule 108 (binop -> binop CONCAT binop .)
    WHILE           reduce using rule 108 (binop -> binop CONCAT binop .)
    AND             shift and go to state 110
    OR              shift and go to state 123
    EQ              shift and go to state 122
    NEQ             shift and go to state 125
    GT              shift and go to state 111
    GE              shift and go to state 115
    LT              shift and go to state 113
    LE              shift and go to state 116
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118
    NOT             shift and go to state 120
    IN              shift and go to state 119

  ! AND             [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! OR              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! EQ              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! NEQ             [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! GT              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! GE              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! LT              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! LE              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! PLUS            [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! MINUS           [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! TIMES           [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! DIVIDE          [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! MOD             [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! NOT             [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! IN              [ reduce using rule 108 (binop -> binop CONCAT binop .) ]
  ! CONCAT          [ shift and go to state 124 ]


state 207

    (96) binop -> binop NEQ binop .
    (93) binop -> binop . AND binop
    (94) binop -> binop . OR binop
    (95) binop -> binop . EQ binop
    (96) binop -> binop . NEQ binop
    (97) binop -> binop . GT binop
    (98) binop -> binop . GE binop
    (99) binop -> binop . LT binop
    (100) binop -> binop . LE binop
    (101) binop -> binop . PLUS binop
    (102) binop -> binop . MINUS binop
    (103) binop -> binop . TIMES binop
    (104) binop -> binop . DIVIDE binop
    (105) binop -> binop . MOD binop
    (106) binop -> binop . NOT binop
    (107) binop -> binop . IN binop
    (108) binop -> binop . CONCAT binop

    AND             reduce using rule 96 (binop -> binop NEQ binop .)
    OR              reduce using rule 96 (binop -> binop NEQ binop .)
    EQ              reduce using rule 96 (binop -> binop NEQ binop .)
    NEQ             reduce using rule 96 (binop -> binop NEQ binop .)
    NOT             reduce using rule 96 (binop -> binop NEQ binop .)
    IN              reduce using rule 96 (binop -> binop NEQ binop .)
    CONCAT          reduce using rule 96 (binop -> binop NEQ binop .)
    ELSE            reduce using rule 96 (binop -> binop NEQ binop .)
    ELSIF           reduce using rule 96 (binop -> binop NEQ binop .)
    SEMI            reduce using rule 96 (binop -> binop NEQ binop .)
    THEN            reduce using rule 96 (binop -> binop NEQ binop .)
    RPAREN          reduce using rule 96 (binop -> binop NEQ binop .)
    COMMA           reduce using rule 96 (binop -> binop NEQ binop .)
    RBRACKET        reduce using rule 96 (binop -> binop NEQ binop .)
    COLON           reduce using rule 96 (binop -> binop NEQ binop .)
    DOWN            reduce using rule 96 (binop -> binop NEQ binop .)
    BY              reduce using rule 96 (binop -> binop NEQ binop .)
    TO              reduce using rule 96 (binop -> binop NEQ binop .)
    FI              reduce using rule 96 (binop -> binop NEQ binop .)
    WHILE           reduce using rule 96 (binop -> binop NEQ binop .)
    GT              shift and go to state 111
    GE              shift and go to state 115
    LT              shift and go to state 113
    LE              shift and go to state 116
    PLUS            shift and go to state 117
    MINUS           shift and go to state 114
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 112
    MOD             shift and go to state 118

  ! GT              [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! GE              [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! LT              [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! LE              [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! PLUS            [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! MINUS           [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! TIMES           [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! DIVIDE          [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! MOD             [ reduce using rule 96 (binop -> binop NEQ binop .) ]
  ! AND             [ shift and go to state 110 ]
  ! OR              [ shift and go to state 123 ]
  ! EQ              [ shift and go to state 122 ]
  ! NEQ             [ shift and go to state 125 ]
  ! NOT             [ shift and go to state 120 ]
  ! IN              [ shift and go to state 119 ]
  ! CONCAT          [ shift and go to state 124 ]


state 208

    (82) parenthesized_expression -> LPAREN expression RPAREN .

    AND             reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    MOD             reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    NOT             reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    IN              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    CONCAT          reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    SEMI            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    THEN            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    ELSIF           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    DOWN            reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    BY              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    TO              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    FI              reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 82 (parenthesized_expression -> LPAREN expression RPAREN .)


state 209

    (88) then_expression -> THEN . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 248
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 210

    (85) conditional_expression -> IF boolean_expression then_expression . else_expression FI
    (86) conditional_expression -> IF boolean_expression then_expression . elsif_expression else_expression FI
    (89) else_expression -> . ELSE expression
    (90) elsif_expression -> . ELSIF boolean_expression then_expression
    (91) elsif_expression -> . elsif_expression ELSIF boolean_expression then_expression

    ELSE            shift and go to state 249
    ELSIF           shift and go to state 251

    elsif_expression               shift and go to state 250
    else_expression                shift and go to state 252

state 211

    (79) value_array_element -> array_primitive_value LBRACKET expression_list . RBRACKET
    (67) expression_list -> expression_list . COMMA expression

    RBRACKET        shift and go to state 253
    COMMA           shift and go to state 230


state 212

    (80) value_array_slice -> array_primitive_value LBRACKET expression . COLON expression RBRACKET
    (66) expression_list -> expression .

    COLON           shift and go to state 254
    RBRACKET        reduce using rule 66 (expression_list -> expression .)
    COMMA           reduce using rule 66 (expression_list -> expression .)


state 213

    (144) do_action -> DO control_part SEMI OD .

    SEMI            reduce using rule 144 (do_action -> DO control_part SEMI OD .)


state 214

    (143) do_action -> DO control_part SEMI action_statement . OD

    OD              shift and go to state 255


state 215

    (160) range_enumeration -> loop_counter DOWN . IN discrete_mode_name

    IN              shift and go to state 256


state 216

    (161) range_enumeration -> loop_counter IN . discrete_mode_name
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    discrete_mode_name             shift and go to state 257
    identifier                     shift and go to state 258

state 217

    (151) step_enumeration -> loop_counter ASSIGN . start_value step_value DOWN end_value
    (152) step_enumeration -> loop_counter ASSIGN . start_value DOWN end_value
    (153) step_enumeration -> loop_counter ASSIGN . start_value step_value end_value
    (154) step_enumeration -> loop_counter ASSIGN . start_value end_value
    (156) start_value -> . discrete_expression
    (159) discrete_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    discrete_expression            shift and go to state 259
    operand                        shift and go to state 45
    value_array_element            shift and go to state 51
    literal                        shift and go to state 49
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    parenthesized_expression       shift and go to state 44
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    start_value                    shift and go to state 260
    identifier                     shift and go to state 62
    expression                     shift and go to state 261
    primitive_value                shift and go to state 64

state 218

    (173) builtin_call -> builtin_name LPAREN parameter_list RPAREN .

    SEMI            reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    ARROW           reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    LBRACKET        reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    PLUS            reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    MINUS           reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    TIMES           reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    DIVIDE          reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    MOD             reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    CONCAT          reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    ASSIGN          reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    AND             reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    OR              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    EQ              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    NEQ             reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    GT              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    GE              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    LT              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    LE              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    NOT             reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    IN              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    THEN            reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    RPAREN          reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    COMMA           reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    RBRACKET        reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    COLON           reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    ELSE            reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    ELSIF           reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    DOWN            reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    BY              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    TO              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    FI              reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)
    WHILE           reduce using rule 173 (builtin_call -> builtin_name LPAREN parameter_list RPAREN .)


state 219

    (168) parameter_list -> parameter_list COMMA . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    parenthesized_expression       shift and go to state 44
    identifier                     shift and go to state 62
    expression                     shift and go to state 262
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 220

    (11) declaration_list -> declaration_list COMMA declaration .

    SEMI            reduce using rule 11 (declaration_list -> declaration_list COMMA declaration .)
    COMMA           reduce using rule 11 (declaration_list -> declaration_list COMMA declaration .)


state 221

    (39) discrete_range_mode -> discrete_mode_name LPAREN . literal_range RPAREN
    (43) literal_range -> . ICONST COLON ICONST

    ICONST          shift and go to state 263

    literal_range                  shift and go to state 264

state 222

    (40) discrete_range_mode -> discrete_mode LPAREN . literal_range RPAREN
    (43) literal_range -> . ICONST COLON ICONST

    ICONST          shift and go to state 263

    literal_range                  shift and go to state 265

state 223

    (44) reference_mode -> REF mode .

    ASSIGN          reduce using rule 44 (reference_mode -> REF mode .)
    SEMI            reduce using rule 44 (reference_mode -> REF mode .)
    COMMA           reduce using rule 44 (reference_mode -> REF mode .)
    LOC             reduce using rule 44 (reference_mode -> REF mode .)
    RPAREN          reduce using rule 44 (reference_mode -> REF mode .)
    DCL             reduce using rule 44 (reference_mode -> REF mode .)
    SYN             reduce using rule 44 (reference_mode -> REF mode .)
    TYPE            reduce using rule 44 (reference_mode -> REF mode .)
    ID              reduce using rule 44 (reference_mode -> REF mode .)
    IF              reduce using rule 44 (reference_mode -> REF mode .)
    DO              reduce using rule 44 (reference_mode -> REF mode .)
    EXIT            reduce using rule 44 (reference_mode -> REF mode .)
    RETURN          reduce using rule 44 (reference_mode -> REF mode .)
    RESULT          reduce using rule 44 (reference_mode -> REF mode .)
    NUM             reduce using rule 44 (reference_mode -> REF mode .)
    PRED            reduce using rule 44 (reference_mode -> REF mode .)
    SUCC            reduce using rule 44 (reference_mode -> REF mode .)
    UPPER           reduce using rule 44 (reference_mode -> REF mode .)
    LOWER           reduce using rule 44 (reference_mode -> REF mode .)
    LENGTH          reduce using rule 44 (reference_mode -> REF mode .)
    READ            reduce using rule 44 (reference_mode -> REF mode .)
    PRINT           reduce using rule 44 (reference_mode -> REF mode .)
    $end            reduce using rule 44 (reference_mode -> REF mode .)
    END             reduce using rule 44 (reference_mode -> REF mode .)


state 224

    (16) identifier_list -> identifier_list COMMA identifier .

    COMMA           reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    REF             reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    ID              reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    INT             reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    BOOL            reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    CHAR            reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    CHARS           reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    ARRAY           reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)
    ASSIGN          reduce using rule 16 (identifier_list -> identifier_list COMMA identifier .)


state 225

    (49) array_mode -> ARRAY LBRACKET . index_mode RBRACKET element_mode
    (50) array_mode -> ARRAY LBRACKET . index_mode COMMA index_mode_list RBRACKET element_mode
    (53) index_mode -> . discrete_mode
    (54) index_mode -> . literal_range
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (43) literal_range -> . ICONST COLON ICONST
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ICONST          shift and go to state 263
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    ID              shift and go to state 31

    discrete_range_mode            shift and go to state 157
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    discrete_mode                  shift and go to state 266
    discrete_mode_name             shift and go to state 148
    integer_mode                   shift and go to state 156
    index_mode                     shift and go to state 267
    identifier                     shift and go to state 258
    literal_range                  shift and go to state 268

state 226

    (47) string_mode -> CHARS LBRACKET . string_length RBRACKET
    (48) string_length -> . ICONST

    ICONST          shift and go to state 269

    string_length                  shift and go to state 270

state 227

    (12) declaration -> identifier_list mode initialization .

    SEMI            reduce using rule 12 (declaration -> identifier_list mode initialization .)
    COMMA           reduce using rule 12 (declaration -> identifier_list mode initialization .)


state 228

    (14) initialization -> ASSIGN . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 271
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 229

    (68) array_slice -> location LBRACKET ICONST COLON . ICONST RBRACKET

    ICONST          shift and go to state 272


state 230

    (67) expression_list -> expression_list COMMA . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 273
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 231

    (65) array_element -> location LBRACKET expression_list RBRACKET .

    ARROW           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    LBRACKET        reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    AND             reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    OR              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    EQ              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    NEQ             reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    GT              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    GE              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    LT              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    LE              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    PLUS            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    MINUS           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    TIMES           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    DIVIDE          reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    MOD             reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    NOT             reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    IN              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    CONCAT          reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    SEMI            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    THEN            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    RPAREN          reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    COMMA           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    RBRACKET        reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    COLON           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    ELSE            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    ELSIF           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    DOWN            reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    BY              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    TO              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    FI              reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    WHILE           reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)
    ASSIGN          reduce using rule 65 (array_element -> location LBRACKET expression_list RBRACKET .)


state 232

    (137) then_clause -> THEN action_statement .

    ELSE            reduce using rule 137 (then_clause -> THEN action_statement .)
    ELSIF           reduce using rule 137 (then_clause -> THEN action_statement .)
    FI              reduce using rule 137 (then_clause -> THEN action_statement .)


state 233

    (141) else_clause -> ELSIF . boolean_expression then_clause else_clause
    (142) else_clause -> ELSIF . boolean_expression then_clause
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    boolean_expression             shift and go to state 274
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 90
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 234

    (139) else_clause -> ELSE . action_statement
    (140) else_clause -> ELSE .
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    FI              reduce using rule 140 (else_clause -> ELSE .)
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    result_action                  shift and go to state 7
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    return_action                  shift and go to state 11
    location                       shift and go to state 21
    exit_action                    shift and go to state 28
    builtin_call                   shift and go to state 24
    call_action                    shift and go to state 25
    dereferenced_reference         shift and go to state 34
    action_statement               shift and go to state 275
    builtin_name                   shift and go to state 8
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 70

state 235

    (135) if_action -> IF boolean_expression then_clause else_clause . FI

    FI              shift and go to state 276


state 236

    (136) if_action -> IF boolean_expression then_clause FI .

    SEMI            reduce using rule 136 (if_action -> IF boolean_expression then_clause FI .)


state 237

    (26) newmode_list -> newmode_list COMMA mode_definition .

    COMMA           reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    DCL             reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    SYN             reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    TYPE            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    ID              reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    IF              reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    DO              reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    EXIT            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    RETURN          reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    RESULT          reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    NUM             reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    PRED            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    SUCC            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    UPPER           reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    LOWER           reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    LENGTH          reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    READ            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    PRINT           reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    $end            reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)
    END             reduce using rule 26 (newmode_list -> newmode_list COMMA mode_definition .)


state 238

    (20) synonym_list -> synonym_list COMMA synonym_definition .

    SEMI            reduce using rule 20 (synonym_list -> synonym_list COMMA synonym_definition .)
    COMMA           reduce using rule 20 (synonym_list -> synonym_list COMMA synonym_definition .)


state 239

    (22) synonym_definition -> identifier_list ASSIGN constant_expression .

    SEMI            reduce using rule 22 (synonym_definition -> identifier_list ASSIGN constant_expression .)
    COMMA           reduce using rule 22 (synonym_definition -> identifier_list ASSIGN constant_expression .)


state 240

    (23) constant_expression -> expression .

    SEMI            reduce using rule 23 (constant_expression -> expression .)
    COMMA           reduce using rule 23 (constant_expression -> expression .)


state 241

    (21) synonym_definition -> identifier_list mode ASSIGN . constant_expression
    (23) constant_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    identifier                     shift and go to state 62
    primitive_value                shift and go to state 64
    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    expression                     shift and go to state 240
    constant_expression            shift and go to state 277
    value_array_element            shift and go to state 51

state 242

    (64) string_slice -> identifier LBRACKET ICONST COLON . ICONST RBRACKET

    ICONST          shift and go to state 278


state 243

    (63) string_element -> identifier LBRACKET ICONST RBRACKET .

    ARROW           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    LBRACKET        reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    PLUS            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    MINUS           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    TIMES           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    DIVIDE          reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    MOD             reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    CONCAT          reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    ASSIGN          reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    AND             reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    OR              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    EQ              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    NEQ             reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    GT              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    GE              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    LT              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    LE              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    NOT             reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    IN              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    SEMI            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    THEN            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    RPAREN          reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    COMMA           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    RBRACKET        reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    COLON           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    ELSE            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    ELSIF           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    DOWN            reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    BY              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    TO              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    FI              reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)
    WHILE           reduce using rule 63 (string_element -> identifier LBRACKET ICONST RBRACKET .)


state 244

    (117) action_statement -> identifier COLON action SEMI .

    OD              reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    END             reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    DCL             reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    SYN             reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    TYPE            reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    ID              reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    IF              reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    DO              reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    EXIT            reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    RETURN          reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    RESULT          reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    NUM             reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    PRED            reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    SUCC            reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    UPPER           reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    LOWER           reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    LENGTH          reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    READ            reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    PRINT           reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    FI              reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    ELSE            reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    ELSIF           reduce using rule 117 (action_statement -> identifier COLON action SEMI .)
    $end            reduce using rule 117 (action_statement -> identifier COLON action SEMI .)


state 245

    (183) procedure_statement -> identifier COLON procedure_definition SEMI .

    END             reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    DCL             reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    SYN             reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    TYPE            reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    ID              reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    IF              reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    DO              reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    EXIT            reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    RETURN          reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    RESULT          reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    NUM             reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    PRED            reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    SUCC            reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    UPPER           reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    LOWER           reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    LENGTH          reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    READ            reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    PRINT           reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)
    $end            reduce using rule 183 (procedure_statement -> identifier COLON procedure_definition SEMI .)


state 246

    (184) procedure_definition -> PROC LPAREN . formal_parameter_list RPAREN result_spec SEMI statement_list END
    (185) procedure_definition -> PROC LPAREN . formal_parameter_list RPAREN SEMI statement_list END
    (186) procedure_definition -> PROC LPAREN . RPAREN SEMI statement_list END
    (187) formal_parameter_list -> . formal_parameter
    (188) formal_parameter_list -> . formal_parameter_list COMMA formal_parameter
    (189) formal_parameter -> . identifier_list parameter_spec
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    RPAREN          shift and go to state 280
    ID              shift and go to state 31

    formal_parameter_list          shift and go to state 279
    identifier                     shift and go to state 73
    formal_parameter               shift and go to state 281
    identifier_list                shift and go to state 282

state 247

    (165) procedure_call -> identifier LPAREN parameter_list RPAREN .

    SEMI            reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    ARROW           reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    LBRACKET        reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    PLUS            reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    MINUS           reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    TIMES           reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    DIVIDE          reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    MOD             reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    CONCAT          reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    ASSIGN          reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    AND             reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    OR              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    EQ              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    NEQ             reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    GT              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    GE              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    LT              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    LE              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    NOT             reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    IN              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    THEN            reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    RPAREN          reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    COMMA           reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    RBRACKET        reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    COLON           reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    ELSE            reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    ELSIF           reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    DOWN            reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    BY              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    TO              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    FI              reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)
    WHILE           reduce using rule 165 (procedure_call -> identifier LPAREN parameter_list RPAREN .)


state 248

    (88) then_expression -> THEN expression .

    ELSIF           reduce using rule 88 (then_expression -> THEN expression .)
    ELSE            reduce using rule 88 (then_expression -> THEN expression .)


state 249

    (89) else_expression -> ELSE . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 283
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 250

    (86) conditional_expression -> IF boolean_expression then_expression elsif_expression . else_expression FI
    (91) elsif_expression -> elsif_expression . ELSIF boolean_expression then_expression
    (89) else_expression -> . ELSE expression

    ELSIF           shift and go to state 284
    ELSE            shift and go to state 249

    else_expression                shift and go to state 285

state 251

    (90) elsif_expression -> ELSIF . boolean_expression then_expression
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    boolean_expression             shift and go to state 286
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 90
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 252

    (85) conditional_expression -> IF boolean_expression then_expression else_expression . FI

    FI              shift and go to state 287


state 253

    (79) value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .

    AND             reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    OR              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    EQ              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    NEQ             reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    GT              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    GE              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    LT              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    LE              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    PLUS            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    MINUS           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    TIMES           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    DIVIDE          reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    MOD             reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    NOT             reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    IN              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    CONCAT          reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    SEMI            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    THEN            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    RPAREN          reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    COMMA           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    RBRACKET        reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    COLON           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    ELSE            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    ELSIF           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    DOWN            reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    BY              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    TO              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    FI              reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    WHILE           reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)
    LBRACKET        reduce using rule 79 (value_array_element -> array_primitive_value LBRACKET expression_list RBRACKET .)


state 254

    (80) value_array_slice -> array_primitive_value LBRACKET expression COLON . expression RBRACKET
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    literal                        shift and go to state 49
    array_primitive_value          shift and go to state 58
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 288
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 255

    (143) do_action -> DO control_part SEMI action_statement OD .

    SEMI            reduce using rule 143 (do_action -> DO control_part SEMI action_statement OD .)


state 256

    (160) range_enumeration -> loop_counter DOWN IN . discrete_mode_name
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    discrete_mode_name             shift and go to state 289
    identifier                     shift and go to state 258

state 257

    (161) range_enumeration -> loop_counter IN discrete_mode_name .

    WHILE           reduce using rule 161 (range_enumeration -> loop_counter IN discrete_mode_name .)


state 258

    (42) discrete_mode_name -> identifier .

    WHILE           reduce using rule 42 (discrete_mode_name -> identifier .)
    LPAREN          reduce using rule 42 (discrete_mode_name -> identifier .)


state 259

    (156) start_value -> discrete_expression .

    DOWN            reduce using rule 156 (start_value -> discrete_expression .)
    BY              reduce using rule 156 (start_value -> discrete_expression .)
    TO              reduce using rule 156 (start_value -> discrete_expression .)


state 260

    (151) step_enumeration -> loop_counter ASSIGN start_value . step_value DOWN end_value
    (152) step_enumeration -> loop_counter ASSIGN start_value . DOWN end_value
    (153) step_enumeration -> loop_counter ASSIGN start_value . step_value end_value
    (154) step_enumeration -> loop_counter ASSIGN start_value . end_value
    (157) step_value -> . BY ICONST
    (158) end_value -> . TO discrete_expression

    DOWN            shift and go to state 293
    BY              shift and go to state 292
    TO              shift and go to state 294

    end_value                      shift and go to state 290
    step_value                     shift and go to state 291

state 261

    (159) discrete_expression -> expression .

    DOWN            reduce using rule 159 (discrete_expression -> expression .)
    BY              reduce using rule 159 (discrete_expression -> expression .)
    TO              reduce using rule 159 (discrete_expression -> expression .)
    WHILE           reduce using rule 159 (discrete_expression -> expression .)


state 262

    (168) parameter_list -> parameter_list COMMA expression .

    RPAREN          reduce using rule 168 (parameter_list -> parameter_list COMMA expression .)
    COMMA           reduce using rule 168 (parameter_list -> parameter_list COMMA expression .)


state 263

    (43) literal_range -> ICONST . COLON ICONST

    COLON           shift and go to state 295


state 264

    (39) discrete_range_mode -> discrete_mode_name LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 296


state 265

    (40) discrete_range_mode -> discrete_mode LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 297


state 266

    (53) index_mode -> discrete_mode .
    (40) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    RBRACKET        reduce using rule 53 (index_mode -> discrete_mode .)
    COMMA           reduce using rule 53 (index_mode -> discrete_mode .)
    LPAREN          shift and go to state 222


state 267

    (49) array_mode -> ARRAY LBRACKET index_mode . RBRACKET element_mode
    (50) array_mode -> ARRAY LBRACKET index_mode . COMMA index_mode_list RBRACKET element_mode

    RBRACKET        shift and go to state 298
    COMMA           shift and go to state 299


state 268

    (54) index_mode -> literal_range .

    RBRACKET        reduce using rule 54 (index_mode -> literal_range .)
    COMMA           reduce using rule 54 (index_mode -> literal_range .)


state 269

    (48) string_length -> ICONST .

    RBRACKET        reduce using rule 48 (string_length -> ICONST .)


state 270

    (47) string_mode -> CHARS LBRACKET string_length . RBRACKET

    RBRACKET        shift and go to state 300


state 271

    (14) initialization -> ASSIGN expression .

    SEMI            reduce using rule 14 (initialization -> ASSIGN expression .)
    COMMA           reduce using rule 14 (initialization -> ASSIGN expression .)


state 272

    (68) array_slice -> location LBRACKET ICONST COLON ICONST . RBRACKET

    RBRACKET        shift and go to state 301


state 273

    (67) expression_list -> expression_list COMMA expression .

    RBRACKET        reduce using rule 67 (expression_list -> expression_list COMMA expression .)
    COMMA           reduce using rule 67 (expression_list -> expression_list COMMA expression .)


state 274

    (141) else_clause -> ELSIF boolean_expression . then_clause else_clause
    (142) else_clause -> ELSIF boolean_expression . then_clause
    (137) then_clause -> . THEN action_statement
    (138) then_clause -> . THEN

    THEN            shift and go to state 175

    then_clause                    shift and go to state 302

state 275

    (139) else_clause -> ELSE action_statement .

    FI              reduce using rule 139 (else_clause -> ELSE action_statement .)


state 276

    (135) if_action -> IF boolean_expression then_clause else_clause FI .

    SEMI            reduce using rule 135 (if_action -> IF boolean_expression then_clause else_clause FI .)


state 277

    (21) synonym_definition -> identifier_list mode ASSIGN constant_expression .

    SEMI            reduce using rule 21 (synonym_definition -> identifier_list mode ASSIGN constant_expression .)
    COMMA           reduce using rule 21 (synonym_definition -> identifier_list mode ASSIGN constant_expression .)


state 278

    (64) string_slice -> identifier LBRACKET ICONST COLON ICONST . RBRACKET

    RBRACKET        shift and go to state 303


state 279

    (184) procedure_definition -> PROC LPAREN formal_parameter_list . RPAREN result_spec SEMI statement_list END
    (185) procedure_definition -> PROC LPAREN formal_parameter_list . RPAREN SEMI statement_list END
    (188) formal_parameter_list -> formal_parameter_list . COMMA formal_parameter

    RPAREN          shift and go to state 304
    COMMA           shift and go to state 305


state 280

    (186) procedure_definition -> PROC LPAREN RPAREN . SEMI statement_list END

    SEMI            shift and go to state 306


state 281

    (187) formal_parameter_list -> formal_parameter .

    RPAREN          reduce using rule 187 (formal_parameter_list -> formal_parameter .)
    COMMA           reduce using rule 187 (formal_parameter_list -> formal_parameter .)


state 282

    (189) formal_parameter -> identifier_list . parameter_spec
    (16) identifier_list -> identifier_list . COMMA identifier
    (191) parameter_spec -> . mode LOC
    (192) parameter_spec -> . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    COMMA           shift and go to state 154
    REF             shift and go to state 150
    ID              shift and go to state 31
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    CHARS           shift and go to state 158
    ARRAY           shift and go to state 155

    string_mode                    shift and go to state 152
    identifier                     shift and go to state 164
    array_mode                     shift and go to state 151
    discrete_range_mode            shift and go to state 157
    discrete_mode_name             shift and go to state 148
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    reference_mode                 shift and go to state 147
    composite_mode                 shift and go to state 161
    integer_mode                   shift and go to state 156
    mode                           shift and go to state 308
    parameter_spec                 shift and go to state 307
    discrete_mode                  shift and go to state 149
    mode_name                      shift and go to state 153

state 283

    (89) else_expression -> ELSE expression .

    FI              reduce using rule 89 (else_expression -> ELSE expression .)


state 284

    (91) elsif_expression -> elsif_expression ELSIF . boolean_expression then_expression
    (87) boolean_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    binop                          shift and go to state 53
    boolean_expression             shift and go to state 309
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 90
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 285

    (86) conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression . FI

    FI              shift and go to state 310


state 286

    (90) elsif_expression -> ELSIF boolean_expression . then_expression
    (88) then_expression -> . THEN expression

    THEN            shift and go to state 209

    then_expression                shift and go to state 311

state 287

    (85) conditional_expression -> IF boolean_expression then_expression else_expression FI .

    SEMI            reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    RPAREN          reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    COMMA           reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    RBRACKET        reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    THEN            reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    FI              reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    COLON           reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    WHILE           reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    DOWN            reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    BY              reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    TO              reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    ELSE            reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)
    ELSIF           reduce using rule 85 (conditional_expression -> IF boolean_expression then_expression else_expression FI .)


state 288

    (80) value_array_slice -> array_primitive_value LBRACKET expression COLON expression . RBRACKET

    RBRACKET        shift and go to state 312


state 289

    (160) range_enumeration -> loop_counter DOWN IN discrete_mode_name .

    WHILE           reduce using rule 160 (range_enumeration -> loop_counter DOWN IN discrete_mode_name .)


state 290

    (154) step_enumeration -> loop_counter ASSIGN start_value end_value .

    WHILE           reduce using rule 154 (step_enumeration -> loop_counter ASSIGN start_value end_value .)


state 291

    (151) step_enumeration -> loop_counter ASSIGN start_value step_value . DOWN end_value
    (153) step_enumeration -> loop_counter ASSIGN start_value step_value . end_value
    (158) end_value -> . TO discrete_expression

    DOWN            shift and go to state 314
    TO              shift and go to state 294

    end_value                      shift and go to state 313

state 292

    (157) step_value -> BY . ICONST

    ICONST          shift and go to state 315


state 293

    (152) step_enumeration -> loop_counter ASSIGN start_value DOWN . end_value
    (158) end_value -> . TO discrete_expression

    TO              shift and go to state 294

    end_value                      shift and go to state 316

state 294

    (158) end_value -> TO . discrete_expression
    (159) discrete_expression -> . expression
    (83) expression -> . binop
    (84) expression -> . conditional_expression
    (92) binop -> . operand
    (93) binop -> . binop AND binop
    (94) binop -> . binop OR binop
    (95) binop -> . binop EQ binop
    (96) binop -> . binop NEQ binop
    (97) binop -> . binop GT binop
    (98) binop -> . binop GE binop
    (99) binop -> . binop LT binop
    (100) binop -> . binop LE binop
    (101) binop -> . binop PLUS binop
    (102) binop -> . binop MINUS binop
    (103) binop -> . binop TIMES binop
    (104) binop -> . binop DIVIDE binop
    (105) binop -> . binop MOD binop
    (106) binop -> . binop NOT binop
    (107) binop -> . binop IN binop
    (108) binop -> . binop CONCAT binop
    (85) conditional_expression -> . IF boolean_expression then_expression else_expression FI
    (86) conditional_expression -> . IF boolean_expression then_expression elsif_expression else_expression FI
    (109) operand -> . MINUS operand1
    (110) operand -> . NOT operand1
    (111) operand -> . primitive_value
    (112) operand -> . identifier
    (69) primitive_value -> . literal
    (70) primitive_value -> . value_array_element
    (71) primitive_value -> . value_array_slice
    (72) primitive_value -> . parenthesized_expression
    (17) identifier -> . ID
    (73) literal -> . ICONST
    (74) literal -> . FALSE
    (75) literal -> . TRUE
    (76) literal -> . CCONST
    (77) literal -> . NULL
    (78) literal -> . SCONST
    (79) value_array_element -> . array_primitive_value LBRACKET expression_list RBRACKET
    (80) value_array_slice -> . array_primitive_value LBRACKET expression COLON expression RBRACKET
    (82) parenthesized_expression -> . LPAREN expression RPAREN
    (81) array_primitive_value -> . primitive_value

    IF              shift and go to state 56
    MINUS           shift and go to state 48
    NOT             shift and go to state 61
    ID              shift and go to state 31
    ICONST          shift and go to state 54
    FALSE           shift and go to state 57
    TRUE            shift and go to state 47
    CCONST          shift and go to state 52
    NULL            shift and go to state 46
    SCONST          shift and go to state 50
    LPAREN          shift and go to state 55

    parenthesized_expression       shift and go to state 44
    discrete_expression            shift and go to state 317
    binop                          shift and go to state 53
    array_primitive_value          shift and go to state 58
    literal                        shift and go to state 49
    value_array_slice              shift and go to state 59
    conditional_expression         shift and go to state 60
    operand                        shift and go to state 45
    identifier                     shift and go to state 62
    expression                     shift and go to state 261
    primitive_value                shift and go to state 64
    value_array_element            shift and go to state 51

state 295

    (43) literal_range -> ICONST COLON . ICONST

    ICONST          shift and go to state 318


state 296

    (39) discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    DCL             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SYN             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    TYPE            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    ID              reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    IF              reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    DO              reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    EXIT            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RETURN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RESULT          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    NUM             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    PRED            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SUCC            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    UPPER           reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    LOWER           reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    LENGTH          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    READ            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    PRINT           reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    $end            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    END             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    LOC             reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RPAREN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)


state 297

    (40) discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    DCL             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SYN             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    TYPE            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    ID              reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    IF              reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    DO              reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    EXIT            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RETURN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RESULT          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    NUM             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    PRED            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SUCC            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    UPPER           reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    LOWER           reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    LENGTH          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    READ            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    PRINT           reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    $end            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    END             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    LOC             reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RPAREN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)


state 298

    (49) array_mode -> ARRAY LBRACKET index_mode RBRACKET . element_mode
    (55) element_mode -> . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    REF             shift and go to state 150
    ID              shift and go to state 31
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    CHARS           shift and go to state 158
    ARRAY           shift and go to state 155

    string_mode                    shift and go to state 152
    array_mode                     shift and go to state 151
    reference_mode                 shift and go to state 147
    discrete_range_mode            shift and go to state 157
    discrete_mode_name             shift and go to state 148
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    discrete_mode                  shift and go to state 149
    composite_mode                 shift and go to state 161
    integer_mode                   shift and go to state 156
    mode                           shift and go to state 320
    element_mode                   shift and go to state 319
    identifier                     shift and go to state 164
    mode_name                      shift and go to state 153

state 299

    (50) array_mode -> ARRAY LBRACKET index_mode COMMA . index_mode_list RBRACKET element_mode
    (51) index_mode_list -> . index_mode
    (52) index_mode_list -> . index_mode_list COMMA index_mode
    (53) index_mode -> . discrete_mode
    (54) index_mode -> . literal_range
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (43) literal_range -> . ICONST COLON ICONST
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ICONST          shift and go to state 263
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    ID              shift and go to state 31

    discrete_range_mode            shift and go to state 157
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    discrete_mode                  shift and go to state 266
    discrete_mode_name             shift and go to state 148
    integer_mode                   shift and go to state 156
    index_mode                     shift and go to state 321
    identifier                     shift and go to state 258
    literal_range                  shift and go to state 268
    index_mode_list                shift and go to state 322

state 300

    (47) string_mode -> CHARS LBRACKET string_length RBRACKET .

    LOC             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    RPAREN          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    COMMA           reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    ASSIGN          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    SEMI            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    DCL             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    SYN             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    TYPE            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    ID              reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    IF              reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    DO              reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    EXIT            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    RETURN          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    RESULT          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    NUM             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    PRED            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    SUCC            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    UPPER           reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    LOWER           reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    LENGTH          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    READ            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    PRINT           reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    $end            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    END             reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)


state 301

    (68) array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .

    ARROW           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    LBRACKET        reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    PLUS            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    MINUS           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    TIMES           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    DIVIDE          reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    MOD             reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    CONCAT          reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    ASSIGN          reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    AND             reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    OR              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    EQ              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    NEQ             reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    GT              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    GE              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    LT              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    LE              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    NOT             reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    IN              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    SEMI            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    THEN            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    RPAREN          reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    COMMA           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    RBRACKET        reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    COLON           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    ELSE            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    ELSIF           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    DOWN            reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    BY              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    TO              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    FI              reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)
    WHILE           reduce using rule 68 (array_slice -> location LBRACKET ICONST COLON ICONST RBRACKET .)


state 302

    (141) else_clause -> ELSIF boolean_expression then_clause . else_clause
    (142) else_clause -> ELSIF boolean_expression then_clause .
    (139) else_clause -> . ELSE action_statement
    (140) else_clause -> . ELSE
    (141) else_clause -> . ELSIF boolean_expression then_clause else_clause
    (142) else_clause -> . ELSIF boolean_expression then_clause

    FI              reduce using rule 142 (else_clause -> ELSIF boolean_expression then_clause .)
    ELSE            shift and go to state 234
    ELSIF           shift and go to state 233

    else_clause                    shift and go to state 323

state 303

    (64) string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .

    ARROW           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    LBRACKET        reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    PLUS            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    MINUS           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    TIMES           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    DIVIDE          reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    MOD             reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    CONCAT          reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    ASSIGN          reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    AND             reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    OR              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    EQ              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    NEQ             reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    GT              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    GE              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    LT              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    LE              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    NOT             reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    IN              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    SEMI            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    THEN            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    RPAREN          reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    COMMA           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    RBRACKET        reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    COLON           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    ELSE            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    ELSIF           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    DOWN            reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    BY              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    TO              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    FI              reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)
    WHILE           reduce using rule 64 (string_slice -> identifier LBRACKET ICONST COLON ICONST RBRACKET .)


state 304

    (184) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN . result_spec SEMI statement_list END
    (185) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN . SEMI statement_list END
    (190) result_spec -> . RETURNS LPAREN parameter_spec RPAREN

    SEMI            shift and go to state 324
    RETURNS         shift and go to state 325

    result_spec                    shift and go to state 326

state 305

    (188) formal_parameter_list -> formal_parameter_list COMMA . formal_parameter
    (189) formal_parameter -> . identifier_list parameter_spec
    (15) identifier_list -> . identifier
    (16) identifier_list -> . identifier_list COMMA identifier
    (17) identifier -> . ID

    ID              shift and go to state 31

    identifier_list                shift and go to state 282
    identifier                     shift and go to state 73
    formal_parameter               shift and go to state 327

state 306

    (186) procedure_definition -> PROC LPAREN RPAREN SEMI . statement_list END
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (183) procedure_statement -> . identifier COLON procedure_definition SEMI
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 22
    statement_list                 shift and go to state 328
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 307

    (189) formal_parameter -> identifier_list parameter_spec .

    RPAREN          reduce using rule 189 (formal_parameter -> identifier_list parameter_spec .)
    COMMA           reduce using rule 189 (formal_parameter -> identifier_list parameter_spec .)


state 308

    (191) parameter_spec -> mode . LOC
    (192) parameter_spec -> mode .

    LOC             shift and go to state 329
    RPAREN          reduce using rule 192 (parameter_spec -> mode .)
    COMMA           reduce using rule 192 (parameter_spec -> mode .)


state 309

    (91) elsif_expression -> elsif_expression ELSIF boolean_expression . then_expression
    (88) then_expression -> . THEN expression

    THEN            shift and go to state 209

    then_expression                shift and go to state 330

state 310

    (86) conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .

    SEMI            reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    RPAREN          reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    COMMA           reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    RBRACKET        reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    THEN            reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    FI              reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    COLON           reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    WHILE           reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    DOWN            reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    BY              reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    TO              reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    ELSE            reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)
    ELSIF           reduce using rule 86 (conditional_expression -> IF boolean_expression then_expression elsif_expression else_expression FI .)


state 311

    (90) elsif_expression -> ELSIF boolean_expression then_expression .

    ELSIF           reduce using rule 90 (elsif_expression -> ELSIF boolean_expression then_expression .)
    ELSE            reduce using rule 90 (elsif_expression -> ELSIF boolean_expression then_expression .)


state 312

    (80) value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .

    AND             reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    OR              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    EQ              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    NEQ             reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    GT              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    GE              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    LT              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    LE              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    PLUS            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    MINUS           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    TIMES           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    DIVIDE          reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    MOD             reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    NOT             reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    IN              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    CONCAT          reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    COLON           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    RBRACKET        reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    COMMA           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    LBRACKET        reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    RPAREN          reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    SEMI            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    THEN            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    ELSE            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    ELSIF           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    DOWN            reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    BY              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    TO              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    FI              reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)
    WHILE           reduce using rule 80 (value_array_slice -> array_primitive_value LBRACKET expression COLON expression RBRACKET .)


state 313

    (153) step_enumeration -> loop_counter ASSIGN start_value step_value end_value .

    WHILE           reduce using rule 153 (step_enumeration -> loop_counter ASSIGN start_value step_value end_value .)


state 314

    (151) step_enumeration -> loop_counter ASSIGN start_value step_value DOWN . end_value
    (158) end_value -> . TO discrete_expression

    TO              shift and go to state 294

    end_value                      shift and go to state 331

state 315

    (157) step_value -> BY ICONST .

    DOWN            reduce using rule 157 (step_value -> BY ICONST .)
    TO              reduce using rule 157 (step_value -> BY ICONST .)


state 316

    (152) step_enumeration -> loop_counter ASSIGN start_value DOWN end_value .

    WHILE           reduce using rule 152 (step_enumeration -> loop_counter ASSIGN start_value DOWN end_value .)


state 317

    (158) end_value -> TO discrete_expression .

    WHILE           reduce using rule 158 (end_value -> TO discrete_expression .)


state 318

    (43) literal_range -> ICONST COLON ICONST .

    RPAREN          reduce using rule 43 (literal_range -> ICONST COLON ICONST .)
    RBRACKET        reduce using rule 43 (literal_range -> ICONST COLON ICONST .)
    COMMA           reduce using rule 43 (literal_range -> ICONST COLON ICONST .)


state 319

    (49) array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .

    LOC             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    RPAREN          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    ASSIGN          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    SEMI            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    COMMA           reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    DCL             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    SYN             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    TYPE            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    ID              reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    IF              reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    DO              reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    EXIT            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    RETURN          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    RESULT          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    NUM             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    PRED            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    SUCC            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    UPPER           reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    LOWER           reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    LENGTH          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    READ            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    PRINT           reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    $end            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)
    END             reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode RBRACKET element_mode .)


state 320

    (55) element_mode -> mode .

    ASSIGN          reduce using rule 55 (element_mode -> mode .)
    SEMI            reduce using rule 55 (element_mode -> mode .)
    COMMA           reduce using rule 55 (element_mode -> mode .)
    DCL             reduce using rule 55 (element_mode -> mode .)
    SYN             reduce using rule 55 (element_mode -> mode .)
    TYPE            reduce using rule 55 (element_mode -> mode .)
    ID              reduce using rule 55 (element_mode -> mode .)
    IF              reduce using rule 55 (element_mode -> mode .)
    DO              reduce using rule 55 (element_mode -> mode .)
    EXIT            reduce using rule 55 (element_mode -> mode .)
    RETURN          reduce using rule 55 (element_mode -> mode .)
    RESULT          reduce using rule 55 (element_mode -> mode .)
    NUM             reduce using rule 55 (element_mode -> mode .)
    PRED            reduce using rule 55 (element_mode -> mode .)
    SUCC            reduce using rule 55 (element_mode -> mode .)
    UPPER           reduce using rule 55 (element_mode -> mode .)
    LOWER           reduce using rule 55 (element_mode -> mode .)
    LENGTH          reduce using rule 55 (element_mode -> mode .)
    READ            reduce using rule 55 (element_mode -> mode .)
    PRINT           reduce using rule 55 (element_mode -> mode .)
    $end            reduce using rule 55 (element_mode -> mode .)
    END             reduce using rule 55 (element_mode -> mode .)
    LOC             reduce using rule 55 (element_mode -> mode .)
    RPAREN          reduce using rule 55 (element_mode -> mode .)


state 321

    (51) index_mode_list -> index_mode .

    RBRACKET        reduce using rule 51 (index_mode_list -> index_mode .)
    COMMA           reduce using rule 51 (index_mode_list -> index_mode .)


state 322

    (50) array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list . RBRACKET element_mode
    (52) index_mode_list -> index_mode_list . COMMA index_mode

    RBRACKET        shift and go to state 333
    COMMA           shift and go to state 332


state 323

    (141) else_clause -> ELSIF boolean_expression then_clause else_clause .

    FI              reduce using rule 141 (else_clause -> ELSIF boolean_expression then_clause else_clause .)


state 324

    (185) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI . statement_list END
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (183) procedure_statement -> . identifier COLON procedure_definition SEMI
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 22
    statement_list                 shift and go to state 334
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 325

    (190) result_spec -> RETURNS . LPAREN parameter_spec RPAREN

    LPAREN          shift and go to state 335


state 326

    (184) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec . SEMI statement_list END

    SEMI            shift and go to state 336


state 327

    (188) formal_parameter_list -> formal_parameter_list COMMA formal_parameter .

    RPAREN          reduce using rule 188 (formal_parameter_list -> formal_parameter_list COMMA formal_parameter .)
    COMMA           reduce using rule 188 (formal_parameter_list -> formal_parameter_list COMMA formal_parameter .)


state 328

    (186) procedure_definition -> PROC LPAREN RPAREN SEMI statement_list . END
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (183) procedure_statement -> . identifier COLON procedure_definition SEMI
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    END             shift and go to state 337
    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 87
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 329

    (191) parameter_spec -> mode LOC .

    RPAREN          reduce using rule 191 (parameter_spec -> mode LOC .)
    COMMA           reduce using rule 191 (parameter_spec -> mode LOC .)


state 330

    (91) elsif_expression -> elsif_expression ELSIF boolean_expression then_expression .

    ELSIF           reduce using rule 91 (elsif_expression -> elsif_expression ELSIF boolean_expression then_expression .)
    ELSE            reduce using rule 91 (elsif_expression -> elsif_expression ELSIF boolean_expression then_expression .)


state 331

    (151) step_enumeration -> loop_counter ASSIGN start_value step_value DOWN end_value .

    WHILE           reduce using rule 151 (step_enumeration -> loop_counter ASSIGN start_value step_value DOWN end_value .)


state 332

    (52) index_mode_list -> index_mode_list COMMA . index_mode
    (53) index_mode -> . discrete_mode
    (54) index_mode -> . literal_range
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (43) literal_range -> . ICONST COLON ICONST
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (42) discrete_mode_name -> . identifier
    (17) identifier -> . ID

    ICONST          shift and go to state 263
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    ID              shift and go to state 31

    discrete_range_mode            shift and go to state 157
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    discrete_mode                  shift and go to state 266
    discrete_mode_name             shift and go to state 148
    integer_mode                   shift and go to state 156
    index_mode                     shift and go to state 338
    literal_range                  shift and go to state 268
    identifier                     shift and go to state 258

state 333

    (50) array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET . element_mode
    (55) element_mode -> . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    REF             shift and go to state 150
    ID              shift and go to state 31
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    CHARS           shift and go to state 158
    ARRAY           shift and go to state 155

    string_mode                    shift and go to state 152
    array_mode                     shift and go to state 151
    reference_mode                 shift and go to state 147
    discrete_range_mode            shift and go to state 157
    discrete_mode_name             shift and go to state 148
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    discrete_mode                  shift and go to state 149
    composite_mode                 shift and go to state 161
    integer_mode                   shift and go to state 156
    mode                           shift and go to state 320
    element_mode                   shift and go to state 339
    identifier                     shift and go to state 164
    mode_name                      shift and go to state 153

state 334

    (185) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_list . END
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (183) procedure_statement -> . identifier COLON procedure_definition SEMI
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    END             shift and go to state 340
    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 87
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 335

    (190) result_spec -> RETURNS LPAREN . parameter_spec RPAREN
    (191) parameter_spec -> . mode LOC
    (192) parameter_spec -> . mode
    (28) mode -> . mode_name
    (29) mode -> . discrete_mode
    (30) mode -> . reference_mode
    (31) mode -> . composite_mode
    (41) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (17) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode RBRACKET element_mode
    (50) array_mode -> . ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode
    (42) discrete_mode_name -> . identifier

    REF             shift and go to state 150
    ID              shift and go to state 31
    INT             shift and go to state 160
    BOOL            shift and go to state 162
    CHAR            shift and go to state 146
    CHARS           shift and go to state 158
    ARRAY           shift and go to state 155

    string_mode                    shift and go to state 152
    array_mode                     shift and go to state 151
    discrete_range_mode            shift and go to state 157
    discrete_mode_name             shift and go to state 148
    boolean_mode                   shift and go to state 145
    character_mode                 shift and go to state 159
    reference_mode                 shift and go to state 147
    composite_mode                 shift and go to state 161
    integer_mode                   shift and go to state 156
    mode                           shift and go to state 308
    parameter_spec                 shift and go to state 341
    discrete_mode                  shift and go to state 149
    identifier                     shift and go to state 164
    mode_name                      shift and go to state 153

state 336

    (184) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI . statement_list END
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (183) procedure_statement -> . identifier COLON procedure_definition SEMI
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 22
    statement_list                 shift and go to state 342
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 337

    (186) procedure_definition -> PROC LPAREN RPAREN SEMI statement_list END .

    SEMI            reduce using rule 186 (procedure_definition -> PROC LPAREN RPAREN SEMI statement_list END .)


state 338

    (52) index_mode_list -> index_mode_list COMMA index_mode .

    RBRACKET        reduce using rule 52 (index_mode_list -> index_mode_list COMMA index_mode .)
    COMMA           reduce using rule 52 (index_mode_list -> index_mode_list COMMA index_mode .)


state 339

    (50) array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .

    LOC             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    RPAREN          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    ASSIGN          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    SEMI            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    COMMA           reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    DCL             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    SYN             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    TYPE            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    ID              reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    IF              reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    DO              reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    EXIT            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    RETURN          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    RESULT          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    NUM             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    PRED            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    SUCC            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    UPPER           reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    LOWER           reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    LENGTH          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    READ            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    PRINT           reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    $end            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)
    END             reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode COMMA index_mode_list RBRACKET element_mode .)


state 340

    (185) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_list END .

    SEMI            reduce using rule 185 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_list END .)


state 341

    (190) result_spec -> RETURNS LPAREN parameter_spec . RPAREN

    RPAREN          shift and go to state 343


state 342

    (184) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list . END
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) statement -> . procedure_statement
    (8) statement -> . action_statement
    (9) declaration_statement -> . DCL declaration_list SEMI
    (18) synonym_statement -> . SYN synonym_list SEMI
    (24) newmode_statement -> . TYPE newmode_list
    (183) procedure_statement -> . identifier COLON procedure_definition SEMI
    (117) action_statement -> . identifier COLON action SEMI
    (118) action_statement -> . action SEMI
    (17) identifier -> . ID
    (119) action -> . if_action
    (120) action -> . do_action
    (121) action -> . assignment_action
    (122) action -> . call_action
    (123) action -> . exit_action
    (124) action -> . return_action
    (125) action -> . result_action
    (135) if_action -> . IF boolean_expression then_clause else_clause FI
    (136) if_action -> . IF boolean_expression then_clause FI
    (143) do_action -> . DO control_part SEMI action_statement OD
    (144) do_action -> . DO control_part SEMI OD
    (145) do_action -> . DO action_statement OD
    (126) assignment_action -> . location assigning_operator expression
    (127) assignment_action -> . identifier assigning_operator expression
    (163) call_action -> . procedure_call
    (164) call_action -> . builtin_call
    (169) exit_action -> . EXIT identifier
    (170) return_action -> . RETURN expression
    (171) return_action -> . RETURN
    (172) result_action -> . RESULT expression
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (61) location -> . call_action
    (165) procedure_call -> . identifier LPAREN parameter_list RPAREN
    (166) procedure_call -> . identifier LPAREN RPAREN
    (173) builtin_call -> . builtin_name LPAREN parameter_list RPAREN
    (174) builtin_call -> . builtin_name LPAREN RPAREN
    (62) dereferenced_reference -> . location ARROW
    (63) string_element -> . identifier LBRACKET ICONST RBRACKET
    (64) string_slice -> . identifier LBRACKET ICONST COLON ICONST RBRACKET
    (65) array_element -> . location LBRACKET expression_list RBRACKET
    (68) array_slice -> . location LBRACKET ICONST COLON ICONST RBRACKET
    (175) builtin_name -> . NUM
    (176) builtin_name -> . PRED
    (177) builtin_name -> . SUCC
    (178) builtin_name -> . UPPER
    (179) builtin_name -> . LOWER
    (180) builtin_name -> . LENGTH
    (181) builtin_name -> . READ
    (182) builtin_name -> . PRINT

    END             shift and go to state 344
    DCL             shift and go to state 16
    SYN             shift and go to state 36
    TYPE            shift and go to state 35
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 4
    EXIT            shift and go to state 38
    RETURN          shift and go to state 3
    RESULT          shift and go to state 27
    NUM             shift and go to state 29
    PRED            shift and go to state 43
    SUCC            shift and go to state 10
    UPPER           shift and go to state 33
    LOWER           shift and go to state 2
    LENGTH          shift and go to state 17
    READ            shift and go to state 19
    PRINT           shift and go to state 9

    assignment_action              shift and go to state 1
    synonym_statement              shift and go to state 5
    result_action                  shift and go to state 7
    return_action                  shift and go to state 11
    array_element                  shift and go to state 6
    procedure_call                 shift and go to state 12
    do_action                      shift and go to state 13
    if_action                      shift and go to state 14
    string_element                 shift and go to state 15
    procedure_statement            shift and go to state 18
    location                       shift and go to state 21
    call_action                    shift and go to state 25
    builtin_call                   shift and go to state 24
    statement                      shift and go to state 87
    exit_action                    shift and go to state 28
    newmode_statement              shift and go to state 30
    dereferenced_reference         shift and go to state 34
    builtin_name                   shift and go to state 8
    declaration_statement          shift and go to state 37
    string_slice                   shift and go to state 23
    array_slice                    shift and go to state 39
    action                         shift and go to state 40
    identifier                     shift and go to state 41
    action_statement               shift and go to state 42

state 343

    (190) result_spec -> RETURNS LPAREN parameter_spec RPAREN .

    SEMI            reduce using rule 190 (result_spec -> RETURNS LPAREN parameter_spec RPAREN .)


state 344

    (184) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END .

    SEMI            reduce using rule 184 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_list END .)

